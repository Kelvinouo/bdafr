-- Decompiled with the Synapse X Luau decompiler.

local u1 = typeof or type;
local function v1(p1)
	return function(p2)
		if u1(p2) == p1 then
			return true;
		end;
		return false;
	end;
end;
local v2 = {
	any = function(p3)
		if p3 ~= nil then
			return true;
		end;
		return false;
	end, 
	boolean = v1("boolean"), 
	thread = v1("thread"), 
	callback = v1("function")
};
v2["function"] = v2.callback;
v2.none = v1("nil");
v2.nil = v2.none;
v2.string = v1("string");
v2.table = v1("table");
v2.userdata = v1("userdata");
function v2.number(p4)
	if u1(p4) ~= "number" then
		return false;
	end;
	if p4 == p4 then
		return true;
	end;
	return false;
end;
function v2.nan(p5)
	if p5 ~= p5 then
		return true;
	end;
	return false;
end;
v2.Axes = v1("Axes");
v2.BrickColor = v1("BrickColor");
v2.CFrame = v1("CFrame");
v2.Color3 = v1("Color3");
v2.ColorSequence = v1("ColorSequence");
v2.ColorSequenceKeypoint = v1("ColorSequenceKeypoint");
v2.DockWidgetPluginGuiInfo = v1("DockWidgetPluginGuiInfo");
v2.Faces = v1("Faces");
v2.Instance = v1("Instance");
v2.NumberRange = v1("NumberRange");
v2.NumberSequence = v1("NumberSequence");
v2.NumberSequenceKeypoint = v1("NumberSequenceKeypoint");
v2.PathWaypoint = v1("PathWaypoint");
v2.PhysicalProperties = v1("PhysicalProperties");
v2.Random = v1("Random");
v2.Ray = v1("Ray");
v2.Rect = v1("Rect");
v2.Region3 = v1("Region3");
v2.Region3int16 = v1("Region3int16");
v2.TweenInfo = v1("TweenInfo");
v2.UDim = v1("UDim");
v2.UDim2 = v1("UDim2");
v2.Vector2 = v1("Vector2");
v2.Vector3 = v1("Vector3");
v2.Vector3int16 = v1("Vector3int16");
v2.Enum = v1("Enum");
v2.EnumItem = v1("EnumItem");
v2.RBXScriptSignal = v1("RBXScriptSignal");
v2.RBXScriptConnection = v1("RBXScriptConnection");
function v2.literal(...)
	local v3 = select("#", ...);
	if v3 == 1 then
		local u2 = ...;
		return function(p6)
			if p6 ~= u2 then
				return false;
			end;
			return true;
		end;
	end;
	local v4 = {};
	for v5 = 1, v3 do
		v4[v5] = v2.literal((select(v5, ...)));
	end;
	return v2.union(table.unpack(v4, 1, v3));
end;
v2.exactly = v2.literal;
function v2.keyOf(p7)
	local v6 = {};
	local v7 = 0;
	for v8, v9 in pairs(p7) do
		v7 = v7 + 1;
		v6[v7] = v8;
	end;
	return v2.literal(table.unpack(v6, 1, v7));
end;
function v2.valueOf(p8)
	local v10 = {};
	local v11 = 0;
	for v12, v13 in pairs(p8) do
		v11 = v11 + 1;
		v10[v11] = v13;
	end;
	return v2.literal(table.unpack(v10, 1, v11));
end;
function v2.integer(p9)
	if not v2.number(p9) then
		return false;
	end;
	if p9 % 1 == 0 then
		return true;
	end;
	return false;
end;
function v2.numberMin(p10)
	return function(p11)
		if not v2.number(p11) then
			return false;
		end;
		if p10 <= p11 then
			return true;
		end;
		return false;
	end;
end;
function v2.numberMax(p12)
	return function(p13)
		if not v2.number(p13) then
			return false;
		end;
		if p13 <= p12 then
			return true;
		end;
		return false;
	end;
end;
function v2.numberMinExclusive(p14)
	return function(p15)
		if not v2.number(p15) then
			return false;
		end;
		if p14 < p15 then
			return true;
		end;
		return false;
	end;
end;
function v2.numberMaxExclusive(p16)
	return function(p17)
		if not v2.number(p17) then
			return false;
		end;
		if p17 < p16 then
			return true;
		end;
		return false;
	end;
end;
v2.numberPositive = v2.numberMinExclusive(0);
v2.numberNegative = v2.numberMaxExclusive(0);
function v2.numberConstrained(p18, p19)
	assert(v2.number(p18));
	assert(v2.number(p19));
	local u3 = v2.numberMin(p18);
	local u4 = v2.numberMax(p19);
	return function(p20)
		if not u3(p20) then
			return false;
		end;
		if not u4(p20) then
			return false;
		end;
		return true;
	end;
end;
function v2.numberConstrainedExclusive(p21, p22)
	assert(v2.number(p21));
	assert(v2.number(p22));
	local u5 = v2.numberMinExclusive(p21);
	local u6 = v2.numberMaxExclusive(p22);
	return function(p23)
		if not u5(p23) then
			return false;
		end;
		if not u6(p23) then
			return false;
		end;
		return true;
	end;
end;
function v2.match(p24)
	assert(v2.string(p24));
	return function(p25)
		if not v2.string(p25) then
			return false;
		end;
		if string.match(p25, p24) == nil then
			return false;
		end;
		return true;
	end;
end;
function v2.optional(p26)
	assert(v2.callback(p26));
	return function(p27)
		if p27 == nil then
			return true;
		end;
		if p26(p27) then
			return true;
		end;
		return false;
	end;
end;
function v2.tuple(...)
	local u7 = { ... };
	return function(...)
		local v14 = { ... };
		for v15, v16 in ipairs(u7) do
			if v16(v14[v15]) == false then
				return false;
			end;
		end;
		return true;
	end;
end;
function v2.keys(p28)
	assert(v2.callback(p28));
	return function(p29)
		if v2.table(p29) == false then
			return false;
		end;
		for v17, v18 in pairs(p29) do
			if p28(v17) == false then
				return false;
			end;
		end;
		return true;
	end;
end;
function v2.values(p30)
	assert(v2.callback(p30));
	return function(p31)
		if v2.table(p31) == false then
			return false;
		end;
		for v19, v20 in pairs(p31) do
			if p30(v20) == false then
				return false;
			end;
		end;
		return true;
	end;
end;
function v2.map(p32, p33)
	assert(v2.callback(p32));
	assert(v2.callback(p33));
	local u8 = v2.keys(p32);
	local u9 = v2.values(p33);
	return function(p34)
		if not u8(p34) then
			return false;
		end;
		if not u9(p34) then
			return false;
		end;
		return true;
	end;
end;
function v2.set(p35)
	return v2.map(p35, v2.literal(true));
end;
local u10 = v2.keys(v2.integer);
function v2.array(p36)
	assert(v2.callback(p36));
	local u11 = v2.values(p36);
	return function(p37)
		if u10(p37) == false then
			return false;
		end;
		local v21 = 0;
		for v22, v23 in ipairs(p37) do
			v21 = v21 + 1;
		end;
		for v24, v25 in pairs(p37) do
			if v24 < 1 then
				return false;
			end;
			if v21 < v24 then
				return false;
			end;
		end;
		if not u11(p37) then
			return false;
		end;
		return true;
	end;
end;
function v2.strictArray(...)
	local v26 = { ... };
	assert(v2.array(v2.callback)(v26));
	return function(p38)
		if u10(p38) == false then
			return false;
		end;
		if #v26 < #p38 then
			return false;
		end;
		for v27, v28 in pairs(v26) do
			if not v28(p38[v27]) then
				return false;
			end;
		end;
		return true;
	end;
end;
u10 = v2.array;
u10 = u10(v2.callback);
function v2.union(...)
	local v29 = { ... };
	assert(u10(v29));
	return function(p39)
		for v30, v31 in ipairs(v29) do
			if v31(p39) then
				return true;
			end;
		end;
		return false;
	end;
end;
v2.some = v2.union;
function v2.intersection(...)
	local v32 = { ... };
	assert(u10(v32));
	return function(p40)
		for v33, v34 in ipairs(v32) do
			if not v34(p40) then
				return false;
			end;
		end;
		return true;
	end;
end;
v2.every = v2.intersection;
u10 = v2.map;
u10 = u10(v2.any, v2.callback);
function v2.interface(p41)
	assert(u10(p41));
	return function(p42)
		if v2.table(p42) == false then
			return false;
		end;
		for v35, v36 in pairs(p41) do
			if v36(p42[v35]) == false then
				return false;
			end;
		end;
		return true;
	end;
end;
function v2.strictInterface(p43)
	assert(u10(p43));
	return function(p44)
		if v2.table(p44) == false then
			return false;
		end;
		for v37, v38 in pairs(p43) do
			if v38(p44[v37]) == false then
				return false;
			end;
		end;
		for v39, v40 in pairs(p44) do
			if not p43[v39] then
				return false;
			end;
		end;
		return true;
	end;
end;
u10 = function(p45, p46)
	assert(v2.string(p45));
	local v41 = nil;
	if p46 ~= nil then
		v41 = v2.children(p46);
	end;
	return function(p47)
		if not v2.Instance(p47) then
			return false;
		end;
		if p47.ClassName ~= p45 then
			return false;
		end;
		if v41 and not v41(p47) then
			return false;
		end;
		return true;
	end;
end;
v2.instanceOf = u10;
u10 = v2.instanceOf;
v2.instance = u10;
u10 = function(p48, p49)
	assert(v2.string(p48));
	local v42 = nil;
	if p49 ~= nil then
		v42 = v2.children(p49);
	end;
	return function(p50)
		if not v2.Instance(p50) then
			return false;
		end;
		if not p50:IsA(p48) then
			return false;
		end;
		if v42 and not v42(p50) then
			return false;
		end;
		return true;
	end;
end;
v2.instanceIsA = u10;
u10 = function(p51)
	assert(v2.Enum(p51));
	return function(p52)
		if not v2.EnumItem(p52) then
			return false;
		end;
		if p52.EnumType == p51 then
			return true;
		end;
		return false;
	end;
end;
v2.enum = u10;
u10 = v2.tuple;
u10 = u10(v2.callback, v2.callback);
function v2.wrap(p53, p54)
	assert(u10(p53, p54));
	return function(...)
		assert(p54(...));
		return p53(...);
	end;
end;
u10 = function(p55)
	return function(...)
		assert(p55(...));
	end;
end;
v2.strict = u10;
u10 = v2.map;
u10 = u10(v2.string, v2.callback);
function v2.children(p56)
	assert(u10(p56));
	return function(p57)
		if not v2.Instance(p57) then
			return false;
		end;
		local v43 = {};
		for v44, v45 in ipairs(p57:GetChildren()) do
			local l__Name__46 = v45.Name;
			if p56[l__Name__46] then
				if v43[l__Name__46] then
					return false;
				end;
				v43[l__Name__46] = v45;
			end;
		end;
		for v47, v48 in pairs(p56) do
			if not v48(v43[v47]) then
				return false;
			end;
		end;
		return true;
	end;
end;
u10 = {
	t = v2
};
return u10;
