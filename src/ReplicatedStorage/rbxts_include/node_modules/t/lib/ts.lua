-- Decompiled with the Synapse X Luau decompiler.

local v1 = {
	type = function(p1)
		return function(p2)
			if type(p2) == p1 then
				return true;
			end;
			return false;
		end;
	end, 
	typeof = function(p3)
		return function(p4)
			if typeof(p4) == p3 then
				return true;
			end;
			return false;
		end;
	end, 
	any = function(p5)
		if p5 ~= nil then
			return true;
		end;
		return false;
	end
};
v1.boolean = v1.typeof("boolean");
v1.thread = v1.typeof("thread");
v1.callback = v1.typeof("function");
v1["function"] = v1.callback;
v1.none = v1.typeof("nil");
v1.nil = v1.none;
v1.string = v1.typeof("string");
v1.table = v1.typeof("table");
v1.userdata = v1.type("userdata");
function v1.number(p6)
	if typeof(p6) ~= "number" then
		return false;
	end;
	if p6 == p6 then
		return true;
	end;
	return false;
end;
function v1.nan(p7)
	if typeof(p7) ~= "number" then
		return false;
	end;
	if p7 ~= p7 then
		return true;
	end;
	return false;
end;
v1.Axes = v1.typeof("Axes");
v1.BrickColor = v1.typeof("BrickColor");
v1.CatalogSearchParams = v1.typeof("CatalogSearchParams");
v1.CFrame = v1.typeof("CFrame");
v1.Color3 = v1.typeof("Color3");
v1.ColorSequence = v1.typeof("ColorSequence");
v1.ColorSequenceKeypoint = v1.typeof("ColorSequenceKeypoint");
v1.DateTime = v1.typeof("DateTime");
v1.DockWidgetPluginGuiInfo = v1.typeof("DockWidgetPluginGuiInfo");
v1.Enum = v1.typeof("Enum");
v1.EnumItem = v1.typeof("EnumItem");
v1.Enums = v1.typeof("Enums");
v1.Faces = v1.typeof("Faces");
v1.Instance = v1.typeof("Instance");
v1.NumberRange = v1.typeof("NumberRange");
v1.NumberSequence = v1.typeof("NumberSequence");
v1.NumberSequenceKeypoint = v1.typeof("NumberSequenceKeypoint");
v1.PathWaypoint = v1.typeof("PathWaypoint");
v1.PhysicalProperties = v1.typeof("PhysicalProperties");
v1.Random = v1.typeof("Random");
v1.Ray = v1.typeof("Ray");
v1.RaycastParams = v1.typeof("RaycastParams");
v1.RaycastResult = v1.typeof("RaycastResult");
v1.RBXScriptConnection = v1.typeof("RBXScriptConnection");
v1.RBXScriptSignal = v1.typeof("RBXScriptSignal");
v1.Rect = v1.typeof("Rect");
v1.Region3 = v1.typeof("Region3");
v1.Region3int16 = v1.typeof("Region3int16");
v1.TweenInfo = v1.typeof("TweenInfo");
v1.UDim = v1.typeof("UDim");
v1.UDim2 = v1.typeof("UDim2");
v1.Vector2 = v1.typeof("Vector2");
v1.Vector2int16 = v1.typeof("Vector2int16");
v1.Vector3 = v1.typeof("Vector3");
v1.Vector3int16 = v1.typeof("Vector3int16");
function v1.literal(...)
	local v2 = select("#", ...);
	if v2 == 1 then
		local u1 = ...;
		return function(p8)
			if p8 ~= u1 then
				return false;
			end;
			return true;
		end;
	end;
	local v3 = {};
	for v4 = 1, v2 do
		v3[v4] = v1.literal((select(v4, ...)));
	end;
	return v1.union(table.unpack(v3, 1, v2));
end;
v1.exactly = v1.literal;
function v1.keyOf(p9)
	local v5 = {};
	local v6 = 0;
	for v7 in pairs(p9) do
		v6 = v6 + 1;
		v5[v6] = v7;
	end;
	return v1.literal(table.unpack(v5, 1, v6));
end;
function v1.valueOf(p10)
	local v8 = {};
	local v9 = 0;
	for v10, v11 in pairs(p10) do
		v9 = v9 + 1;
		v8[v9] = v11;
	end;
	return v1.literal(table.unpack(v8, 1, v9));
end;
function v1.integer(p11)
	if not v1.number(p11) then
		return false;
	end;
	if p11 % 1 == 0 then
		return true;
	end;
	return false;
end;
function v1.numberMin(p12)
	return function(p13)
		if not v1.number(p13) then
			return false;
		end;
		if p12 <= p13 then
			return true;
		end;
		return false;
	end;
end;
function v1.numberMax(p14)
	return function(p15)
		if not v1.number(p15) then
			return false;
		end;
		if p15 <= p14 then
			return true;
		end;
		return false;
	end;
end;
function v1.numberMinExclusive(p16)
	return function(p17)
		if not v1.number(p17) then
			return false;
		end;
		if p16 < p17 then
			return true;
		end;
		return false;
	end;
end;
function v1.numberMaxExclusive(p18)
	return function(p19)
		if not v1.number(p19) then
			return false;
		end;
		if p19 < p18 then
			return true;
		end;
		return false;
	end;
end;
v1.numberPositive = v1.numberMinExclusive(0);
v1.numberNegative = v1.numberMaxExclusive(0);
function v1.numberConstrained(p20, p21)
	assert(v1.number(p20));
	assert(v1.number(p21));
	local u2 = v1.numberMin(p20);
	local u3 = v1.numberMax(p21);
	return function(p22)
		if not u2(p22) then
			return false;
		end;
		if not u3(p22) then
			return false;
		end;
		return true;
	end;
end;
function v1.numberConstrainedExclusive(p23, p24)
	assert(v1.number(p23));
	assert(v1.number(p24));
	local u4 = v1.numberMinExclusive(p23);
	local u5 = v1.numberMaxExclusive(p24);
	return function(p25)
		if not u4(p25) then
			return false;
		end;
		if not u5(p25) then
			return false;
		end;
		return true;
	end;
end;
function v1.match(p26)
	assert(v1.string(p26));
	return function(p27)
		if not v1.string(p27) then
			return false;
		end;
		if string.match(p27, p26) == nil then
			return false;
		end;
		return true;
	end;
end;
function v1.optional(p28)
	assert(v1.callback(p28));
	return function(p29)
		if p29 == nil then
			return true;
		end;
		if p28(p29) then
			return true;
		end;
		return false;
	end;
end;
function v1.tuple(...)
	local u6 = { ... };
	return function(...)
		local v12 = { ... };
		local v13, v14, v15 = ipairs(u6);
		while true do
			v13(v14, v15);
			if not v13 then
				break;
			end;
			v15 = v13;
			if v14(v12[v13]) == false then
				return false;
			end;		
		end;
		return true;
	end;
end;
function v1.keys(p30)
	assert(v1.callback(p30));
	return function(p31)
		if v1.table(p31) == false then
			return false;
		end;
		for v16 in pairs(p31) do
			if p30(v16) == false then
				return false;
			end;
		end;
		return true;
	end;
end;
function v1.values(p32)
	assert(v1.callback(p32));
	return function(p33)
		if v1.table(p33) == false then
			return false;
		end;
		for v17, v18 in pairs(p33) do
			if p32(v18) == false then
				return false;
			end;
		end;
		return true;
	end;
end;
function v1.map(p34, p35)
	assert(v1.callback(p34));
	assert(v1.callback(p35));
	local u7 = v1.keys(p34);
	local u8 = v1.values(p35);
	return function(p36)
		if not u7(p36) then
			return false;
		end;
		if not u8(p36) then
			return false;
		end;
		return true;
	end;
end;
function v1.set(p37)
	return v1.map(p37, v1.literal(true));
end;
local u9 = v1.keys(v1.integer);
function v1.array(p38)
	assert(v1.callback(p38));
	local u10 = v1.values(p38);
	return function(p39)
		if u9(p39) == false then
			return false;
		end;
		local v19 = 0;
		local v20, v21, v22 = ipairs(p39);
		while true do
			v20(v21, v22);
			if not v20 then
				break;
			end;
			v22 = v20;
			v19 = v19 + 1;		
		end;
		for v23 in pairs(p39) do
			if v23 < 1 then
				return false;
			end;
			if v19 < v23 then
				return false;
			end;
		end;
		if not u10(p39) then
			return false;
		end;
		return true;
	end;
end;
function v1.strictArray(...)
	local v24 = { ... };
	assert(v1.array(v1.callback)(v24));
	return function(p40)
		if u9(p40) == false then
			return false;
		end;
		if #v24 < #p40 then
			return false;
		end;
		for v25, v26 in pairs(v24) do
			if not v26(p40[v25]) then
				return false;
			end;
		end;
		return true;
	end;
end;
u9 = v1.array;
u9 = u9(v1.callback);
function v1.union(...)
	local v27 = { ... };
	assert(u9(v27));
	return function(p41)
		local v28, v29, v30 = ipairs(v27);
		while true do
			v28(v29, v30);
			if not v28 then
				break;
			end;
			v30 = v28;
			if v29(p41) then
				return true;
			end;		
		end;
		return false;
	end;
end;
v1.some = v1.union;
function v1.intersection(...)
	local v31 = { ... };
	assert(u9(v31));
	return function(p42)
		local v32, v33, v34 = ipairs(v31);
		while true do
			v32(v33, v34);
			if not v32 then
				break;
			end;
			v34 = v32;
			if not v33(p42) then
				return false;
			end;		
		end;
		return true;
	end;
end;
v1.every = v1.intersection;
u9 = v1.map;
u9 = u9(v1.any, v1.callback);
function v1.interface(p43)
	assert(u9(p43));
	return function(p44)
		if v1.table(p44) == false then
			return false;
		end;
		for v35, v36 in pairs(p43) do
			if v36(p44[v35]) == false then
				return false;
			end;
		end;
		return true;
	end;
end;
function v1.strictInterface(p45)
	assert(u9(p45));
	return function(p46)
		if v1.table(p46) == false then
			return false;
		end;
		for v37, v38 in pairs(p45) do
			if v38(p46[v37]) == false then
				return false;
			end;
		end;
		for v39 in pairs(p46) do
			if not p45[v39] then
				return false;
			end;
		end;
		return true;
	end;
end;
u9 = function(p47, p48)
	assert(v1.string(p47));
	local v40 = nil;
	if p48 ~= nil then
		v40 = v1.children(p48);
	end;
	return function(p49)
		if not v1.Instance(p49) then
			return false;
		end;
		if p49.ClassName ~= p47 then
			return false;
		end;
		if v40 and not v40(p49) then
			return false;
		end;
		return true;
	end;
end;
v1.instanceOf = u9;
u9 = v1.instanceOf;
v1.instance = u9;
u9 = function(p50, p51)
	assert(v1.string(p50));
	local v41 = nil;
	if p51 ~= nil then
		v41 = v1.children(p51);
	end;
	return function(p52)
		if not v1.Instance(p52) then
			return false;
		end;
		if not p52:IsA(p50) then
			return false;
		end;
		if v41 and not v41(p52) then
			return false;
		end;
		return true;
	end;
end;
v1.instanceIsA = u9;
u9 = function(p53)
	assert(v1.Enum(p53));
	return function(p54)
		if not v1.EnumItem(p54) then
			return false;
		end;
		if p54.EnumType == p53 then
			return true;
		end;
		return false;
	end;
end;
v1.enum = u9;
u9 = v1.tuple;
u9 = u9(v1.callback, v1.callback);
function v1.wrap(p55, p56)
	assert(u9(p55, p56));
	return function(...)
		assert(p56(...));
		return p55(...);
	end;
end;
u9 = function(p57)
	return function(...)
		assert(p57(...));
	end;
end;
v1.strict = u9;
u9 = v1.map;
u9 = u9(v1.string, v1.callback);
function v1.children(p58)
	assert(u9(p58));
	return function(p59)
		if not v1.Instance(p59) then
			return false;
		end;
		local v42 = {};
		local v43, v44, v45 = ipairs(p59:GetChildren());
		while true do
			v43(v44, v45);
			if not v43 then
				break;
			end;
			v45 = v43;
			local l__Name__46 = v44.Name;
			if p58[l__Name__46] then
				if v42[l__Name__46] then
					return false;
				end;
				v42[l__Name__46] = v44;
			end;		
		end;
		for v47, v48 in pairs(p58) do
			if not v48(v42[v47]) then
				return false;
			end;
		end;
		return true;
	end;
end;
u9 = {
	t = v1
};
return u9;
