-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
local function u1(p1)
	assert(type(p1) == "table", "First argument must be a table");
	local v2 = table.create(#p1);
	for v3, v4 in pairs(p1) do
		if type(v4) == "table" then
			v2[v3] = u1(v4);
		else
			v2[v3] = v4;
		end;
	end;
	return v2;
end;
local function u2(p2, p3)
	assert(type(p2) == "table", "First argument must be a table");
	assert(type(p3) == "table", "Second argument must be a table");
	for v5, v6 in pairs(p2) do
		local v7 = p3[v5];
		if v7 == nil then
			p2[v5] = nil;
		elseif type(v6) ~= type(v7) then
			if type(v7) == "table" then
				p2[v5] = u1(v7);
			else
				p2[v5] = v7;
			end;
		elseif type(v6) == "table" then
			u2(v6, v7);
		end;
	end;
	for v8, v9 in pairs(p3) do
		if p2[v8] == nil then
			if type(v9) == "table" then
				p2[v8] = u1(v9);
			else
				p2[v8] = v9;
			end;
		end;
	end;
end;
local l__HttpService__3 = game:GetService("HttpService");
local l__table_find__4 = table.find;
local function u5(p4, p5)
	local v10 = #p4;
	p4[p5] = p4[v10];
	p4[v10] = nil;
end;
v1.Copy = u1;
function v1.CopyShallow(p6)
	local v11 = table.create(#p6);
	for v12, v13 in pairs(p6) do
		v11[v12] = v13;
	end;
	return v11;
end;
v1.Sync = u2;
v1.FastRemove = u5;
function v1.FastRemoveFirstValue(p7, p8)
	local v14 = l__table_find__4(p7, p8);
	if not v14 then
		return false, nil;
	end;
	u5(p7, v14);
	return true, v14;
end;
function v1.Print(p9, p10, p11)
	local v15 = p9;
	assert(type(v15) == "table", "First argument must be a table");
	local v16 = true;
	if p10 ~= nil then
		v15 = p10;
		v16 = type(v15) == "string";
	end;
	assert(v16, "Second argument must be a string or nil");
	p10 = p10 and "TABLE";
	local u6 = {};
	local function u7(p12, p13)
		u6[#u6 + 1] = (" - "):rep(p13) .. p12 .. "\n";
	end;
	local function u8(p14, p15)
		return tostring(p14.k) < tostring(p15.k);
	end;
	local function u9(p16, p17, p18)
		u7(p18 .. ":", p17 - 1);
		local v17 = {};
		local v18 = {};
		local v19 = 0;
		local v20, v21, v22 = pairs(p16);
		while true do
			local v23, v24 = v20(v21, v22);
			if not v23 then
				break;
			end;
			if type(v24) == "table" then
				table.insert(v18, {
					k = v23, 
					v = v24
				});
			else
				table.insert(v17, {
					k = v23, 
					v = "[" .. typeof(v24) .. "] " .. tostring(v24)
				});
			end;
			local v25 = #tostring(v23) + 1;
			if v19 < v25 then
				v19 = v25;
			end;		
		end;
		table.sort(v17, u8);
		table.sort(v18, u8);
		for v26, v27 in ipairs(v17) do
			u7(tostring(v27.k) .. ":" .. (" "):rep(v19 - #tostring(v27.k)) .. v27.v, p17);
		end;
		if not p11 then
			for v28, v29 in ipairs(v18) do
				u7(tostring(v29.k) .. ":" .. (" "):rep(v19 - #tostring(v29.k)) .. "[Table]", p17);
			end;
			return;
		end;
		for v30, v31 in ipairs(v18) do
			u9(v31.v, p17 + 1, tostring(v31.k) .. (" "):rep(v19 - #tostring(v31.k)) .. " [Table]");
		end;
	end;
	u9(p9, 1, p10);
	print(table.concat(u6, ""));
end;
function v1.Map(p19, p20)
	assert(type(p19) == "table", "First argument must be a table");
	assert(type(p20) == "function", "Second argument must be a function");
	local v32 = table.create(#p19);
	for v33, v34 in pairs(p19) do
		v32[v33] = p20(v34, v33, p19);
	end;
	return v32;
end;
function v1.Filter(p21, p22)
	assert(type(p21) == "table", "First argument must be a table");
	assert(type(p22) == "function", "Second argument must be a function");
	local v35 = table.create(#p21);
	if #p21 > 0 then
		for v36, v37 in ipairs(p21) do
			if p22(v37, v36, p21) then
				v35[v36] = v37;
			end;
		end;
		return v35;
	end;
	for v38, v39 in pairs(p21) do
		if p22(v39, v38, p21) then
			v35[v38] = v39;
		end;
	end;
	return v35;
end;
function v1.Reduce(p23, p24, p25)
	assert(type(p23) == "table", "First argument must be a table");
	assert(type(p24) == "function", "Second argument must be a function");
	local v40 = true;
	if p25 ~= nil then
		v40 = type(p25) == "number";
	end;
	assert(v40, "Third argument must be a number or nil");
	local v41 = p25 and 0;
	for v42, v43 in pairs(p23) do
		v41 = p24(v41, v43, v42, p23);
	end;
	return v41;
end;
function v1.Assign(p26, ...)
	for v44, v45 in ipairs({ ... }) do
		for v46, v47 in pairs(v45) do
			p26[v46] = v47;
		end;
	end;
	return p26;
end;
function v1.Extend(p27, p28)
	for v48, v49 in pairs(p28) do
		p27[v48] = v49;
	end;
end;
v1.IndexOf = l__table_find__4;
function v1.Reverse(p29)
	local v50 = #p29;
	local v51 = table.create(v50);
	for v52 = 1, v50 do
		v51[v52] = p29[v50 - v52 + 1];
	end;
	return v51;
end;
function v1.Shuffle(p30)
	assert(type(p30) == "table", "First argument must be a table");
	local v53 = Random.new();
	for v54 = #p30, 2, -1 do
		local v55 = v53:NextInteger(1, v54);
		p30[v54] = p30[v55];
		p30[v55] = p30[v54];
	end;
end;
function v1.IsEmpty(p31)
	return next(p31) == nil;
end;
function v1.EncodeJSON(p32)
	return l__HttpService__3:JSONEncode(p32);
end;
function v1.DecodeJSON(p33)
	return l__HttpService__3:JSONDecode(p33);
end;
return v1;
