-- Decompiled with the Synapse X Luau decompiler.

local v1 = setmetatable({}, {
	__tostring = function()
		return "ScaleSpecifier";
	end
});
v1.__index = v1;
function v1.new(...)
	local v2 = setmetatable({}, v1);
	return v2:constructor(...) and v2;
end;
local function u1(p1)
	local v3 = nil;
	local v4 = #p1;
	if v4 == 0 then
		return 0;
	end;
	v3 = 0;
	for v5 = 1, #p1 do
		v3 = v3 + p1[v5];
	end;
	return local v6 / v4;
end;
function v1.constructor(p2, p3)
	p2._scaleInput = p3;
	local v7 = typeof(p3);
	p2.isNumber = v7 == "number";
	p2.isVector2 = v7 == "Vector2";
	p2.isVector3 = v7 == "Vector3";
	p2.isScaleSpec = not p2.isNumber and (not p2.isVector2 and not p2.isVector3);
	if p2.isNumber then
		local l___scaleInput__8 = p2._scaleInput;
		p2.asNumber = l___scaleInput__8;
		p2.asVector2 = Vector2.new(l___scaleInput__8, l___scaleInput__8);
		p2.asVector3 = Vector3.new(l___scaleInput__8, l___scaleInput__8, l___scaleInput__8);
		p2.asScaleSpec = p2;
		return;
	end;
	if p2.isVector2 then
		local l___scaleInput__9 = p2._scaleInput;
		p2.asNumber = u1({ l___scaleInput__9.X, l___scaleInput__9.Y });
		p2.asVector2 = l___scaleInput__9;
		p2.asVector3 = Vector3.new(l___scaleInput__9.X, l___scaleInput__9.Y, p2.asNumber);
		p2.asScaleSpec = p2;
		return;
	end;
	if not p2.isVector3 then
		if p2.isScaleSpec then
			local l___scaleInput__10 = p2._scaleInput;
			p2.asNumber = l___scaleInput__10.asNumber;
			p2.asVector2 = l___scaleInput__10.asVector2;
			p2.asVector3 = l___scaleInput__10.asVector3;
			p2.asScaleSpec = l___scaleInput__10;
		end;
		return;
	end;
	local l___scaleInput__11 = p2._scaleInput;
	p2.asNumber = u1({ l___scaleInput__11.X, l___scaleInput__11.Y, l___scaleInput__11.Z });
	p2.asVector2 = Vector2.new(l___scaleInput__11.X, l___scaleInput__11.Y);
	p2.asVector3 = l___scaleInput__11;
	p2.asScaleSpec = p2;
end;
local u2 = nil;
local u3 = nil;
local u4 = nil;
local function u5(p4, p5, p6)
	local v12 = p4 - p5;
	local l__asVector3__13 = p6.asVector3;
	return Vector3.new(p5.X + v12.X * l__asVector3__13.X, p5.Y + v12.Y * l__asVector3__13.Y, p5.Z + v12.Z * l__asVector3__13.Z);
end;
local function u6(p7)
	local v14 = {};
	for v15, v16 in ipairs((p7:GetDescendants())) do
		if v16:IsA("WeldConstraint") then
			v14[v16] = v16.Enabled;
			v16.Enabled = false;
		end;
	end;
	return v14;
end;
local function u7(p8, p9, p10)
	if p9 == 1 then
		return nil;
	end;
	if p10 and typeof(p10) == "Vector3" then
		local v17 = p10;
	else
		local l__PrimaryPart__18 = p8.PrimaryPart;
		if not l__PrimaryPart__18 then
			print("Unable to scale model, no center nor PrimaryPart has been defined");
			return nil;
		end;
		v17 = u2(p10, p8:GetExtentsSize(), l__PrimaryPart__18.Position);
	end;
	u3(p8, p9, v17);
end;
local u8 = nil;
local function u9(p11, p12, p13)
	if p12 == 1 then
		return nil;
	end;
	if p13 and typeof(p13) == "Vector3" then
		local v19 = p13;
	else
		local l__Handle__20 = p11:FindFirstChild("Handle");
		if not l__Handle__20 then
			print("Unable to scale tool, no center nor Handle has been defined");
			return nil;
		end;
		v19 = u2(p13, l__Handle__20.Size, l__Handle__20.Position);
	end;
	u3(p11, p12, v19);
end;
local u10 = nil;
local u11 = nil;
local u12 = nil;
local u13 = nil;
local function u14(p14)
	for v21, v22 in pairs(p14) do
		v21.Enabled = v22;
	end;
end;
u3 = function(p15, p16, p17, p18)
	if p18 == nil then
		p18 = false;
	end;
	if p16 == 1 then
		return nil;
	end;
	if p18 then
		local v23 = nil;
	else
		v23 = u6(p15);
	end;
	local v24, v25, v26 = ipairs((p15:GetChildren()));
	while true do
		local v27, v28 = v24(v25, v26);
		if not v27 then
			break;
		end;
		local v29 = false;
		if v28:IsA("BasePart") then
			u4(v28, p16, p17);
		elseif v28:IsA("Model") then
			u7(v28, p16, p17);
			v29 = true;
		elseif v28:IsA("Attachment") then
			u8(v28, p16, p17);
		elseif v28:IsA("Tool") then
			u9(v28, p16, p17);
			v29 = true;
		elseif v28:IsA("SpecialMesh") then
			u10(v28, p16, p17);
		elseif v28:IsA("Fire") then
			u11(v28, p16, p17);
		elseif v28:IsA("Explosion") then
			if p16 ~= 1 then
				local v30 = v1.new(p16);
				if v30.isVector3 then
					local v31 = v28.Position * v30.asVector3;
				else
					v31 = v28.Position * v30.asNumber;
				end;
				v28.Position = v31;
				v28.BlastPressure = v28.BlastPressure * v30.asNumber;
				v28.BlastRadius = v28.BlastRadius * v30.asNumber;
			end;
		elseif v28:IsA("ParticleEmitter") then
			u12(v28, p16);
		elseif v28:IsA("Texture") then
			u13(v28, p16, p17);
		end;
		if not v29 then
			u3(v28, p16, p17, true);
		end;	
	end;
	if v23 then
		u14(v23);
	end;
end;
u13 = function(p19, p20, p21)
	local l__asVector2__32 = v1.new(p20).asVector2;
	p19.OffsetStudsU = p19.OffsetStudsU * l__asVector2__32.X;
	p19.OffsetStudsV = p19.OffsetStudsV * l__asVector2__32.Y;
	p19.StudsPerTileU = p19.StudsPerTileU * l__asVector2__32.X;
	p19.StudsPerTileV = p19.StudsPerTileV * l__asVector2__32.Y;
end;
local u15 = nil;
u2 = function(p22, p23, p24)
	if typeof(p22) == "Vector3" then
		return p22;
	end;
	if not p22 then
		return p24;
	end;
	return u15(p23, p24, p22);
end;
u15 = function(p25, p26, p27)
	local v33 = nil;
	v33 = p25 * 0.5;
	if p27 == Enum.NormalId.Front then
		return Vector3.new(p26.X, p26.Y, p26.Z - v33.Z);
	end;
	if p27 == Enum.NormalId.Back then
		return Vector3.new(p26.X, p26.Y, p26.Z + v33.Z);
	end;
	if p27 == Enum.NormalId.Right then
		return Vector3.new(p26.X + v33.X, p26.Y, p26.Z);
	end;
	if p27 == Enum.NormalId.Left then
		return Vector3.new(p26.X - v33.X, p26.Y, p26.Z);
	end;
	if p27 == Enum.NormalId.Top then
		return Vector3.new(p26.X, p26.Y + v33.Y, p26.Z);
	end;
	if p27 ~= Enum.NormalId.Bottom then
		return p26;
	end;
	return Vector3.new(p26.X, p26.Y - v33.Y, p26.Z);
end;
u4 = function(p28, p29, p30)
	local v34 = v1.new(p29);
	local v35 = p28.Position - p30;
	local l__asVector3__36 = v34.asVector3;
	if v34.isVector3 then
		local v37 = p28.Size * v34.asVector3;
	else
		v37 = p28.Size * v34.asNumber;
	end;
	p28.Size = v37;
	p28.CFrame = CFrame.new((Vector3.new(p30.X + v35.X * l__asVector3__36.X, p30.Y + v35.Y * l__asVector3__36.Y, p30.Z + v35.Z * l__asVector3__36.Z))) * (p28.CFrame - p28.Position);
end;
u8 = function(p31, p32, p33)
	local v38 = p31:FindFirstAncestorWhichIsA("BasePart");
	if v38 then
		local l__Position__39 = v38.Position;
		local v40 = v1.new(p32);
		local v41 = p31.WorldPosition - l__Position__39;
		local l__asVector3__42 = v40.asVector3;
		p31.WorldPosition = Vector3.new(l__Position__39.X + v41.X * l__asVector3__42.X, l__Position__39.Y + v41.Y * l__asVector3__42.Y, l__Position__39.Z + v41.Z * l__asVector3__42.Z);
	end;
end;
u10 = function(p34, p35, p36)
	p34.Scale = p34.Scale * v1.new(p35).asNumber;
end;
u11 = function(p37, p38, p39)
	p37.Size = math.floor(p37.Size * v1.new(p38).asNumber);
end;
local u16 = nil;
u12 = function(p40, p41)
	p40.Size = u16(p40.Size, p41);
end;
u16 = function(p42, p43)
	local l__Keypoints__43 = p42.Keypoints;
	local l__asNumber__17 = v1.new(p43).asNumber;
	local v44 = table.create(#l__Keypoints__43);
	for v45, v46 in ipairs(l__Keypoints__43) do
		v44[v45] = NumberSequenceKeypoint.new(v46.Time, v46.Value * l__asNumber__17, v46.Envelope * l__asNumber__17);
	end;
	return NumberSequence.new(v44);
end;
return {
	scaleModel = u7, 
	scalePart = function(p44, p45, p46)
		if p45 == 1 then
			return nil;
		end;
		local v47 = u2(p46, p44.Size, p44.Position);
		u4(p44, p45, v47);
		u3(p44, p45, v47);
	end, 
	scaleVector = function(p47, p48, p49)
		local v48 = nil;
		if p48 == 1 then
			return p47;
		end;
		v48 = v1.new(p48);
		if p49 then
			return u5(p47, p49, v48);
		end;
		if v48.isVector3 then
			return p47 * v48.asVector3;
		end;
		return p47 * v48.asNumber;
	end, 
	scaleExplosion = function(p50, p51)
		if p51 == 1 then
			return nil;
		end;
		local v49 = v1.new(p51);
		if v49.isVector3 then
			local v50 = p50.Position * v49.asVector3;
		else
			v50 = p50.Position * v49.asNumber;
		end;
		p50.Position = v50;
		p50.BlastPressure = p50.BlastPressure * v49.asNumber;
		p50.BlastRadius = p50.BlastRadius * v49.asNumber;
	end, 
	scaleTool = u9, 
	scaleDescendants = u3, 
	scaleTexture = u13, 
	ScaleSpecifier = v1
};
