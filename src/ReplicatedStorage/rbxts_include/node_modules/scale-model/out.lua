-- Decompiled with the Synapse X Luau decompiler.

local v1 = setmetatable({}, {
	__tostring = function()
		return "ScaleSpecifier";
	end
});
v1.__index = v1;
function v1.new(...)
	local v2 = setmetatable({}, v1);
	return v2:constructor(...) and v2;
end;
local function u1(p1)
	local v3 = nil;
	local v4 = #p1;
	if v4 == 0 then
		return 0;
	end;
	v3 = 0;
	local function v5(p2, p3)
		return p2 + p3;
	end;
	for v6 = 1, #p1 do
		v3 = v5(v3, p1[v6], v6 - 1, p1);
	end;
	return local v7 / v4;
end;
function v1.constructor(p4, p5)
	p4._scaleInput = p5;
	local v8 = typeof(p5);
	p4.isNumber = v8 == "number";
	p4.isVector2 = v8 == "Vector2";
	p4.isVector3 = v8 == "Vector3";
	p4.isScaleSpec = not p4.isNumber and (not p4.isVector2 and not p4.isVector3);
	if p4.isNumber then
		local l___scaleInput__9 = p4._scaleInput;
		p4.asNumber = l___scaleInput__9;
		p4.asVector2 = Vector2.new(l___scaleInput__9, l___scaleInput__9);
		p4.asVector3 = Vector3.new(l___scaleInput__9, l___scaleInput__9, l___scaleInput__9);
		p4.asScaleSpec = p4;
		return;
	end;
	if p4.isVector2 then
		local l___scaleInput__10 = p4._scaleInput;
		p4.asNumber = u1({ l___scaleInput__10.X, l___scaleInput__10.Y });
		p4.asVector2 = l___scaleInput__10;
		p4.asVector3 = Vector3.new(l___scaleInput__10.X, l___scaleInput__10.Y, p4.asNumber);
		p4.asScaleSpec = p4;
		return;
	end;
	if not p4.isVector3 then
		if p4.isScaleSpec then
			local l___scaleInput__11 = p4._scaleInput;
			p4.asNumber = l___scaleInput__11.asNumber;
			p4.asVector2 = l___scaleInput__11.asVector2;
			p4.asVector3 = l___scaleInput__11.asVector3;
			p4.asScaleSpec = l___scaleInput__11;
		end;
		return;
	end;
	local l___scaleInput__12 = p4._scaleInput;
	p4.asNumber = u1({ l___scaleInput__12.X, l___scaleInput__12.Y, l___scaleInput__12.Z });
	p4.asVector2 = Vector2.new(l___scaleInput__12.X, l___scaleInput__12.Y);
	p4.asVector3 = l___scaleInput__12;
	p4.asScaleSpec = p4;
end;
local u2 = nil;
local u3 = nil;
local u4 = nil;
local function u5(p6, p7, p8)
	local v13 = p6 - p7;
	local l__asVector3__14 = p8.asVector3;
	return Vector3.new(p7.X + v13.X * l__asVector3__14.X, p7.Y + v13.Y * l__asVector3__14.Y, p7.Z + v13.Z * l__asVector3__14.Z);
end;
local function u6(p9)
	local v15 = {};
	for v16, v17 in ipairs((p9:GetDescendants())) do
		if v17:IsA("WeldConstraint") then
			v15[v17] = v17.Enabled;
			v17.Enabled = false;
		end;
	end;
	return v15;
end;
local function u7(p10, p11, p12)
	if p11 == 1 then
		return nil;
	end;
	if p12 and typeof(p12) == "Vector3" then
		local v18 = p12;
	else
		local l__PrimaryPart__19 = p10.PrimaryPart;
		if not l__PrimaryPart__19 then
			print("Unable to scale model, no center nor PrimaryPart has been defined");
			return nil;
		end;
		v18 = u2(p12, p10:GetExtentsSize(), l__PrimaryPart__19.Position);
	end;
	u3(p10, p11, v18);
end;
local u8 = nil;
local function u9(p13, p14, p15)
	if p14 == 1 then
		return nil;
	end;
	if p15 and typeof(p15) == "Vector3" then
		local v20 = p15;
	else
		local l__Handle__21 = p13:FindFirstChild("Handle");
		if not l__Handle__21 then
			print("Unable to scale tool, no center nor Handle has been defined");
			return nil;
		end;
		v20 = u2(p15, l__Handle__21.Size, l__Handle__21.Position);
	end;
	u3(p13, p14, v20);
end;
local u10 = nil;
local u11 = nil;
local function u12(p16, p17)
	if p17 == 1 then
		return nil;
	end;
	local v22 = v1.new(p17);
	if v22.isVector3 then
		local v23 = p16.Position * v22.asVector3;
	else
		v23 = p16.Position * v22.asNumber;
	end;
	p16.Position = v23;
	p16.BlastPressure = p16.BlastPressure * v22.asNumber;
	p16.BlastRadius = p16.BlastRadius * v22.asNumber;
end;
local u13 = nil;
local u14 = nil;
local function u15(p18)
	local function v24(p19, p20)
		p20.Enabled = p19;
	end;
	for v25, v26 in pairs(p18) do
		v24(v26, v25, p18);
	end;
end;
u3 = function(p21, p22, p23, p24)
	if p24 == nil then
		p24 = false;
	end;
	if p22 == 1 then
		return nil;
	end;
	if p24 then
		local v27 = nil;
	else
		v27 = u6(p21);
	end;
	local v28, v29, v30 = ipairs((p21:GetChildren()));
	while true do
		local v31, v32 = v28(v29, v30);
		if not v31 then
			break;
		end;
		local v33 = false;
		if v32:IsA("BasePart") then
			u4(v32, p22, p23);
		elseif v32:IsA("Model") then
			u7(v32, p22, p23);
			v33 = true;
		elseif v32:IsA("Attachment") then
			u8(v32, p22, p23);
		elseif v32:IsA("Tool") then
			u9(v32, p22, p23);
			v33 = true;
		elseif v32:IsA("SpecialMesh") then
			u10(v32, p22, p23);
		elseif v32:IsA("Fire") then
			u11(v32, p22, p23);
		elseif v32:IsA("Explosion") then
			u12(v32, p22);
		elseif v32:IsA("ParticleEmitter") then
			u13(v32, p22);
		elseif v32:IsA("Texture") then
			u14(v32, p22, p23);
		end;
		if not v33 then
			u3(v32, p22, p23, true);
		end;	
	end;
	if v27 then
		u15(v27);
	end;
end;
u14 = function(p25, p26, p27)
	local l__asVector2__34 = v1.new(p26).asVector2;
	p25.OffsetStudsU = p25.OffsetStudsU * l__asVector2__34.X;
	p25.OffsetStudsV = p25.OffsetStudsV * l__asVector2__34.Y;
	p25.StudsPerTileU = p25.StudsPerTileU * l__asVector2__34.X;
	p25.StudsPerTileV = p25.StudsPerTileV * l__asVector2__34.Y;
end;
local u16 = nil;
u2 = function(p28, p29, p30)
	if typeof(p28) == "Vector3" then
		return p28;
	end;
	if not p28 then
		return p30;
	end;
	return u16(p29, p30, p28);
end;
u16 = function(p31, p32, p33)
	local v35 = nil;
	v35 = p31 * 0.5;
	if p33 == Enum.NormalId.Front then
		return Vector3.new(p32.X, p32.Y, p32.Z - v35.Z);
	end;
	if p33 == Enum.NormalId.Back then
		return Vector3.new(p32.X, p32.Y, p32.Z + v35.Z);
	end;
	if p33 == Enum.NormalId.Right then
		return Vector3.new(p32.X + v35.X, p32.Y, p32.Z);
	end;
	if p33 == Enum.NormalId.Left then
		return Vector3.new(p32.X - v35.X, p32.Y, p32.Z);
	end;
	if p33 == Enum.NormalId.Top then
		return Vector3.new(p32.X, p32.Y + v35.Y, p32.Z);
	end;
	if p33 ~= Enum.NormalId.Bottom then
		return p32;
	end;
	return Vector3.new(p32.X, p32.Y - v35.Y, p32.Z);
end;
u4 = function(p34, p35, p36)
	local v36 = v1.new(p35);
	if v36.isVector3 then
		local v37 = p34.Size * v36.asVector3;
	else
		v37 = p34.Size * v36.asNumber;
	end;
	p34.Size = v37;
	p34.CFrame = CFrame.new((u5(p34.Position, p36, v36))) * (p34.CFrame - p34.Position);
end;
u8 = function(p37, p38, p39)
	local v38 = p37:FindFirstAncestorWhichIsA("BasePart");
	if v38 then
		p37.WorldPosition = u5(p37.WorldPosition, v38.Position, v1.new(p38));
	end;
end;
u10 = function(p40, p41, p42)
	p40.Scale = p40.Scale * v1.new(p41).asNumber;
end;
u11 = function(p43, p44, p45)
	p43.Size = math.floor(p43.Size * v1.new(p44).asNumber);
end;
local u17 = nil;
u13 = function(p46, p47)
	p46.Size = u17(p46.Size, p47);
end;
u17 = function(p48, p49)
	local l__Keypoints__39 = p48.Keypoints;
	local l__asNumber__18 = v1.new(p49).asNumber;
	local function v40(p50)
		return NumberSequenceKeypoint.new(p50.Time, p50.Value * l__asNumber__18, p50.Envelope * l__asNumber__18);
	end;
	local v41 = table.create(#l__Keypoints__39);
	for v42, v43 in ipairs(l__Keypoints__39) do
		v41[v42] = v40(v43, v42 - 1, l__Keypoints__39);
	end;
	return NumberSequence.new(v41);
end;
return {
	scaleModel = u7, 
	scalePart = function(p51, p52, p53)
		if p52 == 1 then
			return nil;
		end;
		local v44 = u2(p53, p51.Size, p51.Position);
		u4(p51, p52, v44);
		u3(p51, p52, v44);
	end, 
	scaleVector = function(p54, p55, p56)
		local v45 = nil;
		if p55 == 1 then
			return p54;
		end;
		v45 = v1.new(p55);
		if p56 then
			return u5(p54, p56, v45);
		end;
		if v45.isVector3 then
			return p54 * v45.asVector3;
		end;
		return p54 * v45.asNumber;
	end, 
	scaleExplosion = u12, 
	scaleTool = u9, 
	scaleDescendants = u3, 
	scaleTexture = u14, 
	ScaleSpecifier = v1
};
