-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
local function u1(p1, p2, p3, p4)
	if p4 ~= nil then
		p1 = p1 / p4;
	end;
	return (p3 and 1) * math.clamp(p1, 0, 1) + (p2 and 0);
end;
function v1.new(p5, p6, p7, p8)
	if not (p5 >= 0) or not (p5 <= 1) or not (p7 >= 0) or not (p7 <= 1) then
		error("The x values must be within range [0, 1]");
	end;
	if p5 == p6 and p7 == p8 then
		return u1;
	end;
	local v2 = 3 * p5;
	local v3 = 3 * p7;
	local v4 = 1 - v3 + v2;
	local v5 = v3 - 2 * v2;
	local v6 = 3 * p6;
	local v7 = {};
	for v8 = 0, 10 do
		local v9 = v8 * 0.1;
		v7[v8] = ((v4 * v9 + v5) * v9 + v2) * v9;
	end;
	local u2 = 3 * (1 - v3 + v2);
	local u3 = 2 * v5;
	local u4 = 1 - 3 * p8 + v6;
	local u5 = 3 * p8 - 2 * v6;
	return function(p9, p10, p11, p12)
		if p12 ~= nil then
			p9 = p9 / p12;
		end;
		p9 = math.clamp(p9, 0, 1);
		local v10 = 9;
		for v11 = 1, v10 do
			if p9 < v7[v11] then
				v10 = v11 - 1;
				break;
			end;
		end;
		local v12 = v10 * 0.1;
		local v13 = v12 + 0.1 * (p9 - v7[v10]) / (v7[v10 + 1] - v7[v10]);
		local v14 = (u2 * v13 + u3) * v13 + v2;
		if v14 >= 0.001 then
			for v15 = 1, 4 do
				local v16 = (u2 * v13 + u3) * v13 + v2;
				if v16 == 0 then
					break;
				end;
				v13 = v13 - (((v4 * v13 + v5) * v13 + v2) * v13 - p9) / v16;
			end;
		elseif v14 ~= 0 then
			local v17 = v12 + 0.1;
			for v18 = 1, 10 do
				v13 = v12 + 0.5 * (v17 - v12);
				local v19 = ((v4 * v13 + v5) * v13 + v2) * v13 - p9;
				if v19 > 0 then
					v17 = v13;
				else
					v12 = v13;
					v19 = -v19;
				end;
				if v19 <= 1E-07 then
					break;
				end;
			end;
		end;
		p9 = ((u4 * v13 + u5) * v13 + v6) * v13;
		return (p11 and 1) * p9 + (p10 and 0);
	end;
end;
return v1;
