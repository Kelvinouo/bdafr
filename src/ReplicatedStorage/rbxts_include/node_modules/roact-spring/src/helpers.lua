-- Decompiled with the Synapse X Luau decompiler.

local v1 = {
	getValuesFromType = function(p1)
		local v2 = typeof(p1);
		if v2 == "number" then
			return { p1 };
		end;
		if v2 == "UDim" then
			return { p1.Scale, p1.Offset };
		end;
		if v2 == "UDim2" then
			return { p1.X.Scale, p1.X.Offset, p1.Y.Scale, p1.Y.Offset };
		end;
		if v2 == "Vector2" then
			return { p1.X, p1.Y };
		end;
		if v2 == "Vector3" then
			return { p1.X, p1.Y, p1.Z };
		end;
		if v2 ~= "Color3" then
			error("Unsupported type: " .. v2);
			return;
		end;
		return { p1.R, p1.G, p1.B };
	end, 
	getTypeFromValues = function(p2, p3)
		if p2 == "number" then
			return p3[1];
		end;
		if p2 == "UDim" then
			return UDim.new(p3[1], p3[2]);
		end;
		if p2 == "UDim2" then
			return UDim2.new(p3[1], p3[2], p3[3], p3[4]);
		end;
		if p2 == "Vector2" then
			return Vector2.new(p3[1], p3[2]);
		end;
		if p2 == "Vector3" then
			return Vector3.new(p3[1], p3[2], p3[3]);
		end;
		if p2 ~= "Color3" then
			error("Unsupported type: " .. p2);
			return;
		end;
		return Color3.new(p3[1], p3[2], p3[3]);
	end
};
local u1 = table.freeze({ "config", "immediate" });
function v1.getDefaultProps(p4)
	local v3 = {};
	local v4, v5, v6 = ipairs(u1);
	while true do
		v4(v5, v6);
		if not v4 then
			break;
		end;
		v6 = v4;
		if p4[v5] then
			v3[v5] = p4[v5];
		end;	
	end;
	return v3;
end;
local u2 = table.freeze({
	config = 1, 
	from = 1, 
	to = 1, 
	loop = 1, 
	reset = 1, 
	immediate = 1, 
	default = 1, 
	delay = 1, 
	keys = 1
});
local function u3(p5)
	local v7 = {};
	local v8 = 0;
	for v9, v10 in pairs(p5) do
		if not u2[v9] then
			v7[v9] = v10;
			v8 = v8 + 1;
		end;
	end;
	if not (v8 > 0) then
		return;
	end;
	return v7;
end;
function v1.inferTo(p6)
	local v11 = u3(p6);
	if not v11 then
		return table.clone(p6);
	end;
	local v12 = {
		to = v11
	};
	for v13, v14 in pairs(p6) do
		if not v11[v13] then
			v12[v13] = v14;
		end;
	end;
	return v12;
end;
local function u4(p7, p8)
	for v15, v16 in pairs(p7) do
		if v16 and not table.find(p8, v15) then
			table.insert(p8, v15);
		end;
	end;
end;
function v1.createUpdate(p9)
	p9 = v1.inferTo(p9);
	local l__to__17 = p9.to;
	local l__from__18 = p9.from;
	local v19 = {};
	if typeof(l__to__17) == "table" then
		u4(l__to__17, v19);
	end;
	if typeof(l__from__18) == "table" then
		u4(l__from__18, v19);
	end;
	p9.keys = v19;
	return p9;
end;
local u5 = require(script.Parent.util);
function v1.createLoopUpdate(p10, p11)
	if p11 == nil then
		p11 = p10.loop;
	end;
	local v20 = true;
	if typeof(p11) == "function" then
		v20 = p11();
	end;
	if not v20 then
		return;
	end;
	local v21 = false;
	if typeof(p11) == "table" then
		v21 = p11;
	end;
	local v22 = not v21 or v21.reset;
	local v23 = table.clone(p10);
	v23.loop = p11;
	v23.default = false;
	v23.pause = nil;
	v23.from = v22 and p10.from;
	v23.reset = v22;
	if typeof(v21) == "table" then
		v23 = u5.merge(v23, v21);
	end;
	return v1.createUpdate(v23);
end;
return v1;
