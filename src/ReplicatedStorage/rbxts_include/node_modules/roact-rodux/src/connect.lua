
-- Decompiled with the Synapse X Luau decompiler.

local u1 = require(script.Parent.join);
local function u2()
	return nil;
end;
local function u3(p1, p2)
	return table.concat(p1, "\n"):format(unpack(p2 or {}));
end;
local u4 = require(script.Parent.Parent.Parent.roact.src);
local u5 = require(script.Parent.shallowEqual);
local function u6(p3)
	return function(p4, p5, p6)
		if p6 == nil then
			p6 = p5.mapStateToProps(p3:getState(), p4);
		end;
		return {
			mappedStoreState = p6, 
			propsForChild = u1(p4, p6, p5.mappedStoreDispatch)
		};
	end;
end;
local u7 = require(script.Parent.StoreContext);
return function(p7, p8)
	if p7 ~= nil then
		assert(typeof(p7) == "function", "mapStateToProps must be a function or nil!");
	else
		p7 = u2;
	end;
	local v1 = typeof(p8);
	if p8 ~= nil then
		local v2 = true;
		if v1 ~= "function" then
			v2 = v1 == "table";
		end;
		assert(v2, "mapDispatchToProps must be a function, table, or nil!");
	else
		p8 = u2;
	end;
	local u8 = debug.traceback();
	return function(p9)
		if p9 == nil then
			error(u3({ "connect returns a function that must be passed a component.", "Check the connection at:", "%s" }, { u8 }), 2);
		end;
		local v3 = ("RoduxConnection(%s)"):format(tostring(p9));
		local v4 = u4.Component:extend(v3);
		function v4.getDerivedStateFromProps(p10, p11)
			if p11.stateUpdater == nil then
				return;
			end;
			return p11.stateUpdater(p10.innerProps, p11);
		end;
		function v4.createStoreConnection(p12)
			p12.storeChangedConnection = p12.store.changed:connect(function(p13)
				p12:setState(function(p14, p15)
					local v5 = p14.mapStateToProps(p13, p15.innerProps);
					if u5(v5, p14.mappedStoreState) then
						return nil;
					end;
					return p14.stateUpdater(p15, p14, v5);
				end);
			end);
		end;
		function v4.init(p16, p17)
			p16.store = p17.store;
			if p16.store == nil then
				error((u3({ "Cannot initialize Roact-Rodux connection without being a descendent of StoreProvider!", "Tried to wrap component %q", "Make sure there is a StoreProvider above this component in the tree." }, { tostring(p9) })));
			end;
			local v6 = p16.store:getState();
			local v7 = p7;
			local v8 = v7(v6, p16.props.innerProps);
			if typeof(v8) == "function" then
				v7 = v8;
				v8 = v7(v6, p16.props.innerProps);
			end;
			if v8 ~= nil and typeof(v8) ~= "table" then
				error((u3({ "mapStateToProps must either return a table, or return another function that returns a table.", "Instead, it returned %q, which is of type %s." }, { tostring(v8), typeof(v8) })));
			end;
			local function v9(...)
				return p16.store:dispatch(...);
			end;
			local v10 = nil;
			if v1 == "table" then
				v10 = {};
				for v11, v12 in pairs(p8) do
					assert(typeof(v12) == "function", "mapDispatchToProps must contain function values");
					v10[v11] = function(...)
						v9(v12(...));
					end;
				end;
			elseif v1 == "function" then
				v10 = p8(v9);
			end;
			local v13 = u6(p16.store);
			p16.state = {
				stateUpdater = v13, 
				mapStateToProps = v7, 
				mappedStoreDispatch = v10, 
				propsForChild = nil
			};
			for v14, v15 in pairs((v13(p16.props.innerProps, p16.state, v8))) do
				p16.state[v14] = v15;
			end;
			p16:createStoreConnection();
		end;
		function v4.willUnmount(p18)
			p18.storeChangedConnection:disconnect();
		end;
		function v4.render(p19)
			return u4.createElement(p9, p19.state.propsForChild);
		end;
		local v16 = u4.Component:extend(v3);
		function v16.render(p20)
			local v17 = {};
			function v17.render(p21)
				return u4.createElement(v4, {
					innerProps = p20.props, 
					store = p21
				});
			end;
			return u4.createElement(u7.Consumer, v17);
		end;
		return v16;
	end;
end;

