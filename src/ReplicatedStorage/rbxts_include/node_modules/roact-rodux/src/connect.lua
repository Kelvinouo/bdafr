-- Decompiled with the Synapse X Luau decompiler.

local u1 = require(script.Parent.join);
local function u2()
	return nil;
end;
local u3 = require(script.Parent.Parent.Parent.roact.src);
local u4 = require(script.Parent.shallowEqual);
local u5 = require(script.Parent.StoreContext);
return function(p1, p2)
	if p1 ~= nil then
		assert(typeof(p1) == "function", "mapStateToProps must be a function or nil!");
	else
		p1 = u2;
	end;
	local v1 = typeof(p2);
	if p2 ~= nil then
		local v2 = true;
		if v1 ~= "function" then
			v2 = v1 == "table";
		end;
		assert(v2, "mapDispatchToProps must be a function, table, or nil!");
	else
		p2 = u2;
	end;
	local u6 = debug.traceback();
	return function(p3)
		if p3 == nil then
			error(table.concat({ "connect returns a function that must be passed a component.", "Check the connection at:", "%s" }, "\n"):format(unpack({ u6 } or {})), 2);
		end;
		local v3 = ("RoduxConnection(%s)"):format(tostring(p3));
		local v4 = u3.Component:extend(v3);
		function v4.getDerivedStateFromProps(p4, p5)
			if p5.stateUpdater == nil then
				return;
			end;
			return p5.stateUpdater(p4.innerProps, p5);
		end;
		function v4.createStoreConnection(p6)
			p6.storeChangedConnection = p6.store.changed:connect(function(p7)
				p6:setState(function(p8, p9)
					local v5 = p8.mapStateToProps(p7, p9.innerProps);
					if u4(v5, p8.mappedStoreState) then
						return nil;
					end;
					return p8.stateUpdater(p9, p8, v5);
				end);
			end);
		end;
		function v4.init(p10, p11)
			p10.store = p11.store;
			if p10.store == nil then
				error((table.concat({ "Cannot initialize Roact-Rodux connection without being a descendent of StoreProvider!", "Tried to wrap component %q", "Make sure there is a StoreProvider above this component in the tree." }, "\n"):format(unpack({ tostring(p3) } or {}))));
			end;
			local v6 = p10.store:getState();
			local v7 = p1;
			local v8 = v7(v6, p10.props.innerProps);
			if typeof(v8) == "function" then
				v7 = v8;
				v8 = v7(v6, p10.props.innerProps);
			end;
			if v8 ~= nil and typeof(v8) ~= "table" then
				error((table.concat({ "mapStateToProps must either return a table, or return another function that returns a table.", "Instead, it returned %q, which is of type %s." }, "\n"):format(unpack({ tostring(v8), typeof(v8) } or {}))));
			end;
			local function v9(...)
				return p10.store:dispatch(...);
			end;
			local v10 = nil;
			if v1 == "table" then
				v10 = {};
				for v11, v12 in pairs(p2) do
					assert(typeof(v12) == "function", "mapDispatchToProps must contain function values");
					v10[v11] = function(...)
						v9(v12(...));
					end;
				end;
			elseif v1 == "function" then
				v10 = p2(v9);
			end;
			local u7 = p10.store;
			local function v13(p12, p13, p14)
				if p14 == nil then
					p14 = p13.mapStateToProps(u7:getState(), p12);
				end;
				return {
					mappedStoreState = p14, 
					propsForChild = u1(p12, p14, p13.mappedStoreDispatch)
				};
			end;
			u7 = {
				stateUpdater = v13, 
				mapStateToProps = v7, 
				mappedStoreDispatch = v10, 
				propsForChild = nil
			};
			p10.state = u7;
			u7 = v13;
			u7 = u7(p10.props.innerProps, p10.state, v8);
			for v14, v15 in pairs(u7) do
				p10.state[v14] = v15;
			end;
			p10:createStoreConnection();
		end;
		function v4.willUnmount(p15)
			p15.storeChangedConnection:disconnect();
		end;
		function v4.render(p16)
			return u3.createElement(p3, p16.state.propsForChild);
		end;
		local v16 = u3.Component:extend(v3);
		function v16.render(p17)
			local v17 = {};
			function v17.render(p18)
				return u3.createElement(v4, {
					innerProps = p17.props, 
					store = p18
				});
			end;
			return u3.createElement(u5.Consumer, v17);
		end;
		return v16;
	end;
end;
