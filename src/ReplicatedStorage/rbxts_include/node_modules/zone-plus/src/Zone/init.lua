-- Decompiled with the Synapse X Luau decompiler.

local l__RunService__1 = game:GetService("RunService");
local v2 = l__RunService__1:IsClient() and game:GetService("Players").LocalPlayer;
local l__ReplicatedStorage__3 = game:GetService("ReplicatedStorage");
local l__enums__4 = require(script.Enum).enums;
local v5 = require(script.ZonePlusReference);
local v6 = v5.getObject();
if game:GetService("RunService"):IsClient() then
	local v7 = "Client";
else
	v7 = "Server";
end;
local v8 = v6 and v6:FindFirstChild(v7);
local v9 = v8 and require(v6.Value) or {};
v9.__index = v9;
if not v8 then
	v5.addToReplicatedStorage();
end;
v9.enum = l__enums__4;
local u1 = require(script.Maid);
local l__HttpService__2 = game:GetService("HttpService");
local u3 = require(script.ZoneController);
local u4 = require(script.Signal);
function v9.new(p1)
	local v10 = {};
	setmetatable(v10, v9);
	local v11 = typeof(p1);
	if v11 ~= "table" and v11 ~= "Instance" then
		error("A zone group must be a model, folder, basepart or table!");
	end;
	v10.accuracy = l__enums__4.Accuracy.High;
	v10.autoUpdate = true;
	v10.respectUpdateQueue = true;
	local v12 = u1.new();
	v10._maid = v12;
	v10._updateConnections = v12:give(u1.new());
	v10.group = p1;
	v10.groupParts = {};
	v10.region = nil;
	v10.volume = nil;
	v10.boundMin = nil;
	v10.boundMax = nil;
	v10.recommendedMaxParts = nil;
	v10.zoneId = l__HttpService__2:GenerateGUID();
	v10.activeTriggers = {};
	v10.occupants = {};
	v10.trackingTouchedTriggers = {};
	v10.enterDetection = l__enums__4.Detection.Automatic;
	v10.exitDetection = l__enums__4.Detection.Automatic;
	v10._currentEnterDetection = nil;
	v10._currentExitDetection = nil;
	v10.totalPartVolume = 0;
	u3.updateDetection(v10);
	v10.updated = v12:give(u4.new());
	local v13 = { "player", "part", "localPlayer" };
	local v14 = { "entered", "exited" };
	for v15, v16 in pairs(v13) do
		local v17 = 0;
		local v18 = 0;
		for v19, v20 in pairs(v14) do
			local v21 = v12:give(u4.new(true));
			local v22 = v20:sub(1, 1):upper() .. v20:sub(2);
			v10[v16 .. v22] = v21;
			local u5 = v18;
			local u6 = v17;
			v21.connectionsChanged:Connect(function(p2)
				if v16 == "localPlayer" and not v2 and p2 == 1 then
					error(("Can only connect to 'localPlayer%s' on the client!"):format(v22));
				end;
				u5 = u6;
				u6 = u6 + p2;
				if u5 == 0 and u6 > 0 then
					u3._registerConnection(v10, v16, v22);
					return;
				end;
				if u5 > 0 and u6 == 0 then
					u3._deregisterConnection(v10, v16);
				end;
			end);
		end;
	end;
	v9.touchedConnectionActions = {};
	for v23, v24 in pairs(v13) do
		local v25 = v10[("_%sTouchedZone"):format(v24)];
		if v25 then
			v10.trackingTouchedTriggers[v24] = {};
			v9.touchedConnectionActions[v24] = function(p3)
				v25(v10, p3);
			end;
		end;
	end;
	v10:_update();
	u3._registerZone(v10);
	v12:give(function()
		u3._deregisterZone(v10);
	end);
	return v10;
end;
function v9._calculateRegion(p4, p5, p6)
	local v26 = {
		Min = {}, 
		Max = {}
	};
	for v27, v28 in pairs(v26) do
		v28.Values = {};
		function v28.parseCheck(p7, p8)
			if v27 == "Min" then
				return p7 <= p8;
			end;
			if v27 ~= "Max" then
				return;
			end;
			return p8 <= p7;
		end;
		function v28.parse(p9, p10)
			local v29, v30, v31 = pairs(p10);
			while true do
				local v32, v33 = v29(v30, v31);
				if not v32 then
					break;
				end;
				if p9.parseCheck(v33, p9.Values[v32] and v33) then
					p9.Values[v32] = v33;
				end;			
			end;
		end;
	end;
	for v34, v35 in pairs(p5) do
		local v36 = v35.Size * 0.5;
		for v37, v38 in pairs({ v35.CFrame * CFrame.new(-v36.X, -v36.Y, -v36.Z), v35.CFrame * CFrame.new(-v36.X, -v36.Y, v36.Z), v35.CFrame * CFrame.new(-v36.X, v36.Y, -v36.Z), v35.CFrame * CFrame.new(-v36.X, v36.Y, v36.Z), v35.CFrame * CFrame.new(v36.X, -v36.Y, -v36.Z), v35.CFrame * CFrame.new(v36.X, -v36.Y, v36.Z), v35.CFrame * CFrame.new(v36.X, v36.Y, -v36.Z), v35.CFrame * CFrame.new(v36.X, v36.Y, v36.Z) }) do
			local v39, v40, v41 = v38:GetComponents();
			local v42 = { v39, v40, v41 };
			v26.Min:parse(v42);
			v26.Max:parse(v42);
		end;
	end;
	local v43 = {};
	local v44 = {};
	local function v45(p11)
		return 4 * math.floor((p11 + 2) / 4);
	end;
	for v46, v47 in pairs(v26) do
		local v48, v49, v50 = pairs(v47.Values);
		while true do
			local v51, v52 = v48(v49, v50);
			if not v51 then
				break;
			end;
			local v53 = v52;
			if not p6 then
				if v46 == "Min" then
					local v54 = -2;
				else
					v54 = 2;
				end;
				v53 = v45(v52 + v54);
			end;
			table.insert(v46 == "Min" and v43 or v44, v53);		
		end;
	end;
	local v55 = Vector3.new(unpack(v43));
	local v56 = Vector3.new(unpack(v44));
	return Region3.new(v55, v56), v55, v56;
end;
function v9._displayBounds(p12)
	if not p12.displayBoundParts then
		p12.displayBoundParts = true;
		for v57, v58 in pairs({
			BoundMin = p12.boundMin, 
			BoundMax = p12.boundMax
		}) do
			local v59 = Instance.new("Part");
			v59.Anchored = true;
			v59.CanCollide = false;
			v59.Transparency = 0.5;
			v59.Size = Vector3.new(1, 1, 1);
			v59.Color = Color3.fromRGB(255, 0, 0);
			v59.CFrame = CFrame.new(v58);
			v59.Name = v57;
			v59.Parent = workspace;
			p12._maid:give(v59);
		end;
	end;
end;
function v9._update(p13)
	local l__group__60 = p13.group;
	local v61 = {};
	p13._updateConnections:clean();
	local v62 = typeof(l__group__60);
	local v63 = {};
	if v62 == "table" then
		for v64, v65 in pairs(l__group__60) do
			if v65:IsA("BasePart") then
				table.insert(v61, v65);
			end;
		end;
	elseif v62 == "Instance" then
		if l__group__60:IsA("BasePart") then
			table.insert(v61, l__group__60);
		else
			table.insert(v63, l__group__60);
			for v66, v67 in pairs(l__group__60:GetDescendants()) do
				if v67:IsA("BasePart") then
					table.insert(v61, v67);
				else
					table.insert(v63, v67);
				end;
			end;
		end;
	end;
	p13.groupParts = v61;
	local u7 = 0;
	local function v68()
		if p13.autoUpdate then
			local v69 = os.clock();
			if p13.respectUpdateQueue then
				u7 = u7 + 1;
				v69 = v69 + 0.1;
			end;
			local u8 = nil;
			u8 = l__RunService__1.Heartbeat:Connect(function()
				if v69 <= os.clock() then
					u8:Disconnect();
					if p13.respectUpdateQueue then
						u7 = u7 - 1;
					end;
					if u7 == 0 and p13.zoneId then
						p13:_update();
					end;
				end;
			end);
		end;
	end;
	local v70 = { "Size", "Position" };
	for v71, v72 in pairs(v61) do
		for v73, v74 in pairs(v70) do
			p13._updateConnections:give(v72:GetPropertyChangedSignal(v74):Connect(v68));
		end;
	end;
	local v75 = { "ChildAdded", "ChildRemoved" };
	for v76, v77 in pairs(v63) do
		for v78, v79 in pairs(v75) do
			p13._updateConnections:give(p13.group[v79]:Connect(function(p14)
				if p14:IsA("BasePart") then
					v68();
				end;
			end));
		end;
	end;
	local v80, v81, v82 = p13:_calculateRegion(v61);
	local v83, v84, v85 = p13:_calculateRegion(v61, true);
	p13.region = v80;
	p13.exactRegion = v83;
	p13.boundMin = v81;
	p13.boundMax = v82;
	local l__Size__86 = v80.Size;
	p13.volume = l__Size__86.X * l__Size__86.Y * l__Size__86.Z;
	p13:_updateTouchedConnections();
	p13.updated:Fire();
end;
function v9._updateOccupants(p15, p16, p17)
	local v87 = p15.occupants[p16];
	if not v87 then
		v87 = {};
		p15.occupants[p16] = v87;
	end;
	local v88 = p15[p16 .. "Exited"];
	local v89 = p15[p16 .. "Entered"];
	if v88 then
		for v90, v91 in pairs(v87) do
			local v92 = p17[v90];
			if v92 == nil or v92 ~= v91 then
				v87[v90] = nil;
				v88:Fire(v90);
			end;
		end;
	end;
	if v89 then
		for v93, v94 in pairs(p17) do
			if v87[v93] == nil then
				v87[v93] = v93.Character;
				v89:Fire(v93);
			end;
		end;
	end;
end;
function v9._formTouchedConnection(p18, p19)
	local v95 = "_touchedMaid" .. p19;
	local v96 = p18[v95];
	if v96 then
		v96:clean();
	else
		p18[v95] = p18._maid:give(u1.new());
	end;
	p18:_updateTouchedConnection(p19);
end;
function v9._updateTouchedConnection(p20, p21)
	local v97 = p20["_touchedMaid" .. p21];
	if not v97 then
		return;
	end;
	for v98, v99 in pairs(p20.groupParts) do
		v97:give(v99.Touched:Connect(p20.touchedConnectionActions[p21], p20));
	end;
end;
function v9._updateTouchedConnections(p22)
	for v100, v101 in pairs(p22.touchedConnectionActions) do
		local v102 = p22["_touchedMaid" .. v100];
		if v102 then
			v102:clean();
			p22:_updateTouchedConnection(v100);
		end;
	end;
end;
function v9._disconnectTouchedConnection(p23, p24)
	local v103 = "_touchedMaid" .. p24;
	local v104 = p23[v103];
	if v104 then
		v104:clean();
		p23[v103] = nil;
	end;
end;
local function u9(p25, p26)
	return math.round(p25 * 10 ^ p26) * 10 ^ (-p26);
end;
local l__Heartbeat__10 = l__RunService__1.Heartbeat;
function v9._partTouchedZone(p27, p28)
	local l__part__105 = p27.trackingTouchedTriggers.part;
	if l__part__105[p28] then
		return;
	end;
	local v106 = p27._maid:give(u1.new());
	l__part__105[p28] = v106;
	if not ({
		Seat = true, 
		VehicleSeat = true
	})[p28.ClassName] and ({
		HumanoidRootPart = true
	})[p28.Name] then
		p28.CanTouch = false;
	end;
	local v107 = u9(p28.Size.X * p28.Size.Y * p28.Size.Z, 5);
	p27.totalPartVolume = p27.totalPartVolume + v107;
	local u11 = 0;
	local u12 = p27:_getRegionConstructor(p28);
	local u13 = false;
	local u14 = p28.Position;
	local u15 = os.clock();
	v106:give(l__Heartbeat__10:Connect(function()
		local v108 = os.clock();
		if u11 <= v108 then
			local v109 = nil;
			local v110 = l__enums__4.Accuracy.getProperty(p27.accuracy);
			u11 = v108 + v110;
			v109 = p27:findPart(p28, u12);
			if not u13 then
				if v109 then
					u13 = true;
					p27.partEntered:Fire(p28);
					return;
				end;
				if (p28.Position - u14).Magnitude > 1.5 and v110 <= v108 - u15 then
					v106:clean();
					return;
				end;
			elseif not v109 then
				u13 = false;
				u14 = p28.Position;
				u15 = os.clock();
				p27.partExited:Fire(p28);
			end;
		end;
	end));
	v106:give(function()
		l__part__105[p28] = nil;
		p28.CanTouch = true;
		p27.totalPartVolume = u9(p27.totalPartVolume - v107, 5);
	end);
end;
function v9._getRegionConstructor(p29, p30)
	local v111, v112 = pcall(function()
		return p30.Shape.Name;
	end);
	if not v111 then
		v112 = ({
			WedgePart = "Wedge", 
			CornerWedgePart = "CornerWedge"
		})[p30.ClassName] and "new";
	end;
	return v112;
end;
function v9.findLocalPlayer(p31)
	if not v2 then
		error("Can only call 'findLocalPlayer' on the client!");
	end;
	return p31:findPlayer(v2);
end;
function v9.findPlayer(p32, p33)
	u3.updateDetection(p32);
	for v113, v114 in pairs((u3.getTouchingZones(p33, false, p32._currentEnterDetection))) do
		if v114 == p32 then
			return true;
		end;
	end;
	return false;
end;
local u16 = require(script.RotatedRegion3);
function v9.findPart(p34, p35, p36, p37, p38)
	local v115 = p36 or p34:_getRegionConstructor(p35);
	local l__CFrame__116 = p35.CFrame;
	local v117 = u16[v115](p35.CFrame, Vector3.new(0.1, 0.1, 0.1)):FindPartsInRegion3WithWhiteList(p34.groupParts, #p34.groupParts);
	if not (#v117 > 0) then
		if #u16[v115](p35.CFrame, p35.Size):FindPartsInRegion3WithWhiteList(p34.groupParts, #p34.groupParts) > 0 then
			return true;
		else
			return false;
		end;
	end;
	local v118 = p35.Size.X / 2;
	if not u3.verifyTouchingParts({ (l__CFrame__116 * CFrame.new(-v118, 0, 0)).Position, (l__CFrame__116 * CFrame.new(v118, 0, 0)).Position }, v117) then
		return false;
	end;
	return true;
end;
function v9.getPlayers(p39)
	u3.updateDetection(p39);
	local v119 = {};
	local v120 = u3._getZonesAndPlayers({
		self = true
	}, p39.volume, false, p39._currentEnterDetection)[p39];
	if v120 then
		for v121, v122 in pairs(v120) do
			table.insert(v119, v121);
		end;
	end;
	return v119;
end;
function v9.getParts(p40)
	local v123 = {};
	if p40.activeTriggers.part then
		for v124, v125 in pairs(p40.trackingTouchedTriggers.part) do
			table.insert(v123, v124);
		end;
		return v123;
	end;
	for v126, v127 in pairs((workspace:FindPartsInRegion3WithIgnoreList(p40.region, p40.groupParts))) do
		if p40:findPart(v127) then
			table.insert(v123, v127);
		end;
	end;
	return v123;
end;
function v9.getRandomPoint(p41)
	local v128 = nil;
	local v129 = nil;
	local l__exactRegion__130 = p41.exactRegion;
	local l__Size__131 = l__exactRegion__130.Size;
	local l__CFrame__132 = l__exactRegion__130.CFrame;
	local v133 = Random.new();
	local v134 = nil;
	while true do
		v128 = l__CFrame__132 * CFrame.new(v133:NextNumber(-l__Size__131.X / 2, l__Size__131.X / 2), v133:NextNumber(-l__Size__131.Y / 2, l__Size__131.Y / 2), v133:NextNumber(-l__Size__131.Z / 2, l__Size__131.Z / 2));
		v129 = u16.new(v128, Vector3.new(0.1, 0.1, 0.1)):FindPartsInRegion3WithWhiteList(p41.groupParts, #p41.groupParts);
		if #v129 > 0 then
			v134 = u3.verifyTouchingParts({ v128.Position }, v129);
		end;
		if v134 then
			break;
		end;	
	end;
	return v128.Position, v129;
end;
function v9.setAccuracy(p42, p43)
	local v135 = tonumber(p43);
	if not v135 then
		v135 = l__enums__4.Accuracy[p43];
		if not v135 then
			error(("'%s' is an invalid enumName!"):format(p43));
		end;
	elseif not l__enums__4.Accuracy.getName(v135) then
		error(("%s is an invalid enumId!"):format(v135));
	end;
	p42.accuracy = v135;
end;
function v9.setDetection(p44, p45)
	local v136 = tonumber(p45);
	if not v136 then
		v136 = l__enums__4.Detection[p45];
		if not v136 then
			error(("'%s' is an invalid enumName!"):format(p45));
		end;
	elseif not l__enums__4.Detection.getName(v136) then
		error(("%s is an invalid enumId!"):format(v136));
	end;
	p44.enterDetection = v136;
	p44.exitDetection = v136;
end;
function v9.destroy(p46)
	p46._maid:clean();
end;
v9.Destroy = v9.destroy;
return v9;
