-- Decompiled with the Synapse X Luau decompiler.

local v1 = (1 + math.sqrt(5)) / 2;
local v2 = Vector3.new(1, 0, 0);
local v3 = Vector3.new(0, 1, 0);
local v4 = Vector3.new(0, 0, 1);
local v5 = Vector3.new(-1, 0, 0);
local v6 = Vector3.new(0, -1, 0);
local v7 = Vector3.new(0, 0, -1);
local v8 = { 1, 2, 3, 4, 5, 6, 7, 8 };
local v9 = { 1, 2, 5, 6, 7, 8 };
local v10 = { 4, 5, 6, 7, 8 };
local u1 = { Vector3.new(1, 1, 1), Vector3.new(-1, 1, 1), Vector3.new(-1, 1, -1), Vector3.new(1, 1, -1), Vector3.new(1, -1, 1), Vector3.new(-1, -1, 1), Vector3.new(-1, -1, -1), Vector3.new(1, -1, -1) };
local u2 = math.pi * 2;
local v11 = {};
for v12 = 1, #v8 do
	v11[v12] = u1[v8[v12]];
end;
local v13 = {};
for v14 = 1, #v9 do
	v13[v14] = u1[v9[v14]];
end;
local v15 = {};
for v16 = 1, #v10 do
	v15[v16] = u1[v10[v16]];
end;
local v17 = {};
local function u3(p1, p2, p3)
	local v18 = {};
	for v19 = 1, #p3 do
		v18[v19] = p1:PointToWorldSpace(p3[v19] * p2);
	end;
	return v18;
end;
function v17.Block(p4, p5)
	return u3(p4, p5, v11);
end;
function v17.Wedge(p6, p7)
	return u3(p6, p7, v13);
end;
function v17.CornerWedge(p8, p9)
	return u3(p8, p9, v15);
end;
local u4 = (function(p10)
	local v20 = {};
	local v21 = u2 / p10;
	for v22 = 1, p10 do
		local v23 = CFrame.fromAxisAngle(v2, v22 * v21) * v3;
		v20[v22] = v2 + v23;
		v20[p10 + v22] = v5 + v23;
	end;
	return v20;
end)(20);
function v17.Cylinder(p11, p12)
	return u3(p11, p12, u4);
end;
local u5 = (function(p13)
	local v24 = { 1, 12, 6, 1, 6, 2, 1, 2, 8, 1, 8, 11, 1, 11, 12, 2, 6, 10, 6, 12, 5, 12, 11, 3, 11, 8, 7, 8, 2, 9, 4, 10, 5, 4, 5, 3, 4, 3, 7, 4, 7, 9, 4, 9, 10, 5, 10, 6, 3, 5, 12, 7, 3, 11, 9, 7, 8, 10, 9, 2 };
	local u6 = {};
	local u7 = { Vector3.new(-1, v1, 0), Vector3.new(1, v1, 0), Vector3.new(-1, -v1, 0), Vector3.new(1, -v1, 0), Vector3.new(0, -1, v1), Vector3.new(0, 1, v1), Vector3.new(0, -1, -v1), Vector3.new(0, 1, -v1), Vector3.new(v1, 0, -1), Vector3.new(v1, 0, 1), Vector3.new(-v1, 0, -1), Vector3.new(-v1, 0, 1) };
	for v25 = 1, p13 do
		for v26 = #v24, 1, -3 do
			local v27 = v24[v26 - 2];
			local v28 = v24[v26 - 1];
			local v29 = v24[v26];
			local v30 = v27 < v28 and v27 .. "," .. v28 or v28 .. "," .. v27;
			if not u6[v30] then
				u7[#u7 + 1] = (u7[v27] + u7[v28]) / 2;
				u6[v30] = #u7;
			end;
			local v31 = u6[v30];
			local v32 = v28 < v29 and v28 .. "," .. v29 or v29 .. "," .. v28;
			if not u6[v32] then
				u7[#u7 + 1] = (u7[v28] + u7[v29]) / 2;
				u6[v32] = #u7;
			end;
			local v33 = u6[v32];
			local v34 = v29 < v27 and v29 .. "," .. v27 or v27 .. "," .. v29;
			if not u6[v34] then
				u7[#u7 + 1] = (u7[v29] + u7[v27]) / 2;
				u6[v34] = #u7;
			end;
			local v35 = u6[v34];
			v24[#v24 + 1] = v27;
			v24[#v24 + 1] = v31;
			v24[#v24 + 1] = v35;
			v24[#v24 + 1] = v28;
			v24[#v24 + 1] = v33;
			v24[#v24 + 1] = v31;
			v24[#v24 + 1] = v29;
			v24[#v24 + 1] = v35;
			v24[#v24 + 1] = v33;
			v24[#v24 + 1] = v31;
			v24[#v24 + 1] = v33;
			v24[#v24 + 1] = v35;
			table.remove(v24, v26);
			table.remove(v24, v26 - 1);
			table.remove(v24, v26 - 2);
		end;
	end;
	for v36 = 1, #u7 do
		u7[v36] = u7[v36].Unit;
	end;
	return u7;
end)(2);
function v17.Ball(p14, p15)
	return u3(p14, p15, u5);
end;
function v17.GetCentroid(p16)
	local v37 = nil;
	v37 = p16[1];
	for v38 = 2, #p16 do
		v37 = v37 + p16[2];
	end;
	return local v39 / #p16;
end;
function v17.Classify(p17)
	if p17.ClassName == "Part" then
		if p17.Shape == Enum.PartType.Block then
			return "Block";
		elseif p17.Shape == Enum.PartType.Cylinder then
			return "Cylinder";
		elseif p17.Shape == Enum.PartType.Ball then
			return "Ball";
		else
			return;
		end;
	else
		if p17.ClassName == "WedgePart" then
			return "Wedge";
		end;
		if p17.ClassName == "CornerWedgePart" then
			return "CornerWedge";
		end;
		if not p17:IsA("BasePart") then
			return;
		end;
	end;
	return "Block";
end;
return v17;
