-- Decompiled with the Synapse X Luau decompiler.

local l__RunService__1 = game:GetService("RunService");
local v2 = l__RunService__1:IsClient() and game:GetService("Players").LocalPlayer;
local l__ReplicatedStorage__3 = game:GetService("ReplicatedStorage");
local l__enums__4 = require(script.Enum).enums;
local v5 = require(script.ZonePlusReference);
local v6 = v5.getObject();
if game:GetService("RunService"):IsClient() then
	local v7 = "Client";
else
	v7 = "Server";
end;
local v8 = v6 and v6:FindFirstChild(v7);
local v9 = v8 and require(v6.Value) or {};
v9.__index = v9;
if not v8 then
	v5.addToReplicatedStorage();
end;
v9.enum = l__enums__4;
local u1 = require(script.Maid);
local l__HttpService__2 = game:GetService("HttpService");
local u3 = require(script.ZoneController);
local u4 = require(script.Signal);
function v9.new(p1)
	local v10 = {};
	setmetatable(v10, v9);
	local v11 = typeof(p1);
	if v11 ~= "table" and v11 ~= "Instance" then
		error("A zone group must be a model, folder, basepart or table!");
	end;
	v10.accuracy = l__enums__4.Accuracy.High;
	v10.autoUpdate = true;
	v10.respectUpdateQueue = true;
	local v12 = u1.new();
	v10._maid = v12;
	v10._updateConnections = v12:give(u1.new());
	v10.group = p1;
	v10.groupParts = {};
	v10.region = nil;
	v10.volume = nil;
	v10.boundMin = nil;
	v10.boundMax = nil;
	v10.recommendedMaxParts = nil;
	v10.zoneId = l__HttpService__2:GenerateGUID();
	v10.activeTriggers = {};
	v10.occupants = {};
	v10.trackingTouchedTriggers = {};
	v10.enterDetection = l__enums__4.Detection.Automatic;
	v10.exitDetection = l__enums__4.Detection.Automatic;
	v10._currentEnterDetection = nil;
	v10._currentExitDetection = nil;
	v10.totalPartVolume = 0;
	u3.updateDetection(v10);
	v10.updated = v12:give(u4.new());
	local v13 = { "player", "part", "localPlayer" };
	local v14 = { "entered", "exited" };
	for v15, v16 in pairs(v13) do
		local v17 = 0;
		local v18 = 0;
		for v19, v20 in pairs(v14) do
			local v21 = v12:give(u4.new(true));
			local v22 = v20:sub(1, 1):upper() .. v20:sub(2);
			v10[v16 .. v22] = v21;
			local u5 = v18;
			local u6 = v17;
			v21.connectionsChanged:Connect(function(p2)
				if v16 == "localPlayer" and not v2 and p2 == 1 then
					error(("Can only connect to 'localPlayer%s' on the client!"):format(v22));
				end;
				u5 = u6;
				u6 = u6 + p2;
				if u5 == 0 and u6 > 0 then
					u3._registerConnection(v10, v16, v22);
					return;
				end;
				if u5 > 0 and u6 == 0 then
					u3._deregisterConnection(v10, v16);
				end;
			end);
		end;
	end;
	v9.touchedConnectionActions = {};
	for v23, v24 in pairs(v13) do
		local v25 = v10[("_%sTouchedZone"):format(v24)];
		if v25 then
			v10.trackingTouchedTriggers[v24] = {};
			v9.touchedConnectionActions[v24] = function(p3)
				v25(v10, p3);
			end;
		end;
	end;
	v10:_update();
	u3._registerZone(v10);
	v12:give(function()
		u3._deregisterZone(v10);
	end);
	return v10;
end;
function v9._calculateRegion(p4, p5, p6)
	local v26 = {
		Min = {}, 
		Max = {}
	};
	for v27, v28 in pairs(v26) do
		v28.Values = {};
		function v28.parseCheck(p7, p8)
			if v27 == "Min" then
				return p7 <= p8;
			end;
			if v27 ~= "Max" then
				return;
			end;
			return p8 <= p7;
		end;
		function v28.parse(p9, p10)
			local v29, v30, v31 = pairs(p10);
			while true do
				local v32, v33 = v29(v30, v31);
				if not v32 then
					break;
				end;
				if p9.parseCheck(v33, p9.Values[v32] and v33) then
					p9.Values[v32] = v33;
				end;			
			end;
		end;
	end;
	for v34, v35 in pairs(p5) do
		local v36 = v35.Size * 0.5;
		for v37, v38 in pairs({ v35.CFrame * CFrame.new(-v36.X, -v36.Y, -v36.Z), v35.CFrame * CFrame.new(-v36.X, -v36.Y, v36.Z), v35.CFrame * CFrame.new(-v36.X, v36.Y, -v36.Z), v35.CFrame * CFrame.new(-v36.X, v36.Y, v36.Z), v35.CFrame * CFrame.new(v36.X, -v36.Y, -v36.Z), v35.CFrame * CFrame.new(v36.X, -v36.Y, v36.Z), v35.CFrame * CFrame.new(v36.X, v36.Y, -v36.Z), v35.CFrame * CFrame.new(v36.X, v36.Y, v36.Z) }) do
			local v39, v40, v41 = v38:GetComponents();
			local v42 = { v39, v40, v41 };
			v26.Min:parse(v42);
			v26.Max:parse(v42);
		end;
	end;
	local v43 = {};
	local v44 = {};
	for v45, v46 in pairs(v26) do
		local v47, v48, v49 = pairs(v46.Values);
		while true do
			local v50, v51 = v47(v48, v49);
			if not v50 then
				break;
			end;
			local v52 = v51;
			if not p6 then
				if v45 == "Min" then
					local v53 = -2;
				else
					v53 = 2;
				end;
				v52 = 4 * math.floor((v51 + v53 + 2) / 4);
			end;
			table.insert(v45 == "Min" and v43 or v44, v52);		
		end;
	end;
	local v54 = Vector3.new(unpack(v43));
	local v55 = Vector3.new(unpack(v44));
	return Region3.new(v54, v55), v54, v55;
end;
function v9._displayBounds(p11)
	if not p11.displayBoundParts then
		p11.displayBoundParts = true;
		for v56, v57 in pairs({
			BoundMin = p11.boundMin, 
			BoundMax = p11.boundMax
		}) do
			local v58 = Instance.new("Part");
			v58.Anchored = true;
			v58.CanCollide = false;
			v58.Transparency = 0.5;
			v58.Size = Vector3.new(1, 1, 1);
			v58.Color = Color3.fromRGB(255, 0, 0);
			v58.CFrame = CFrame.new(v57);
			v58.Name = v56;
			v58.Parent = workspace;
			p11._maid:give(v58);
		end;
	end;
end;
function v9._update(p12)
	local l__group__59 = p12.group;
	local v60 = {};
	p12._updateConnections:clean();
	local v61 = typeof(l__group__59);
	local v62 = {};
	if v61 == "table" then
		for v63, v64 in pairs(l__group__59) do
			if v64:IsA("BasePart") then
				table.insert(v60, v64);
			end;
		end;
	elseif v61 == "Instance" then
		if l__group__59:IsA("BasePart") then
			table.insert(v60, l__group__59);
		else
			table.insert(v62, l__group__59);
			for v65, v66 in pairs(l__group__59:GetDescendants()) do
				if v66:IsA("BasePart") then
					table.insert(v60, v66);
				else
					table.insert(v62, v66);
				end;
			end;
		end;
	end;
	p12.groupParts = v60;
	local u7 = 0;
	local function v67()
		if p12.autoUpdate then
			local v68 = os.clock();
			if p12.respectUpdateQueue then
				u7 = u7 + 1;
				v68 = v68 + 0.1;
			end;
			local u8 = nil;
			u8 = l__RunService__1.Heartbeat:Connect(function()
				if v68 <= os.clock() then
					u8:Disconnect();
					if p12.respectUpdateQueue then
						u7 = u7 - 1;
					end;
					if u7 == 0 and p12.zoneId then
						p12:_update();
					end;
				end;
			end);
		end;
	end;
	local v69 = { "Size", "Position" };
	for v70, v71 in pairs(v60) do
		for v72, v73 in pairs(v69) do
			p12._updateConnections:give(v71:GetPropertyChangedSignal(v73):Connect(v67));
		end;
	end;
	local v74 = { "ChildAdded", "ChildRemoved" };
	for v75, v76 in pairs(v62) do
		for v77, v78 in pairs(v74) do
			p12._updateConnections:give(p12.group[v78]:Connect(function(p13)
				if p13:IsA("BasePart") then
					v67();
				end;
			end));
		end;
	end;
	local v79, v80, v81 = p12:_calculateRegion(v60);
	local v82, v83, v84 = p12:_calculateRegion(v60, true);
	p12.region = v79;
	p12.exactRegion = v82;
	p12.boundMin = v80;
	p12.boundMax = v81;
	local l__Size__85 = v79.Size;
	p12.volume = l__Size__85.X * l__Size__85.Y * l__Size__85.Z;
	p12:_updateTouchedConnections();
	p12.updated:Fire();
end;
function v9._updateOccupants(p14, p15, p16)
	local v86 = p14.occupants[p15];
	if not v86 then
		v86 = {};
		p14.occupants[p15] = v86;
	end;
	local v87 = p14[p15 .. "Exited"];
	local v88 = p14[p15 .. "Entered"];
	if v87 then
		for v89, v90 in pairs(v86) do
			local v91 = p16[v89];
			if v91 == nil or v91 ~= v90 then
				v86[v89] = nil;
				v87:Fire(v89);
			end;
		end;
	end;
	if v88 then
		for v92, v93 in pairs(p16) do
			if v86[v92] == nil then
				v86[v92] = v92.Character;
				v88:Fire(v92);
			end;
		end;
	end;
end;
function v9._formTouchedConnection(p17, p18)
	local v94 = "_touchedMaid" .. p18;
	local v95 = p17[v94];
	if v95 then
		v95:clean();
	else
		p17[v94] = p17._maid:give(u1.new());
	end;
	p17:_updateTouchedConnection(p18);
end;
function v9._updateTouchedConnection(p19, p20)
	local v96 = p19["_touchedMaid" .. p20];
	if not v96 then
		return;
	end;
	for v97, v98 in pairs(p19.groupParts) do
		v96:give(v98.Touched:Connect(p19.touchedConnectionActions[p20], p19));
	end;
end;
function v9._updateTouchedConnections(p21)
	for v99, v100 in pairs(p21.touchedConnectionActions) do
		local v101 = p21["_touchedMaid" .. v99];
		if v101 then
			v101:clean();
			p21:_updateTouchedConnection(v99);
		end;
	end;
end;
function v9._disconnectTouchedConnection(p22, p23)
	local v102 = "_touchedMaid" .. p23;
	local v103 = p22[v102];
	if v103 then
		v103:clean();
		p22[v102] = nil;
	end;
end;
local l__Heartbeat__9 = l__RunService__1.Heartbeat;
function v9._partTouchedZone(p24, p25)
	local l__part__104 = p24.trackingTouchedTriggers.part;
	if l__part__104[p25] then
		return;
	end;
	local v105 = os.clock();
	local v106 = p24:_getRegionConstructor(p25);
	local v107 = p24._maid:give(u1.new());
	l__part__104[p25] = v107;
	if not ({
		Seat = true, 
		VehicleSeat = true
	})[p25.ClassName] and ({
		HumanoidRootPart = true
	})[p25.Name] then
		p25.CanTouch = false;
	end;
	local v108 = math.round(p25.Size.X * p25.Size.Y * p25.Size.Z * 100000) * 1E-05;
	p24.totalPartVolume = p24.totalPartVolume + v108;
	local u10 = 0;
	local u11 = false;
	local u12 = p25.Position;
	local u13 = v105;
	v107:give(l__Heartbeat__9:Connect(function()
		local v109 = os.clock();
		if u10 <= v109 then
			local v110 = nil;
			local v111 = l__enums__4.Accuracy.getProperty(p24.accuracy);
			u10 = v109 + v111;
			v110 = p24:findPart(p25, v106);
			if not u11 then
				if v110 then
					u11 = true;
					p24.partEntered:Fire(p25);
					return;
				end;
				if (p25.Position - u12).Magnitude > 1.5 and v111 <= v109 - u13 then
					v107:clean();
					return;
				end;
			elseif not v110 then
				u11 = false;
				u12 = p25.Position;
				u13 = os.clock();
				p24.partExited:Fire(p25);
			end;
		end;
	end));
	v107:give(function()
		l__part__104[p25] = nil;
		p25.CanTouch = true;
		p24.totalPartVolume = math.round((p24.totalPartVolume - v108) * 100000) * 1E-05;
	end);
end;
function v9._getRegionConstructor(p26, p27)
	local v112, v113 = pcall(function()
		return p27.Shape.Name;
	end);
	if not v112 then
		v113 = ({
			WedgePart = "Wedge", 
			CornerWedgePart = "CornerWedge"
		})[p27.ClassName] and "new";
	end;
	return v113;
end;
function v9.findLocalPlayer(p28)
	if not v2 then
		error("Can only call 'findLocalPlayer' on the client!");
	end;
	return p28:findPlayer(v2);
end;
function v9.findPlayer(p29, p30)
	u3.updateDetection(p29);
	for v114, v115 in pairs((u3.getTouchingZones(p30, false, p29._currentEnterDetection))) do
		if v115 == p29 then
			return true;
		end;
	end;
	return false;
end;
local u14 = require(script.RotatedRegion3);
function v9.findPart(p31, p32, p33, p34, p35)
	local v116 = p33 or p31:_getRegionConstructor(p32);
	local l__CFrame__117 = p32.CFrame;
	local v118 = u14[v116](p32.CFrame, Vector3.new(0.1, 0.1, 0.1)):FindPartsInRegion3WithWhiteList(p31.groupParts, #p31.groupParts);
	if not (#v118 > 0) then
		if #u14[v116](p32.CFrame, p32.Size):FindPartsInRegion3WithWhiteList(p31.groupParts, #p31.groupParts) > 0 then
			return true;
		else
			return false;
		end;
	end;
	local v119 = p32.Size.X / 2;
	if not u3.verifyTouchingParts({ (l__CFrame__117 * CFrame.new(-v119, 0, 0)).Position, (l__CFrame__117 * CFrame.new(v119, 0, 0)).Position }, v118) then
		return false;
	end;
	return true;
end;
function v9.getPlayers(p36)
	u3.updateDetection(p36);
	local v120 = {};
	local v121 = u3._getZonesAndPlayers({
		self = true
	}, p36.volume, false, p36._currentEnterDetection)[p36];
	if v121 then
		for v122, v123 in pairs(v121) do
			table.insert(v120, v122);
		end;
	end;
	return v120;
end;
function v9.getParts(p37)
	local v124 = {};
	if p37.activeTriggers.part then
		for v125, v126 in pairs(p37.trackingTouchedTriggers.part) do
			table.insert(v124, v125);
		end;
		return v124;
	end;
	for v127, v128 in pairs((workspace:FindPartsInRegion3WithIgnoreList(p37.region, p37.groupParts))) do
		if p37:findPart(v128) then
			table.insert(v124, v128);
		end;
	end;
	return v124;
end;
function v9.getRandomPoint(p38)
	local v129 = nil;
	local v130 = nil;
	local l__exactRegion__131 = p38.exactRegion;
	local l__Size__132 = l__exactRegion__131.Size;
	local l__CFrame__133 = l__exactRegion__131.CFrame;
	local v134 = Random.new();
	local v135 = nil;
	while true do
		v129 = l__CFrame__133 * CFrame.new(v134:NextNumber(-l__Size__132.X / 2, l__Size__132.X / 2), v134:NextNumber(-l__Size__132.Y / 2, l__Size__132.Y / 2), v134:NextNumber(-l__Size__132.Z / 2, l__Size__132.Z / 2));
		v130 = u14.new(v129, Vector3.new(0.1, 0.1, 0.1)):FindPartsInRegion3WithWhiteList(p38.groupParts, #p38.groupParts);
		if #v130 > 0 then
			v135 = u3.verifyTouchingParts({ v129.Position }, v130);
		end;
		if v135 then
			break;
		end;	
	end;
	return v129.Position, v130;
end;
function v9.setAccuracy(p39, p40)
	local v136 = tonumber(p40);
	if not v136 then
		v136 = l__enums__4.Accuracy[p40];
		if not v136 then
			error(("'%s' is an invalid enumName!"):format(p40));
		end;
	elseif not l__enums__4.Accuracy.getName(v136) then
		error(("%s is an invalid enumId!"):format(v136));
	end;
	p39.accuracy = v136;
end;
function v9.setDetection(p41, p42)
	local v137 = tonumber(p42);
	if not v137 then
		v137 = l__enums__4.Detection[p42];
		if not v137 then
			error(("'%s' is an invalid enumName!"):format(p42));
		end;
	elseif not l__enums__4.Detection.getName(v137) then
		error(("%s is an invalid enumId!"):format(v137));
	end;
	p41.enterDetection = v137;
	p41.exitDetection = v137;
end;
function v9.destroy(p43)
	p43._maid:clean();
end;
v9.Destroy = v9.destroy;
return v9;
