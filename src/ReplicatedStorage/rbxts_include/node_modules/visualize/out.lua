
-- Decompiled with the Synapse X Luau decompiler.

local v1 = _G[script];
local v2 = v1.import(script, v1.getModule(script, "services"));
local v3 = setmetatable({}, {
	__tostring = function()
		return "Visualizer";
	end
});
v3.__index = v3;
function v3.new(...)
	local v4 = setmetatable({}, v3);
	v4:constructor(...);
	return v4;
end;
local l__RunService__1 = v2.RunService;
function v3.constructor(p1, p2)
	p1.config = {
		enabled = true, 
		color = Color3.new(1, 1, 1), 
		alwaysOnTop = true, 
		vectorRadius = 0.1, 
		pointRadius = 0.1, 
		lineRadius = 0.02, 
		lineInnerRadius = 0, 
		transparency = 0.5, 
		cframeLength = 1, 
		cacheAdornments = true, 
		vectorLine = false
	};
	p1.swappable = {};
	p1.vectors = p1:createSwappable();
	p1.points = p1:createSwappable();
	p1.lines = p1:createSwappable();
	if p2 then
		p1:configure(p2);
	end;
	if l__RunService__1:IsServer() then
		l__RunService__1.Heartbeat:Connect(function()
			return p1:step();
		end);
		return;
	end;
	l__RunService__1.RenderStepped:Connect(function()
		return p1:step();
	end);
end;
local l__Workspace__2 = v2.Workspace;
function v3.createHandleAdornment(p3, p4)
	local v5 = Instance.new(p4);
	v5.Transparency = p3.config.transparency;
	v5.AlwaysOnTop = p3.config.alwaysOnTop;
	v5.Color3 = p3.config.color;
	v5.Visible = true;
	v5.ZIndex = 2;
	v5.Adornee = l__Workspace__2.Terrain;
	v5.Parent = l__Workspace__2.Terrain;
	return v5;
end;
function v3.createSwappable(p5)
	local v6 = {
		used = {}, 
		unused = {}
	};
	local l__swappable__7 = p5.swappable;
	l__swappable__7[#l__swappable__7 + 1] = v6;
	return v6;
end;
function v3.pop(p6, p7)
	if not p6.config.cacheAdornments then
		return nil;
	end;
	local l__unused__8 = p7.unused;
	local v9 = #l__unused__8;
	l__unused__8[v9] = nil;
	return l__unused__8[v9];
end;
function v3.step(p8)
	for v10, v11 in ipairs(p8.swappable) do
		for v12, v13 in ipairs(v11.unused) do
			v13:Destroy();
		end;
		v11.unused = v11.used;
		v11.used = {};
	end;
end;
local u3 = v1.import(script, v1.getModule(script, "object-utils"));
function v3.configure(p9, p10)
	u3.assign(p9.config, p10);
end;
local u4 = nil;
function v3.vector(p11, p12, p13, p14)
	if p14 == nil then
		p14 = p11.config.color;
	end;
	if not p11.config.enabled or not u4.config.enabled then
		return nil;
	end;
	local v14 = p11:pop(p11.vectors);
	if not v14 then
		if p11.config.vectorLine then
			local v15 = "CylinderHandleAdornment";
		else
			v15 = "ConeHandleAdornment";
		end;
		v14 = p11:createHandleAdornment(v15);
	end;
	v14.Height = math.max(p13.Magnitude, 1);
	v14.Radius = p11.config.vectorRadius;
	v14.CFrame = CFrame.lookAt(p12, p12 + p13) * CFrame.new(0, 0, -(p11.config.vectorLine and p13.Magnitude / 2 or 0));
	v14.Color3 = p14;
	local l__used__16 = p11.vectors.used;
	l__used__16[#l__used__16 + 1] = v14;
end;
function v3.point(p15, p16, p17)
	if p17 == nil then
		p17 = p15.config.color;
	end;
	if not p15.config.enabled or not u4.config.enabled then
		return nil;
	end;
	local v17 = p15:pop(p15.points) or p15:createHandleAdornment("SphereHandleAdornment");
	v17.Radius = p15.config.pointRadius;
	v17.CFrame = CFrame.new(p16);
	v17.Color3 = p17;
	local l__used__18 = p15.points.used;
	l__used__18[#l__used__18 + 1] = v17;
end;
function v3.line(p18, p19, p20, p21)
	if p21 == nil then
		p21 = p18.config.color;
	end;
	if not p18.config.enabled or not u4.config.enabled then
		return nil;
	end;
	local v19 = p18:pop(p18.lines) or p18:createHandleAdornment("CylinderHandleAdornment");
	v19.Height = (p19 - p20).Magnitude;
	v19.Radius = p18.config.lineRadius;
	v19.InnerRadius = p18.config.lineInnerRadius;
	v19.CFrame = CFrame.lookAt(p19, p20) * CFrame.new(0, 0, -(p19 - p20).Magnitude / 2);
	v19.Color3 = p21;
	local l__used__20 = p18.lines.used;
	l__used__20[#l__used__20 + 1] = v19;
end;
function v3.cframe(p22, p23, p24)
	if p24 == nil then
		p24 = p22.config.color;
	end;
	p22:vector(p23.Position, p23.LookVector * p22.config.cframeLength, p24);
end;
u4 = v3.new();
return {
	Visualizer = v3, 
	Visualize = u4
};

