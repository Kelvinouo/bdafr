-- Script Hash: f62c252583a99b8518b398d7998eb3ab6d14e6d8be48362099c8fc4481dd83facc67664e556ca732e520fe2d04c5ee10
-- Decompiled with the Synapse X Luau decompiler.

local l__RunService__1 = game:GetService("RunService");
local l__CollectionService__2 = game:GetService("CollectionService");
local v3 = l__RunService__1:IsRunning() and l__RunService__1:IsStudio();
local v4 = {};
local v5 = {};
local v6 = nil;
if v3 then
	local v7 = Instance.new("Camera", script);
	v7.Name = "NonReplicated";
	v6 = Instance.new("Folder", v7);
	v6.Name = "RunningTrees(debug)";
	l__CollectionService__2:AddTag(v6, "_btRunningTrees");
end;
v4.SharedBlackboards = {};
local function u1(p1, p2)
	local function v8()
		local u2 = 0;
		local u3 = nil;
		local u4 = nil;
		local u5 = 0;
		return function()
			u2 = u2 + 1;
			if u2 == #p2 + 1 then
				u3 = nil;
			end;
			if not u3 then
				if u4 then
					return nil;
				end;
				u5 = u5 + 1;
				u3 = p1.params.nodes[u5];
				u4 = u5 == #p1.params.nodes;
				u2 = #p2 + 1;
				u1(u3, p2);
			end;
			return p2[u2], #p2 + 1, u4;
		end;
	end;
	local function v9(p3)
		local v10 = {
			type = p3
		};
		p2[#p2 + 1] = v10;
		return v10, #p2;
	end;
	if p1.type == "task" then
		assert(p1.params.run, "Can't process tree; task leaf node has no run func parameter");
		local v11 = v9("task");
		v11.start = p1.params.start;
		v11.run = p1.params.run;
		v11.finish = p1.params.finish;
		v11.onsuccess = true;
		v11.onfail = false;
		v11.nodefolder = p1.params.nodefolder;
		return;
	end;
	if p1.type == "blackboard" then
		local v12 = v9("blackboard");
		v12.onsuccess = true;
		v12.onfail = false;
		v12.key = p1.params.key;
		v12.board = p1.params.board;
		local v13 = p1.params.value:lower();
		local v14 = false;
		if v13 == "true" then
			v12.returntype = 1;
		elseif v13 == "false" then
			v12.returntype = 2;
		elseif v13 == "unset" or v13 == "nil" then
			v12.returntype = 3;
		elseif v13 == "set" then
			v12.returntype = 4;
		else
			v14 = true;
			v12.returntype = p1.params.value;
		end;
		v12.comparestring = v14;
		return;
	end;
	if p1.type == "tree" then
		assert(p1.params.tree, "Can't process tree; tree leaf node has no linked tree object");
		local v15 = v9("tree");
		v15.tree = p1.params.tree;
		v15.onsuccess = true;
		v15.onfail = false;
		v15.nodefolder = p1.params.nodefolder;
		return;
	end;
	if p1.type == "always_succeed" then
		assert(#p1.params.nodes <= 1, "Can't process tree; succeed decorator with multiple children");
		if p1.params.nodes[1] then
			local v16, v17, v18 = v8();
			while true do
				local v19, v20, v21 = v16(v17, v18);
				if not v19 then
					break;
				end;
				if v19.onsuccess == false then
					v19.onsuccess = true;
				end;
				if v19.onfail == false then
					v19.onfail = true;
				end;			
			end;
			return;
		else
			v9("succeed").onsuccess = true;
			return;
		end;
	end;
	if p1.type == "always_fail" then
		assert(#p1.params.nodes <= 1, "Can't process tree; fail decorator with multiple children");
		if p1.params.nodes[1] then
			local v22, v23, v24 = v8();
			while true do
				local v25, v26, v27 = v22(v23, v24);
				if not v25 then
					break;
				end;
				if v25.onsuccess == true then
					v25.onsuccess = false;
				end;
				if v25.onfail == true then
					v25.onfail = false;
				end;			
			end;
			return;
		else
			v9("fail").onfail = false;
			return;
		end;
	end;
	if p1.type == "invert" then
		assert(#p1.params.nodes <= 1, "Can't process tree; invert decorator with multiple children");
		assert(#p1.params.nodes == 1, "Can't process tree; hanging invert decorator");
		local v28, v29, v30 = v8();
		while true do
			local v31, v32, v33 = v28(v29, v30);
			if not v31 then
				break;
			end;
			if v31.onsuccess == true then
				v31.onsuccess = false;
			elseif v31.onsuccess == false then
				v31.onsuccess = true;
			end;
			if v31.onfail == false then
				v31.onfail = true;
			elseif v31.onfail == true then
				v31.onfail = false;
			end;		
		end;
		return;
	end;
	if p1.type == "repeat" then
		assert(#p1.params.nodes <= 1, "Can't process tree; repeat decorator with multiple children");
		assert(#p1.params.nodes == 1, "Can't process tree; hanging repeat decorator");
		local v34 = #p2 + 1;
		if p1.params.count then
			local v35 = p1.params.count > 0 and p1.params.count or nil;
		else
			v35 = nil;
		end;
		if v35 and v35 > 0 then
			v9("repeat-start");
			local v36, v37 = v9("repeat");
			v36.repeatGoal = v35;
			v36.repeatCount = 0;
			v36.onsuccess = true;
			v36.onfail = false;
			v34 = v37;
		end;
		local l__breakonfail__38 = p1.params.breakonfail;
		local v39, v40, v41 = v8();
		while true do
			local v42, v43, v44 = v39(v40, v41);
			if not v42 then
				break;
			end;
			if v42.onsuccess == true then
				v42.onsuccess = v34;
			elseif v42.onsuccess == false and not l__breakonfail__38 then
				v42.onsuccess = v34;
			end;
			if v42.onfail == false and not l__breakonfail__38 then
				v42.onfail = v34;
			elseif v42.onfail == true then
				v42.onfail = v34;
			end;		
		end;
		return;
	end;
	if p1.type == "while" then
		assert(#p1.params.nodes == 2, "Can't process tree; while composite without 2 children");
		local v45 = #p2 + 1;
		if p1.params.count then
			local v46 = p1.params.count > 0 and p1.params.count or nil;
		else
			v46 = nil;
		end;
		if v46 and v46 > 0 then
			local v47, v48 = v9("repeat-start");
			local v49, v50 = v9("repeat");
			v49.repeatGoal = v46;
			v49.repeatCount = 0;
			v49.onsuccess = false;
			v49.onfail = false;
			v45 = v50;
		end;
		u1(p1.params.nodes[1], p2);
		local v51 = #p2 + 1;
		u1(p1.params.nodes[2], p2);
		for v52 = #p2 + 1, v51 - 1 do
			local v53 = p2[v52];
			if v53.onsuccess == true then
				v53.onsuccess = v51;
			end;
			if v53.onfail == true then
				v53.onfail = v51;
			end;
		end;
		for v54 = v51, #p2 do
			local v55 = p2[v54];
			if v55.onsuccess == false then
				v55.onsuccess = v45;
			end;
			if v55.onfail == false then
				v55.onfail = v45;
			end;
		end;
		return;
	end;
	if p1.type == "sequence" then
		assert(#p1.params.nodes >= 1, "Can't process tree; sequence composite node has no children");
		local v56, v57, v58 = v8();
		while true do
			local v59, v60, v61 = v56(v57, v58);
			if not v59 then
				break;
			end;
			if v59.onsuccess == true then
				v59.onsuccess = not v61 and v60 or true;
			end;
			if v59.onfail == true then
				v59.onfail = not v61 and v60 or true;
			end;		
		end;
		return;
	end;
	if p1.type == "selector" then
		assert(#p1.params.nodes >= 1, "Can't process tree; selector composite node has no children");
		local v62, v63, v64 = v8();
		while true do
			local v65, v66, v67 = v62(v63, v64);
			if not v65 then
				break;
			end;
			if v65.onsuccess == false then
				v65.onsuccess = not v67 and v66 or false;
			end;
			if v65.onfail == false then
				v65.onfail = not v67 and v66 or false;
			end;		
		end;
		return;
	end;
	if p1.type ~= "random" then
		if p1.type == "root" then
			assert(#p2 == 0, "Can't process tree; root node found at nonroot location");
			u1(p1.tree, p2);
			for v68 = 1, #p2 do
				local v69 = p2[v68];
				if v69.onsuccess == true then
					v69.onsuccess = #p2 + 1;
				elseif v69.onsuccess == false then
					v69.onsuccess = #p2 + 2;
				end;
				if v69.onfail == true then
					v69.onfail = #p2 + 1;
				elseif v69.onfail == false then
					v69.onfail = #p2 + 2;
				end;
			end;
			return;
		else
			error("ProcessNode: bad node.type " .. tostring(p1.type));
			return;
		end;
	end;
	assert(#p1.params.nodes >= 1, "Can't process tree; random composite node has no children");
	local v70 = v9("random");
	v70.indices = {};
	for v71, v72 in pairs(p1.params.nodes) do
		if v72.weight then
			local v73 = #v70.indices;
			local v74 = #p2 + 1;
			for v75 = 1, v72.weight do
				v70.indices[v73 + v75] = v74;
			end;
		else
			v70.indices[#v70.indices + 1] = #p2 + 1;
		end;
		u1(v72, p2);
	end;
end;
local v76 = {
	abort = function(p4, p5, ...)
		assert(typeof(p5) == "table", "The first argument of a behavior tree's abort method must be a table!");
		local v77 = p4.IndexLookup[p5];
		if not v77 then
			return;
		end;
		local v78 = p4.nodes[v77];
		if v78.type == "task" and v78.finish then
			v78.finish(p5, 2, ...);
		end;
		p4.IndexLookup[p5] = 1;
	end
};
function v76.run(p6, p7, ...)
	assert(typeof(p7) == "table", "The first argument of a behavior tree's run method must be a table!");
	local v79 = nil;
	if v3 and p6.folder then
		local l__Name__80 = p6.folder.Name;
		local v81 = tostring(p7);
		local v82 = v6:FindFirstChild(l__Name__80);
		if not v82 then
			v82 = Instance.new("Folder");
			v82.Name = l__Name__80;
			v82.Parent = v6;
		end;
		local v83 = v82:FindFirstChild(v81);
		if not v83 then
			local v84 = Instance.new("Folder");
			v84.Name = v81;
			Instance.new("ObjectValue", v84).Name = "Node";
			local v85 = Instance.new("ObjectValue", v84);
			v85.Name = "TreeFolder";
			v85.Value = p6.folder;
			local v86 = p7.name or p7.Name;
			if v86 and typeof(v86) ~= "string" then
				v86 = nil;
			end;
			if not v86 then
				for v87, v88 in pairs(p7) do
					if typeof(v88) == "Instance" then
						v86 = v88.Name;
					end;
				end;
			end;
			if v86 then
				local v89 = Instance.new("StringValue", v83);
				v89.Name = "Name";
				v89.Value = v86;
			end;
			v83.Parent = v82;
		end;
		v79 = v83.Node;
	end;
	if p6.running then
		return;
	end;
	local l__nodes__90 = p6.nodes;
	local v91 = p6.IndexLookup[p7] and 1;
	local v92 = p7.Blackboard;
	if not v92 then
		v92 = {};
		p7.Blackboard = v92;
	end;
	if not p7.SharedBlackboards then
		p7.SharedBlackboards = v4.SharedBlackboards;
	end;
	local v93 = #l__nodes__90;
	local v94 = p6.paused;
	p6.paused = false;
	p6.running = true;
	while v91 <= v93 do
		local v95 = l__nodes__90[v91];
		if v3 and p6.folder then
			v79.Value = v95.nodefolder;
		end;
		if v95.type == "task" then
			if v94 then
				v94 = false;
			elseif v95.start then
				v95.start(p7, ...);
			end;
			local v96 = v95.run(p7, ...);
			if v96 == nil then
				warn("node.run did not call success, running or fail, acting as fail");
				v96 = 2;
			end;
			if v96 == 3 then
				p6.paused = true;
				break;
			end;
			if v96 == 1 then
				if v95.finish then
					v95.finish(p7, v96, ...);
				end;
				v91 = v95.onsuccess;
			elseif v96 == 2 then
				if v95.finish then
					v95.finish(p7, v96, ...);
				end;
				v91 = v95.onfail;
			else
				error("bad node.status");
			end;
		elseif v95.type == "blackboard" then
			local v97 = false;
			if v95.board == "Entity" then
				local v98 = v92;
			else
				local v99 = v4.SharedBlackboards[v95.board];
				if not v99 then
					warn(string.format("Shared Blackboard %s is not registered, acting as fail"), v95.board);
				end;
				v98 = v99;
			end;
			if v98 then
				local v100 = v98[v95.key];
				local v101 = tostring(v100);
				if v95.comparestring then
					v97 = v101 and v101 == v95.returntype;
				elseif v95.returntype == 1 then
					v97 = v100 == true;
				elseif v95.returntype == 2 then
					v97 = v100 == false;
				elseif v95.returntype == 3 then
					if v100 ~= nil then
						v97 = false;
					else
						v97 = true;
					end;
				elseif v95.returntype == 4 then
					if v100 == nil then
						v97 = false;
					else
						v97 = true;
					end;
				end;
			end;
			v91 = v97 == true and v95.onsuccess or v95.onfail;
		elseif v95.type == "tree" then
			local v102 = v95.tree:run(p7, ...);
			if v102 == 3 then
				p6.paused = true;
				break;
			end;
			if v102 == 1 then
				v91 = v95.onsuccess;
			elseif v102 == 2 then
				v91 = v95.onfail;
			else
				error("bad tree result");
			end;
		elseif v95.type == "random" then
			v91 = v95.indices[math.random(1, #v95.indices)];
		elseif v95.type == "repeat-start" then
			v91 = v91 + 1;
			l__nodes__90[v91].repeatCount = 0;
		elseif v95.type == "repeat" then
			v95.repeatCount = v95.repeatCount + 1;
			if v95.repeatGoal < v95.repeatCount then
				v91 = v95.onsuccess;
			else
				v91 = v91 + 1;
			end;
		elseif v95.type == "succeed" then
			v91 = v95.onsuccess;
		elseif v95.type == "fail" then
			v91 = v95.onfail;
		else
			error("bad node.type");
		end;	
	end;
	if v91 == v93 + 1 then
		local v103 = 1;
	elseif v91 == v93 + 2 then
		v103 = 2;
	else
		v103 = 3;
	end;
	p6.IndexLookup[p7] = v91 <= v93 and v91 or 1;
	p6.running = false;
	return v103;
end;
v76.Run = v76.run;
v76.Abort = v76.abort;
function v4.new(p8)
	local v104 = {};
	u1({
		type = "root", 
		tree = p8.tree, 
		params = {}
	}, v104);
	return setmetatable({
		nodes = v104, 
		IndexLookup = {}, 
		folder = p8.treeFolder
	}, {
		__index = v76
	});
end;
function v4.Sequence(p9)
	return {
		type = "sequence", 
		params = p9
	};
end;
function v4.Selector(p10)
	return {
		type = "selector", 
		params = p10
	};
end;
function v4.Random(p11)
	return {
		type = "random", 
		params = p11
	};
end;
function v4.While(p12)
	return {
		type = "while", 
		params = p12
	};
end;
function v4.Succeed(p13)
	return {
		type = "always_succeed", 
		params = p13
	};
end;
function v4.Fail(p14)
	return {
		type = "always_fail", 
		params = p14
	};
end;
function v4.Invert(p15)
	return {
		type = "invert", 
		params = p15
	};
end;
function v4.Repeat(p16)
	return {
		type = "repeat", 
		params = p16
	};
end;
function v4.Task(p17)
	return {
		type = "task", 
		params = p17
	};
end;
function v4.Tree(p18)
	return {
		type = "tree", 
		params = p18
	};
end;
v4["Blackboard Query"] = function(p19)
	return {
		type = "blackboard", 
		params = p19
	};
end;
return v4;
