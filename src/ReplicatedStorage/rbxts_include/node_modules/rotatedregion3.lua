-- Script Hash: 109f6ea4b5b2fe34acc6da412895cca4bfe8f6ab9cb8c934ec96b8736d203ccc1b077a92a6e2fef97de87e769dc3a834
-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
v1.__index = v1;
local u1 = require(script:WaitForChild("Vertices"));
local u2 = require(script:WaitForChild("Supports"));
local function u3(p1)
	local v2 = {};
	local v3 = {};
	local v4 = {};
	for v5 = 1, #p1 do
		v2[v5] = p1[v5].x;
		v3[v5] = p1[v5].y;
		v4[v5] = p1[v5].z;
	end;
	return Vector3.new(math.min(unpack(v2)), math.min(unpack(v3)), math.min(unpack(v4))), Vector3.new(math.max(unpack(v2)), math.max(unpack(v3)), math.max(unpack(v4)));
end;
function v1.new(p2, p3)
	local v6 = setmetatable({}, v1);
	v6.CFrame = p2;
	v6.Size = p3;
	v6.Shape = "Block";
	v6.Set = u1.Block(p2, p3 / 2);
	v6.Support = u2.PointCloud;
	v6.Centroid = p2.p;
	v6.AlignedRegion3 = Region3.new(u3(v6.Set));
	return v6;
end;
v1.Block = v1.new;
function v1.Wedge(p4, p5)
	local v7 = setmetatable({}, v1);
	v7.CFrame = p4;
	v7.Size = p5;
	v7.Shape = "Wedge";
	v7.Set = u1.Wedge(p4, p5 / 2);
	v7.Support = u2.PointCloud;
	v7.Centroid = u1.GetCentroid(v7.Set);
	v7.AlignedRegion3 = Region3.new(u3(v7.Set));
	return v7;
end;
function v1.CornerWedge(p6, p7)
	local v8 = setmetatable({}, v1);
	v8.CFrame = p6;
	v8.Size = p7;
	v8.Shape = "CornerWedge";
	v8.Set = u1.CornerWedge(p6, p7 / 2);
	v8.Support = u2.PointCloud;
	v8.Centroid = u1.GetCentroid(v8.Set);
	v8.AlignedRegion3 = Region3.new(u3(v8.Set));
	return v8;
end;
local function u4(p8, p9)
	return { p8:PointToWorldSpace(Vector3.new(-p9.x, p9.y, p9.z)), p8:PointToWorldSpace(Vector3.new(-p9.x, -p9.y, p9.z)), p8:PointToWorldSpace(Vector3.new(-p9.x, -p9.y, -p9.z)), p8:PointToWorldSpace(Vector3.new(p9.x, -p9.y, -p9.z)), p8:PointToWorldSpace(Vector3.new(p9.x, p9.y, -p9.z)), p8:PointToWorldSpace(Vector3.new(p9.x, p9.y, p9.z)), p8:PointToWorldSpace(Vector3.new(p9.x, -p9.y, p9.z)), p8:PointToWorldSpace(Vector3.new(-p9.x, p9.y, -p9.z)) };
end;
function v1.Cylinder(p10, p11)
	local v9 = setmetatable({}, v1);
	v9.CFrame = p10;
	v9.Size = p11;
	v9.Shape = "Cylinder";
	v9.Set = { p10, p11 / 2 };
	v9.Support = u2.Cylinder;
	v9.Centroid = p10.p;
	v9.AlignedRegion3 = Region3.new(u3(u4(unpack(v9.Set))));
	return v9;
end;
function v1.Ball(p12, p13)
	local v10 = setmetatable({}, v1);
	v10.CFrame = p12;
	v10.Size = p13;
	v10.Shape = "Ball";
	v10.Set = { p12, p13 / 2 };
	v10.Support = u2.Ellipsoid;
	v10.Centroid = p12.p;
	v10.AlignedRegion3 = Region3.new(u3(u4(unpack(v10.Set))));
	return v10;
end;
function v1.FromPart(p14)
	return v1[u1.Classify(p14)](p14.CFrame, p14.Size);
end;
local u5 = require(script:WaitForChild("GJK"));
function v1.CastPoint(p15, p16)
	return u5.new(p15.Set, { p16 }, p15.Centroid, p16, p15.Support, u2.PointCloud):IsColliding();
end;
function v1.CastPart(p17, p18)
	local v11 = v1.FromPart(p18);
	return u5.new(p17.Set, v11.Set, p17.Centroid, v11.Centroid, p17.Support, v11.Support):IsColliding();
end;
function v1.FindPartsInRegion3(p19, p20, p21)
	local v12 = {};
	local v13 = game.Workspace:FindPartsInRegion3(p19.AlignedRegion3, p20, p21);
	for v14 = 1, #v13 do
		if p19:CastPart(v13[v14]) then
			table.insert(v12, v13[v14]);
		end;
	end;
	return v12;
end;
function v1.FindPartsInRegion3WithIgnoreList(p22, p23, p24)
	p23 = p23 or {};
	local v15 = {};
	local v16 = game.Workspace:FindPartsInRegion3WithIgnoreList(p22.AlignedRegion3, p23, p24);
	for v17 = 1, #v16 do
		if p22:CastPart(v16[v17]) then
			table.insert(v15, v16[v17]);
		end;
	end;
	return v15;
end;
function v1.FindPartsInRegion3WithWhiteList(p25, p26, p27)
	p26 = p26 or {};
	local v18 = {};
	local v19 = game.Workspace:FindPartsInRegion3WithWhiteList(p25.AlignedRegion3, p26, p27);
	for v20 = 1, #v19 do
		if p25:CastPart(v19[v20]) then
			table.insert(v18, v19[v20]);
		end;
	end;
	return v18;
end;
function v1.Cast(p28, p29, p30)
	p29 = type(p29) == "table" and p29 or { p29 };
	return p28:FindPartsInRegion3WithIgnoreList(p29, p30);
end;
return v1;
