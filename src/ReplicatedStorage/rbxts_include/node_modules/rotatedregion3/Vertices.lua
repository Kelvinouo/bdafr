-- Decompiled with the Synapse X Luau decompiler.

local v1 = Vector3.new(1, 0, 0);
local v2 = Vector3.new(0, 1, 0);
local v3 = Vector3.new(0, 0, 1);
local v4 = Vector3.new(-1, 0, 0);
local v5 = Vector3.new(0, -1, 0);
local v6 = Vector3.new(0, 0, -1);
local v7 = { 1, 2, 3, 4, 5, 6, 7, 8 };
local v8 = { 1, 2, 5, 6, 7, 8 };
local v9 = { 4, 5, 6, 7, 8 };
local u1 = { Vector3.new(1, 1, 1), Vector3.new(-1, 1, 1), Vector3.new(-1, 1, -1), Vector3.new(1, 1, -1), Vector3.new(1, -1, 1), Vector3.new(-1, -1, 1), Vector3.new(-1, -1, -1), Vector3.new(1, -1, -1) };
local u2 = math.pi * 2;
local v10 = {};
for v11 = 1, #v7 do
	v10[v11] = u1[v7[v11]];
end;
local v12 = {};
for v13 = 1, #v8 do
	v12[v13] = u1[v8[v13]];
end;
local v14 = {};
for v15 = 1, #v9 do
	v14[v15] = u1[v9[v15]];
end;
local v16 = {};
local function u3(p1, p2, p3)
	local v17 = {};
	for v18 = 1, #p3 do
		v17[v18] = p1:PointToWorldSpace(p3[v18] * p2);
	end;
	return v17;
end;
function v16.Block(p4, p5)
	return u3(p4, p5, v10);
end;
function v16.Wedge(p6, p7)
	return u3(p6, p7, v12);
end;
function v16.CornerWedge(p8, p9)
	return u3(p8, p9, v14);
end;
local u4 = (function(p10)
	local v19 = {};
	local v20 = u2 / p10;
	for v21 = 1, p10 do
		local v22 = CFrame.fromAxisAngle(v1, v21 * v20) * v2;
		v19[v21] = v1 + v22;
		v19[p10 + v21] = v4 + v22;
	end;
	return v19;
end)(20);
function v16.Cylinder(p11, p12)
	return u3(p11, p12, u4);
end;
local u5 = (function(p13)
	local v23 = { 1, 12, 6, 1, 6, 2, 1, 2, 8, 1, 8, 11, 1, 11, 12, 2, 6, 10, 6, 12, 5, 12, 11, 3, 11, 8, 7, 8, 2, 9, 4, 10, 5, 4, 5, 3, 4, 3, 7, 4, 7, 9, 4, 9, 10, 5, 10, 6, 3, 5, 12, 7, 3, 11, 9, 7, 8, 10, 9, 2 };
	local u6 = {};
	local u7 = { Vector3.new(-1, 1.618033988749895, 0), Vector3.new(1, 1.618033988749895, 0), Vector3.new(-1, -1.618033988749895, 0), Vector3.new(1, -1.618033988749895, 0), Vector3.new(0, -1, 1.618033988749895), Vector3.new(0, 1, 1.618033988749895), Vector3.new(0, -1, -1.618033988749895), Vector3.new(0, 1, -1.618033988749895), Vector3.new(1.618033988749895, 0, -1), Vector3.new(1.618033988749895, 0, 1), Vector3.new(-1.618033988749895, 0, -1), Vector3.new(-1.618033988749895, 0, 1) };
	for v24 = 1, p13 do
		for v25 = #v23, 1, -3 do
			local v26 = v23[v25 - 2];
			local v27 = v23[v25 - 1];
			local v28 = v23[v25];
			local v29 = v26 < v27 and v26 .. "," .. v27 or v27 .. "," .. v26;
			if not u6[v29] then
				u7[#u7 + 1] = (u7[v26] + u7[v27]) / 2;
				u6[v29] = #u7;
			end;
			local v30 = u6[v29];
			local v31 = v27 < v28 and v27 .. "," .. v28 or v28 .. "," .. v27;
			if not u6[v31] then
				u7[#u7 + 1] = (u7[v27] + u7[v28]) / 2;
				u6[v31] = #u7;
			end;
			local v32 = u6[v31];
			local v33 = v28 < v26 and v28 .. "," .. v26 or v26 .. "," .. v28;
			if not u6[v33] then
				u7[#u7 + 1] = (u7[v28] + u7[v26]) / 2;
				u6[v33] = #u7;
			end;
			local v34 = u6[v33];
			v23[#v23 + 1] = v26;
			v23[#v23 + 1] = v30;
			v23[#v23 + 1] = v34;
			v23[#v23 + 1] = v27;
			v23[#v23 + 1] = v32;
			v23[#v23 + 1] = v30;
			v23[#v23 + 1] = v28;
			v23[#v23 + 1] = v34;
			v23[#v23 + 1] = v32;
			v23[#v23 + 1] = v30;
			v23[#v23 + 1] = v32;
			v23[#v23 + 1] = v34;
			table.remove(v23, v25);
			table.remove(v23, v25 - 1);
			table.remove(v23, v25 - 2);
		end;
	end;
	for v35 = 1, #u7 do
		u7[v35] = u7[v35].Unit;
	end;
	return u7;
end)(2);
function v16.Ball(p14, p15)
	return u3(p14, p15, u5);
end;
function v16.GetCentroid(p16)
	local v36 = nil;
	v36 = p16[1];
	for v37 = 2, #p16 do
		v36 = v36 + p16[2];
	end;
	return local v38 / #p16;
end;
function v16.Classify(p17)
	if p17.ClassName == "Part" then
		if p17.Shape == Enum.PartType.Block then
			return "Block";
		elseif p17.Shape == Enum.PartType.Cylinder then
			return "Cylinder";
		elseif p17.Shape == Enum.PartType.Ball then
			return "Ball";
		else
			return;
		end;
	else
		if p17.ClassName == "WedgePart" then
			return "Wedge";
		end;
		if p17.ClassName == "CornerWedgePart" then
			return "CornerWedge";
		end;
		if not p17:IsA("BasePart") then
			return;
		end;
	end;
	return "Block";
end;
return v16;
