-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
v1.__index = v1;
function v1.new(p1)
	local v2 = {
		_listeners = {}, 
		_store = p1
	};
	setmetatable(v2, v1);
	return v2;
end;
local function u1(p2, ...)
	local v3 = {};
	local v4 = #p2;
	for v5 = 1, v4 do
		v3[v5] = p2[v5];
	end;
	for v6 = 1, select("#", ...) do
		v3[v4 + v6] = select(v6, ...);
	end;
	return v3;
end;
local function u2(p3, p4)
	local v7 = {};
	for v8 = 1, #p3 do
		if p3[v8] ~= p4 then
			table.insert(v7, p3[v8]);
		end;
	end;
	return v7;
end;
function v1.connect(p5, p6)
	if typeof(p6) ~= "function" then
		error("Expected the listener to be a function.");
	end;
	if p5._store and p5._store._isDispatching then
		error("You may not call store.changed:connect() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store:getState() in the callback to access the latest state. ");
	end;
	local v9 = {
		callback = p6, 
		disconnected = false, 
		connectTraceback = debug.traceback(), 
		disconnectTraceback = nil
	};
	p5._listeners = u1(p5._listeners, v9);
	return {
		disconnect = function()
			if v9.disconnected then
				error(("Listener connected at: \n%s\nwas already disconnected at: \n%s\n"):format(tostring(v9.connectTraceback), tostring(v9.disconnectTraceback)));
			end;
			if p5._store and p5._store._isDispatching then
				error("You may not unsubscribe from a store listener while the reducer is executing.");
			end;
			v9.disconnected = true;
			v9.disconnectTraceback = debug.traceback();
			p5._listeners = u2(p5._listeners, v9);
		end
	};
end;
function v1.fire(p7, ...)
	local v10, v11, v12 = ipairs(p7._listeners);
	while true do
		v10(v11, v12);
		if not v10 then
			break;
		end;
		v12 = v10;
		if not v11.disconnected then
			v11.callback(...);
		end;	
	end;
end;
return v1;
