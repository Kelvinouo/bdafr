-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
local function u1(p1)
	local v2 = table.create(#p1);
	if #p1 > 0 then
		table.move(p1, 1, #p1, 1, v2);
		return v2;
	end;
	for v3, v4 in pairs(p1) do
		v2[v3] = v4;
	end;
	return v2;
end;
local function u2(p2)
	assert(type(p2) == "table", "First argument must be a table");
	local function u3(p3)
		local v5 = table.create(#p3);
		for v6, v7 in pairs(p3) do
			if type(v7) == "table" then
				v5[v6] = u3(v7);
			else
				v5[v6] = v7;
			end;
		end;
		return v5;
	end;
	return u3(p2);
end;
local function u4(p4, p5)
	assert(type(p4) == "table", "First argument must be a table");
	assert(type(p5) == "table", "Second argument must be a table");
	local v8 = u1(p4);
	for v9, v10 in pairs(v8) do
		local v11 = p5[v9];
		if v11 == nil then
			v8[v9] = nil;
		elseif type(v10) ~= type(v11) then
			if type(v11) == "table" then
				v8[v9] = u2(v11);
			else
				v8[v9] = v11;
			end;
		elseif type(v10) == "table" then
			v8[v9] = u4(v10, v11);
		end;
	end;
	for v12, v13 in pairs(p5) do
		if v8[v12] == nil then
			if type(v13) == "table" then
				v8[v12] = u2(v13);
			else
				v8[v12] = v13;
			end;
		end;
	end;
	return v8;
end;
local function u5(p6, p7)
	local v14 = #p6;
	p6[p7] = p6[v14];
	p6[v14] = nil;
end;
local u6 = Random.new();
local function u7(p8, p9)
	p9 = p9 and 1;
	local v15 = table.create(#p8);
	local function u8(p10, p11)
		for v16, v17 in ipairs(p10) do
			if type(v17) == "table" and p11 < p9 then
				u8(v17, p11 + 1);
			else
				table.insert(v15, v17);
			end;
		end;
	end;
	u8(p8, 0);
	return v15;
end;
local function u9(p12, p13)
	assert(type(p12) == "table", "First argument must be a table");
	assert(type(p13) == "function", "Second argument must be a function");
	local v18 = table.create(#p12);
	for v19, v20 in pairs(p12) do
		v18[v19] = p13(v20, v19, p12);
	end;
	return v18;
end;
local l__HttpService__10 = game:GetService("HttpService");
v1.Copy = u2;
v1.CopyShallow = u1;
v1.Sync = u4;
v1.FastRemove = u5;
function v1.FastRemoveFirstValue(p14, p15)
	local v21 = table.find(p14, p15);
	if not v21 then
		return false, nil;
	end;
	u5(p14, v21);
	return true, v21;
end;
v1.Map = u9;
function v1.Filter(p16, p17)
	assert(type(p16) == "table", "First argument must be a table");
	assert(type(p17) == "function", "Second argument must be a function");
	local v22 = table.create(#p16);
	if not (#p16 > 0) then
		for v23, v24 in pairs(p16) do
			if p17(v24, v23, p16) then
				v22[v23] = v24;
			end;
		end;
		return v22;
	end;
	local v25 = 0;
	for v26, v27 in ipairs(p16) do
		if p17(v27, v26, p16) then
			v25 = v25 + 1;
			v22[v25] = v27;
		end;
	end;
	return v22;
end;
function v1.Reduce(p18, p19, p20)
	assert(type(p18) == "table", "First argument must be a table");
	assert(type(p19) == "function", "Second argument must be a function");
	local v28 = true;
	if p20 ~= nil then
		v28 = type(p20) == "number";
	end;
	assert(v28, "Third argument must be a number or nil");
	local v29 = p20 and 0;
	for v30, v31 in pairs(p18) do
		v29 = p19(v29, v31, v30, p18);
	end;
	return v29;
end;
function v1.Assign(p21, ...)
	local v32 = u1(p21);
	for v33, v34 in ipairs({ ... }) do
		for v35, v36 in pairs(v34) do
			v32[v35] = v36;
		end;
	end;
	return v32;
end;
function v1.Extend(p22, p23)
	local v37 = u1(p22);
	for v38, v39 in ipairs(p23) do
		table.insert(v37, v39);
	end;
	return v37;
end;
function v1.Reverse(p24)
	local v40 = #p24;
	local v41 = table.create(v40);
	for v42 = 1, v40 do
		v41[v42] = p24[v40 - v42 + 1];
	end;
	return v41;
end;
function v1.Shuffle(p25, p26)
	assert(type(p25) == "table", "First argument must be a table");
	local v43 = u1(p25);
	local v44 = p26 or u6;
	for v45 = #p25, 2, -1 do
		local v46 = v44:NextInteger(1, v45);
		v43[v45] = v43[v46];
		v43[v46] = v43[v45];
	end;
	return v43;
end;
v1.Flat = u7;
function v1.FlatMap(p27, p28)
	return u7(u9(p27, p28));
end;
function v1.Keys(p29)
	local v47 = table.create(#p29);
	for v48, v49 in pairs(p29) do
		table.insert(v47, v48);
	end;
	return v47;
end;
function v1.Find(p30, p31)
	for v50, v51 in pairs(p30) do
		if p31(v51, v50, p30) then
			return v51, v50;
		end;
	end;
	return nil, nil;
end;
function v1.Every(p32, p33)
	for v52, v53 in pairs(p32) do
		if not p33(v53, v52, p32) then
			return false;
		end;
	end;
	return true;
end;
function v1.Some(p34, p35)
	for v54, v55 in pairs(p34) do
		if p35(v55, v54, p34) then
			return true;
		end;
	end;
	return false;
end;
function v1.IsEmpty(p36)
	return next(p36) == nil;
end;
function v1.EncodeJSON(p37)
	return l__HttpService__10:JSONEncode(p37);
end;
function v1.DecodeJSON(p38)
	return l__HttpService__10:JSONDecode(p38);
end;
return v1;
