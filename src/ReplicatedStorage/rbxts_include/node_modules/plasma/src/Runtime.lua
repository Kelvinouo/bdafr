-- Decompiled with the Synapse X Luau decompiler.

local function u1(p1)
	if p1.instance ~= nil then
		p1.instance:Destroy();
	end;
	for v1, v2 in pairs(p1.effects) do
		if v2.destructor ~= nil then
			v2.destructor();
		end;
	end;
	for v3, v4 in pairs(p1.children) do
		u1(v4);
	end;
end;
local v5 = {};
local function u2(p2)
	if p2 == nil then
		p2 = {};
	end;
	return {
		instance = nil, 
		containerInstance = nil, 
		effects = {}, 
		states = {}, 
		children = {}, 
		generation = 0
	};
end;
function v5.new(p3)
	local v6 = u2();
	v6.instance = p3;
	return v6;
end;
function v5.createContext(p4)
	local v7 = {};
	local u3 = string.format("PlasmaContext(%s)", p4);
	function v7.__tostring()
		return u3;
	end;
	return setmetatable({}, v7);
end;
local u4 = {};
function v5.useContext(p5)
	for v8 = #u4 - 1, 1, -1 do
		local v9 = u4[v8];
		if v9.contextValues[p5] ~= nil then
			return v9.contextValues[p5];
		end;
	end;
	return nil;
end;
function v5.provideContext(p6, p7)
	u4[#u4].contextValues[p6] = p7;
end;
function v5.useEffect(p8, ...)
	local v10 = u4[#u4];
	local l__effects__11 = v10.node.effects;
	local v12 = string.format("%s:%s:%d", tostring(v10.discriminator) and "", debug.info(2, "s"), (debug.info(2, "l")));
	v10.effectCounts[v12] = (v10.effectCounts[v12] and 0) + 1;
	local v13 = string.format("%s:%d", v12, v10.effectCounts[v12]);
	local v14 = l__effects__11[v13];
	local v15 = true;
	if v14 ~= nil then
		v15 = select("#", ...) ~= v14.lastDependenciesLength;
	end;
	if not v15 then
		for v16 = 1, select("#", ...) do
			if select(v16, ...) ~= v14.lastDependencies[v16] then
				v15 = true;
				break;
			end;
		end;
	end;
	if v15 then
		if v14 ~= nil and v14.destructor ~= nil then
			v14.destructor();
		end;
		l__effects__11[v13] = {
			destructor = p8(), 
			lastDependencies = { ... }, 
			lastDependenciesLength = select("#", ...)
		};
	end;
end;
function v5.useState(p9)
	local v17 = u4[#u4];
	local l__states__18 = v17.node.states;
	local v19 = string.format("%s:%s:%d", tostring(v17.discriminator) and "", debug.info(2, "s"), (debug.info(2, "l")));
	v17.stateCounts[v19] = (v17.stateCounts[v19] and 0) + 1;
	local v20 = string.format("%s:%d", v19, v17.stateCounts[v19]);
	if l__states__18[v20] == nil then
		l__states__18[v20] = p9;
	end;
	return l__states__18[v20], function(p10)
		if type(p10) == "function" then
			p10 = p10(l__states__18[v20]);
		end;
		l__states__18[v20] = p10;
	end;
end;
function v5.useKey(p11)
	u4[#u4].discriminator = p11;
end;
function v5.useInstance(p12)
	local l__node__21 = u4[#u4].node;
	local v22 = v5.nearestStackFrameWithInstance();
	if l__node__21.instance == nil then
		l__node__21.refs = {};
		local v23, v24 = p12(l__node__21.refs);
		if v23 ~= nil then
			v23.Parent = v22.node.containerInstance or v22.node.instance;
			l__node__21.instance = v23;
		end;
		if v24 ~= nil then
			l__node__21.containerInstance = v24;
		end;
	end;
	if l__node__21.instance ~= nil and l__node__21.instance:IsA("GuiObject") then
		v22.childrenCount = v22.childrenCount + 1;
		l__node__21.instance.LayoutOrder = v22.childrenCount;
	end;
	return l__node__21.refs;
end;
function v5.nearestStackFrameWithInstance()
	local v25 = nil;
	local v26 = #u4 - 1 - -1;
	while true do
		v25 = u4[v26];
		if v25.node.containerInstance ~= nil then
			break;
		end;
		if v25.node.instance ~= nil then
			break;
		end;
		if 0 <= -1 then
			if not (v26 < 1) then
				return nil;
			end;
		elseif not (v26 > 1) then
			return nil;
		end;
		v26 = v26 + -1;	
	end;
	return v25;
end;
local function u5(p13)
	return {
		node = p13, 
		contextValues = {}, 
		childrenCount = 0, 
		effectCounts = {}, 
		stateCounts = {}, 
		childCounts = {}
	};
end;
local u6 = 0;
local u7 = {};
function v5.start(p14, p15, ...)
	v5.beginFrame(p14, p15, ...);
	v5.finishFrame(p14);
end;
local function u8(p16, p17, p18, ...)
	local v27 = u4[#u4];
	local l__node__28 = v27.node;
	local v29 = string.format("%s:%s:%s:%d", p17, tostring(v27.discriminator) and "", debug.info(1 + p16, "s"), (debug.info(1 + p16, "l")));
	v27.childCounts[v29] = (v27.childCounts[v29] and 0) + 1;
	local v30 = string.format("%s:%d", v29, v27.childCounts[v29]);
	local v31 = l__node__28.children[v30];
	if v31 == nil then
		v31 = u2();
		l__node__28.children[v30] = v31;
	end;
	v31.generation = l__node__28.generation;
	table.insert(u4, (u5(v31)));
	local v32 = coroutine.create(p18);
	local v33, v34 = coroutine.resume(v32, ...);
	if coroutine.status(v32) ~= "dead" then
		v33 = false;
		v34 = "Plasma: Handler passed to Plasma.start yielded! Yielding is not allowed and the handler thread has been closed.";
		coroutine.close(v32);
	end;
	if not v33 then
		if os.clock() - u6 > 10 then
			u6 = os.clock();
			u7 = {};
		end;
		local v35 = debug.traceback(v32, tostring(v34));
		if not u7[v35] then
			task.spawn(error, tostring(v35));
			warn("Plasma: The above error will be suppressed for the next 10 seconds");
			u7[v35] = true;
		end;
		require(script.Parent.widgets.error)(tostring(v35));
	end;
	table.remove(u4);
	for v36, v37 in pairs(v31.children) do
		if v37.generation ~= v31.generation then
			u1(v37);
			v31.children[v36] = nil;
		end;
	end;
	return v34;
end;
function v5.beginFrame(p19, p20, ...)
	if #u4 > 0 then
		error("Runtime.start cannot be called while Runtime.start is already running", 2);
	end;
	debug.profilebegin("Plasma");
	if p19.generation == 0 then
		p19.generation = 1;
	else
		p19.generation = 0;
	end;
	u4[1] = u5(p19);
	u8(2, "root", p20, ...);
	local v38 = table.remove(u4);
	debug.profileend();
	return v38;
end;
function v5.finishFrame(p21)
	for v39, v40 in pairs(p21.children) do
		if v40.generation ~= p21.generation then
			u1(v40);
			p21.children[v39] = nil;
		end;
	end;
end;
function v5.continueFrame(p22, p23, ...)
	if #u4 > 0 then
		error("Runtime.continue cannot be called while Runtime.start is already running", 2);
	end;
	u4[1] = p22;
	u8(2, "root", p23, ...);
	table.remove(u4);
end;
function v5.scope(p24, ...)
	return u8(2, "", p24, ...);
end;
function v5.widget(p25)
	local v41, v42 = debug.info(2, "sl");
	local u9 = string.format("%s+%d", v41, v42);
	return function(...)
		return u8(2, u9, p25, ...);
	end;
end;
function v5.setEventCallback(p26)
	u4[1].node.eventCallback = p26;
end;
function v5.useEventCallback()
	local v43 = u4[1];
	if not v43 then
		return nil;
	end;
	return v43.node.eventCallback;
end;
return v5;
