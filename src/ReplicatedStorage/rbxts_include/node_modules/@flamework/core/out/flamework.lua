-- Decompiled with the Synapse X Luau decompiler.

local v1 = _G[script];
local v2 = v1.import(script, v1.getModule(script, "@rbxts", "services"));
local v3 = {};
local v4 = {
	isDefault = true
};
v3.flameworkConfig = v4;
v3.isInitialized = false;
local l__Reflect__1 = v1.import(script, script.Parent, "reflect").Reflect;
local u2 = nil;
local l__Modding__3 = v1.import(script, script.Parent, "modding").Modding;
function v3.resolveDependency(p1)
	local v5 = l__Reflect__1.idToObj[p1];
	if v5 == nil then
		error("Dependency " .. p1 .. " could not be found.");
	end;
	if not u2(v5) then
		error("Dependency " .. p1 .. " did not resolve to a constructor.");
	end;
	return l__Modding__3.resolveSingleton(v5);
end;
local l__RunService__4 = v2.RunService;
local l__Players__5 = v2.Players;
function v3._addPaths(...)
	local v6 = {};
	local v7, v8, v9 = ipairs({ ... });
	while true do
		v7(v8, v9);
		if not v7 then
			break;
		end;
		local v10 = table.remove(v8, 1);
		local v11 = game:GetService(v10);
		if v10 == "StarterPlayer" then
			if v8[1] ~= "StarterPlayerScripts" then
				error("StarterPlayer only supports StarterPlayerScripts");
			end;
			if not l__RunService__4:IsClient() then
				error("The server cannot load StarterPlayer content");
			end;
			v11 = l__Players__5.LocalPlayer:WaitForChild("PlayerScripts");
			table.remove(v8, 1);
		end;
		local v12 = 0;
		local v13 = false;
		while true do
			if v13 then
				v12 = v12 + 1;
			else
				v13 = true;
			end;
			if not (v12 < #v8) then
				break;
			end;
			v11 = v11:WaitForChild(v8[v12 + 1]);		
		end;
		table.insert(v6, v11);	
	end;
	local function v14(p2)
		local v15 = os.clock();
		local v16, v17 = pcall(require, p2);
		local v18 = v16 and {
			success = true, 
			value = v17
		} or {
			success = false, 
			error = v17
		};
		local v19 = math.floor((os.clock() - v15) * 1000);
		if not v18.success then
			error(p2:GetFullName() .. " failed to preload (" .. tostring(v19) .. "ms): " .. v18.error);
		end;
	end;
	local v20, v21, v22 = ipairs(v6);
	while true do
		v20(v21, v22);
		if not v20 then
			break;
		end;
		if v21:IsA("ModuleScript") then
			v14(v21);
		end;
		local v23, v24, v25 = ipairs(v21:GetDescendants());
		while true do
			v23(v24, v25);
			if not v23 then
				break;
			end;
			v25 = v23;
			if v24:IsA("ModuleScript") then
				v14(v24);
			end;		
		end;	
	end;
end;
function v3._implements(p3, p4)
	local v26, v27, v28 = ipairs((l__Reflect__1.getMetadatas(p3, "flamework:implements")));
	while true do
		v26(v27, v28);
		if not v26 then
			break;
		end;
		v28 = v26;
		if table.find(v27, p4) ~= nil then
			return true;
		end;	
	end;
	return false;
end;
u2 = function(p5)
	local v29 = false;
	if p5.new ~= nil then
		v29 = p5.constructor ~= nil;
	end;
	return v29;
end;
local u6 = {};
function v3.registerExternalClass(p6)
	u6[p6] = true;
end;
local u7 = false;
local u8 = v4;
function v3.ignite(p7)
	if u7 then
		error("Flamework.ignite() should only be called once");
	end;
	u7 = true;
	if p7 then
		for v30, v31 in pairs(p7) do
			u8[v30] = v31;
		end;
	end;
	for v32, v33 in pairs(l__Reflect__1.objToId) do
		if not l__RunService__4:IsServer() or l__Modding__3.getDecorator(v32, nil, "$:flamework@Service") ~= nil then
			if l__RunService__4:IsClient() then
				if l__Modding__3.getDecorator(v32, nil, "$:flamework@Controller") ~= nil and u2(v32) and (not u8.loadOverride or table.find(u8.loadOverride, v32) ~= nil or l__Reflect__1.getOwnMetadata(v32, "flamework:isPatched")) and (not l__Reflect__1.getOwnMetadata(v32, "flamework:isExternal") or u6[v32] ~= nil) then
					l__Modding__3.resolveSingleton(v32);
				end;
			elseif u2(v32) and (not u8.loadOverride or table.find(u8.loadOverride, v32) ~= nil or l__Reflect__1.getOwnMetadata(v32, "flamework:isPatched")) and (not l__Reflect__1.getOwnMetadata(v32, "flamework:isExternal") or u6[v32] ~= nil) then
				l__Modding__3.resolveSingleton(v32);
			end;
		end;
	end;
	local v34 = {};
	if l__RunService__4:IsServer() then
		local v35 = "$:flamework@Service";
	else
		v35 = "$:flamework@Controller";
	end;
	for v36 in pairs(l__Modding__3.getSingletons()) do
		local v37 = l__Modding__3.getDecorator(v36, nil, v35);
		if v37 and (not l__Reflect__1.getOwnMetadata(v36, "flamework:isExternal") or u6[v36] ~= nil) then
			table.insert(v34, { l__Modding__3.resolveSingleton(v36), v37.arguments[1] or {} });
		end;
	end;
	local v38 = {};
	local v39 = {};
	table.sort(v34, function(p8, p9)
		local v40 = p8[2].loadOrder;
		if v40 == nil then
			v40 = 1;
		end;
		local v41 = p9[2].loadOrder;
		if v41 == nil then
			v41 = 1;
		end;
		return v40 < v41;
	end);
	local u9 = {};
	l__Modding__3.onListenerAdded(function(p10)
		u9[p10] = true;
		return u9;
	end, "$:flamework@OnTick");
	local u10 = {};
	l__Modding__3.onListenerAdded(function(p11)
		u10[p11] = true;
		return u10;
	end, "$:flamework@OnPhysics");
	local u11 = {};
	l__Modding__3.onListenerAdded(function(p12)
		u11[p12] = true;
		return u11;
	end, "$:flamework@OnRender");
	l__Modding__3.onListenerRemoved(function(p13)
		u9[p13] = nil;
		return u9[p13] ~= nil;
	end, "$:flamework@OnTick");
	l__Modding__3.onListenerRemoved(function(p14)
		u10[p14] = nil;
		return u10[p14] ~= nil;
	end, "$:flamework@OnPhysics");
	l__Modding__3.onListenerRemoved(function(p15)
		u11[p15] = nil;
		return u11[p15] ~= nil;
	end, "$:flamework@OnRender");
	local v42, v43, v44 = ipairs(v34);
	while true do
		v42(v43, v44);
		if not v42 then
			break;
		end;
		local v45 = v43[1];
		if v3._implements(v45, "$:flamework@OnInit") then
			table.insert(v39, v45);
		end;
		if v3._implements(v45, "$:flamework@OnStart") then
			table.insert(v38, v45);
		end;	
	end;
	local v46, v47, v48 = ipairs(v39);
	while true do
		v46(v47, v48);
		if not v46 then
			break;
		end;
		v48 = v46;
		debug.setmemorycategory(l__Reflect__1.getMetadata(v47, "identifier"));
		local v49 = v47:onInit();
		if v1.Promise.is(v49) then
			v49:await();
		end;
		debug.resetmemorycategory();	
	end;
	v3.isInitialized = true;
	l__RunService__4.Heartbeat:Connect(function(p16)
		for v50 in pairs(u9) do
			task.spawn(function()
				return v50:onTick(p16);
			end);
		end;
	end);
	l__RunService__4.Stepped:Connect(function(p17, p18)
		for v51 in pairs(u10) do
			task.spawn(function()
				return v51:onPhysics(p18, p17);
			end);
		end;
	end);
	if l__RunService__4:IsClient() then
		l__RunService__4.RenderStepped:Connect(function(p19)
			for v52 in pairs(u11) do
				task.spawn(function()
					return v52:onRender(p19);
				end);
			end;
		end);
	end;
	local v53, v54, v55 = ipairs(v38);
	while true do
		v53(v54, v55);
		if not v53 then
			break;
		end;
		v55 = v53;
		task.spawn(function()
			debug.setmemorycategory(l__Reflect__1.getMetadata(v54, "identifier"));
			v54:onStart();
		end);	
	end;
	return v34;
end;
v3.Testing = {
	patchDependency = function(p20, p21)
		if p21 == nil then
			error("Patching failed, no ID");
		end;
		local v56 = l__Reflect__1.idToObj[p21];
		if v56 == nil then
			error("Dependency " .. p21 .. " was not found and cannot be patched.");
		end;
		if l__Modding__3.getSingletons()[v56] ~= nil then
			error(p21 .. " has already been resolved, continuing is unsafe");
		end;
		local v57 = l__Reflect__1.metadata[v56];
		if not v57 then
			error("Dependency " .. p21 .. " has no existing metadata.");
		end;
		l__Reflect__1.defineMetadata(v56, "flamework:isPatched", true);
		l__Reflect__1.metadata[v56] = nil;
		l__Reflect__1.metadata[p20] = v57;
		l__Reflect__1.objToId[p20] = p21;
		l__Reflect__1.idToObj[p21] = p20;
	end
};
u8 = l__Modding__3.createMetaDecorator;
u8 = u8("Class");
return {
	Flamework = v3, 
	Service = u8, 
	Controller = l__Modding__3.createMetaDecorator("Class"), 
	External = l__Modding__3.createDecorator("Class", function(p22)
		l__Reflect__1.defineMetadata(p22.object, "flamework:isExternal", true);
	end)
};
