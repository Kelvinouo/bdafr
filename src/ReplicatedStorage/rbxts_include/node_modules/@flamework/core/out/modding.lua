-- Decompiled with the Synapse X Luau decompiler.

local v1 = _G[script];
local v2 = v1.import(script, v1.getModule(script, "@rbxts", "signal"));
local v3 = {};
local l__Reflect__1 = v1.import(script, script.Parent, "reflect").Reflect;
local u2 = {};
local u3 = {};
local u4 = {};
local u5 = {};
local u6 = v2.new();
local function v4(p1)
	local v5 = {
		eventIds = {}, 
		involvement = {}
	};
	for v6, v7 in ipairs(l__Reflect__1.getMetadatas(p1, "flamework:implements")) do
		for v8, v9 in ipairs(v7) do
			if v5.eventIds[v9] == nil then
				local v10 = u2[v9];
				if not v10 then
					v10 = {};
					u2[v9] = v10;
				end;
				v10[p1] = true;
				v5.eventIds[v9] = true;
				table.insert(v5.involvement, v10);
				local v11 = u3[v9];
				if v11 ~= nil then
					v11:Fire(p1);
				end;
			end;
		end;
	end;
	local v12 = l__Reflect__1.getMetadata(p1, "flamework:decorators");
	if v12 then
		for v13, v14 in ipairs(v12) do
			if v5.eventIds[v14] == nil then
				local v15 = u4[v14];
				if not v15 then
					v15 = {};
					u4[v14] = v15;
				end;
				v15[p1] = true;
				v5.eventIds[v14] = true;
				table.insert(v5.involvement, v15);
				local v16 = u3[v14];
				if v16 ~= nil then
					v16:Fire(p1);
				end;
			end;
		end;
	end;
	u5[p1] = v5;
	u6:Fire(p1);
end;
v3.addListener = v4;
local u7 = {};
local u8 = v2.new();
function v3.removeListener(p2)
	local v17 = u5[p2];
	if not v17 then
		return nil;
	end;
	for v18, v19 in ipairs(v17.involvement) do
		v19[p2] = nil;
	end;
	for v20 in pairs(v17.eventIds) do
		local v21 = u7[v20];
		if v21 ~= nil then
			v21:Fire(p2);
		end;
	end;
	u5[p2] = nil;
	u8:Fire(p2);
end;
function v3.onListenerAdded(p3, p4)
	if p4 == nil then
		for v22 in pairs(u5) do
			task.spawn(p3, v22);
		end;
		return u6:Connect(p3);
	end;
	local v23 = u3[p4];
	if not v23 then
		v23 = v2.new();
		u3[p4] = v23;
	end;
	local v24 = u2[p4] or u4[p4];
	if v24 then
		for v25 in pairs(v24) do
			task.spawn(p3, v25);
		end;
	end;
	return v23:Connect(p3);
end;
function v3.onListenerRemoved(p5, p6)
	if p6 == nil then
		return u8:Connect(p5);
	end;
	local v26 = u7[p6];
	if not v26 then
		v26 = v2.new();
		u7[p6] = v26;
	end;
	return v26:Connect(p5);
end;
local u9 = nil;
function v3.createDecorator(p7, p8)
	local v27 = {};
	function v27.func(p9, p10)
		u9(p9, p10);
		p8(p9, p10);
	end;
	return v27;
end;
function v3.createMetaDecorator(p11)
	return {
		func = function(p12, p13)
			u9(p12, p13);
		end
	};
end;
function v3.getDecorators(p14)
	assert(p14 ~= nil);
	local v28 = l__Reflect__1.decorators[p14];
	if not v28 then
		return {};
	end;
	local v29 = table.create(#v28);
	for v30, v31 in ipairs(v28) do
		local v32 = l__Reflect__1.getOwnMetadata(v31, "flamework:decorators." .. p14);
		assert(v32);
		v29[v30] = {
			object = v31, 
			arguments = v32.arguments
		};
	end;
	return v29;
end;
local u10 = nil;
function v3.getPropertyDecorators(p15, p16)
	local v33 = {};
	assert(p16 ~= nil);
	for v34, v35 in ipairs(l__Reflect__1.getProperties(p15)) do
		local v36 = u10(p15, v35, p16);
		if v36 then
			v33[v35] = v36;
		end;
	end;
	return v33;
end;
u10 = function(p17, p18, p19)
	local v37 = l__Reflect__1.getMetadata(p17, "flamework:decorators." .. tostring(p19), p18);
	if v37 then
		return v37;
	end;
	return nil;
end;
v3.getDecorator = u10;
local u11 = {};
local u12 = {};
local u13 = nil;
local function v38(p20)
	local v39 = u11[p20];
	if v39 ~= nil then
		return v39;
	end;
	if table.find(u12, p20) ~= nil then
		local v40 = table.create(#u12);
		for v41, v42 in ipairs(u12) do
			v40[v41] = tostring(v42);
		end;
		error("Circular dependency detected " .. table.concat(v40, " <=> ") .. " <=> " .. tostring(p20));
	end;
	table.insert(u12, p20);
	local v43 = u13(p20, (l__Reflect__1.getOwnMetadata(p20, "flamework:dependency_resolution")));
	u11[p20] = v43;
	u12[#u12] = nil;
	v4(v43);
	return v43;
end;
v3.resolveSingleton = v38;
function v3.getSingletons()
	return u11;
end;
local u14 = {};
function v3.registerDependency(p21, p22)
	assert(p22 ~= nil);
	if type(p21) == "function" then
		u14[p22] = p21;
		return;
	end;
	u14[p22] = function()
		return p21;
	end;
end;
local u15 = nil;
u13 = function(p23, p24)
	if p24 == nil then
		p24 = {};
	end;
	local v44 = u15(p23, p24);
	v44[2]();
	return v44[1];
end;
v3.createDependency = u13;
local u16 = nil;
local u17 = nil;
u15 = function(p25, p26)
	if p26 == nil then
		p26 = {};
	end;
	local v45 = u16(p25);
	local v46 = {};
	local u18 = v45[2];
	v46[1] = v45[1];
	v46[2] = function()
		local v47 = l__Reflect__1.getMetadata(p25, "flamework:parameters");
		local v48 = {};
		if v47 then
			for v49, v50 in pairs(v47) do
				v48[v49 - 1 + 1] = u17(p25, v50, v49 - 1, p26);
			end;
		end;
		u18(unpack(v48));
	end;
	return v46;
end;
v3.createDeferredDependency = u15;
local u19 = nil;
u17 = function(p27, p28, p29, p30)
	if p30.handle ~= nil then
		local v51 = p30.handle(p28, p29);
		if v51 ~= nil then
			return v51;
		end;
	end;
	local v52 = u14[p28];
	if v52 ~= nil then
		return v52(p27);
	end;
	if string.sub(p28, 1, 2) == "$p" then
		if string.sub(p28, 1, 3) == "$ps" then
			return string.sub(p28, 5);
		end;
		if string.sub(p28, 1, 3) == "$pn" then
			local v53 = tonumber(string.sub(p28, 5));
			if v53 == nil then
				v53 = 0;
			end;
			return v53;
		end;
		if p30.handlePrimitive ~= nil then
			return p30.handlePrimitive(p28, p29);
		end;
		error("Unexpected primitive dependency '" .. p28 .. "' while constructing " .. tostring(p27));
	end;
	local v54 = l__Reflect__1.idToObj[p28];
	if not v54 or not u19(v54) then
		error("Could not find constructor for " .. p28 .. " while constructing " .. tostring(p27));
	end;
	return v38(v54);
end;
function v3.macro(p31, p32)
	if type(p31) == "string" then
		return {
			[p31] = p32
		};
	end;
	local v55 = {};
	for v56, v57 in ipairs(p31) do
		v55[v57[1]] = v57[2];
	end;
	return v55;
end;
u9 = function(p33, p34)
	if p33.isStatic then
		local v58 = "static:" .. p33.property;
	else
		v58 = p33.property;
	end;
	l__Reflect__1.defineMetadata(p33.object, "flamework:decorators." .. p33.id, {
		arguments = p34
	}, v58);
	local v59 = l__Reflect__1.getMetadata(p33.object, "flamework:decorators", v58);
	if not v59 then
		v59 = {};
		l__Reflect__1.defineMetadata(p33.object, "flamework:decorators", v59, v58);
	end;
	table.insert(v59, p33.id);
end;
u19 = function(p35)
	local v60 = false;
	if p35.new ~= nil then
		v60 = p35.constructor ~= nil;
	end;
	return v60;
end;
u16 = function(p36)
	local v61 = setmetatable({}, p36);
	local v62 = {};
	v62[1] = v61;
	v62[2] = function(...)
		local v63 = v61:constructor(unpack({ ... }));
		local v64 = true;
		if v63 ~= nil then
			v64 = v63 == v61;
		end;
		assert(v64, "Deferred constructors are not allowed to return values.");
	end;
	return v62;
end;
return {
	Modding = v3
};
