-- Decompiled with the Synapse X Luau decompiler.

local v1 = _G[script];
local v2 = v1.import(script, script.Parent.Parent, "configuration");
local v3 = v1.import(script, script.Parent.Parent, "internal");
local l__default__4 = v1.import(script, script.Parent, "MiddlewareEvent").default;
local v5 = setmetatable({}, {
	__tostring = function()
		return "ServerAsyncFunction";
	end, 
	__index = l__default__4
});
v5.__index = v5;
function v5.new(...)
	local v6 = setmetatable({}, v5);
	return v6:constructor(...) and v6;
end;
local u1 = l__default__4;
local l__findOrCreateRemote__2 = v3.findOrCreateRemote;
local l__IS_CLIENT__3 = v3.IS_CLIENT;
function v5.constructor(p1, p2, p3)
	if p3 == nil then
		p3 = {};
	end;
	u1.constructor(p1, p3);
	p1.timeout = 10;
	p1.listeners = {};
	p1.instance = l__findOrCreateRemote__2("AsyncRemoteFunction", p2, function(p4)
		p1.defaultHook = p4.OnServerEvent:Connect(v5.DefaultEventHook);
	end);
	assert(not l__IS_CLIENT__3, "Cannot create a NetServerAsyncFunction on the client!");
end;
function v5.GetInstance(p5)
	return p5.instance;
end;
function v5.SetCallTimeout(p6, p7)
	assert(p7 > 0, "timeout must be a positive number");
	p6.timeout = p7;
	return p6;
end;
function v5.GetCallTimeout(p8)
	return p8.timeout;
end;
local function u4(p9)
	if #p9 < 2 then
		return false;
	end;
	local v7 = false;
	if type(p9[1]) == "string" then
		v7 = type(p9[2]) == "table";
	end;
	return v7;
end;
function v5.SetCallback(p10, p11)
	local l__defaultHook__8 = p10.defaultHook;
	if l__defaultHook__8 ~= nil then
		l__defaultHook__8:Disconnect();
	end;
	if p10.connector then
		p10.connector:Disconnect();
		p10.connector = nil;
	end;
	p10.connector = p10.instance.OnServerEvent:Connect(v1.async(function(p12, ...)
		local v9 = { ... };
		if not u4(v9) then
			warn("[rbx-net-async] Recieved message without eventId");
			return;
		end;
		local v10 = v9[1];
		local v11 = p10:_processMiddleware(p11);
		if v11 ~= nil then
			v11 = v11(p12, unpack(v9[2]));
		end;
		if v1.Promise.is(v11) then
			v11:andThen(function(p13)
				p10.instance:FireClient(p12, v10, p13);
			end):catch(function(p14)
				warn("[rbx-net] Failed to send response to client: " .. p14);
			end);
			return;
		end;
		if v11 == nil then
			warn("[rbx-net-async] " .. p10.instance.Name .. " returned undefined");
		end;
		p10.instance:FireClient(p12, v10, v11);
	end));
end;
local l__HttpService__5 = game:GetService("HttpService");
local l__DebugLog__6 = v2.DebugLog;
local l__RunService__7 = game:GetService("RunService");
local l__DebugWarn__8 = v2.DebugWarn;
v5.CallPlayerAsync = v1.async(function(p15, p16, ...)
	local v12 = l__HttpService__5:GenerateGUID(false);
	local v13 = {};
	for v14, v15 in pairs({ ... }) do
		v13[v14] = v15;
	end;
	p15.instance:FireClient(p16, v12, v13);
	return v1.Promise.new(function(p17, p18)
		local v16 = tick();
		l__DebugLog__6("Connected CallPlayerAsync EventId", v12);
		local u9 = nil;
		u9 = p15.instance.OnServerEvent:Connect(function(p19, ...)
			local v17 = { ... };
			local v18 = v17[1];
			local v19 = v17[2];
			if type(v18) == "string" and v19 ~= nil and p16 == p16 and v18 == v12 then
				l__DebugLog__6("Disconnected CallPlayerAsync EventId", v18);
				u9:Disconnect();
				p17(v19);
			end;
		end);
		p15.listeners[v12] = {
			connection = u9, 
			timeout = p15.timeout
		};
		while true do
			l__RunService__7.Stepped:Wait();
			if not u9.Connected then
				break;
			end;
			if not (tick() < v16 + p15.timeout) then
				break;
			end;		
		end;
		p15.listeners[v12] = nil;
		if v16 <= tick() and u9.Connected then
			l__DebugWarn__8("(timeout) Disconnected CallPlayerAsync EventId", v12);
			u9:Disconnect();
			p18("Request to client timed out");
		end;
	end);
end);
function v5.DefaultEventHook(p20, ...)
	({})[1] = ...;
end;
u1 = v5;
return {
	default = u1
};
