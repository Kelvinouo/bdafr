-- Decompiled with the Synapse X Luau decompiler.

local v1 = _G[script];
local v2 = v1.import(script, script.Parent.Parent, "configuration");
local v3 = v1.import(script, script.Parent.Parent, "internal");
local l__default__4 = v1.import(script, script.Parent, "MiddlewareEvent").default;
local v5 = setmetatable({}, {
	__tostring = function()
		return "ServerAsyncFunction";
	end, 
	__index = l__default__4
});
v5.__index = v5;
function v5.new(...)
	local v6 = setmetatable({}, v5);
	return v6:constructor(...) and v6;
end;
local l__findOrCreateRemote__1 = v3.findOrCreateRemote;
local l__IS_CLIENT__2 = v3.IS_CLIENT;
function v5.constructor(p1, p2, p3)
	if p3 == nil then
		p3 = {};
	end;
	l__default__4.constructor(p1, p3);
	p1.timeout = 10;
	p1.listeners = {};
	p1.instance = l__findOrCreateRemote__1("AsyncRemoteFunction", p2, function(p4)
		p1.defaultHook = p4.OnServerEvent:Connect(v5.DefaultEventHook);
	end);
	assert(not l__IS_CLIENT__2, "Cannot create a NetServerAsyncFunction on the client!");
end;
function v5.GetInstance(p5)
	return p5.instance;
end;
function v5.SetCallTimeout(p6, p7)
	assert(p7 > 0, "timeout must be a positive number");
	p6.timeout = p7;
	return p6;
end;
function v5.GetCallTimeout(p8)
	return p8.timeout;
end;
function v5.SetCallback(p9, p10)
	local l__defaultHook__7 = p9.defaultHook;
	if l__defaultHook__7 ~= nil then
		l__defaultHook__7:Disconnect();
	end;
	if p9.connector then
		p9.connector:Disconnect();
		p9.connector = nil;
	end;
	p9.connector = p9.instance.OnServerEvent:Connect(v1.async(function(p11, ...)
		local v8 = { ... };
		if #v8 < 2 then
			local v9 = false;
		else
			v9 = false;
			if type(v8[1]) == "string" then
				v9 = type(v8[2]) == "table";
			end;
		end;
		if not v9 then
			warn("[rbx-net-async] Recieved message without eventId");
			return;
		end;
		local v10 = v8[1];
		local v11 = p9:_processMiddleware(p10);
		if v11 ~= nil then
			v11 = v11(p11, unpack(v8[2]));
		end;
		if v1.Promise.is(v11) then
			v11:andThen(function(p12)
				p9.instance:FireClient(p11, v10, p12);
			end):catch(function(p13)
				warn("[rbx-net] Failed to send response to client: " .. p13);
			end);
			return;
		end;
		if v11 == nil then
			warn("[rbx-net-async] " .. p9.instance.Name .. " returned undefined");
		end;
		p9.instance:FireClient(p11, v10, v11);
	end));
end;
local l__HttpService__3 = game:GetService("HttpService");
local l__DebugLog__4 = v2.DebugLog;
local l__RunService__5 = game:GetService("RunService");
local l__DebugWarn__6 = v2.DebugWarn;
v5.CallPlayerAsync = v1.async(function(p14, p15, ...)
	local v12 = l__HttpService__3:GenerateGUID(false);
	local v13 = {};
	for v14, v15 in pairs({ ... }) do
		v13[v14] = v15;
	end;
	p14.instance:FireClient(p15, v12, v13);
	return v1.Promise.new(function(p16, p17)
		local v16 = tick();
		l__DebugLog__4("Connected CallPlayerAsync EventId", v12);
		local u7 = nil;
		u7 = p14.instance.OnServerEvent:Connect(function(p18, ...)
			local v17 = { ... };
			local v18 = v17[1];
			local v19 = v17[2];
			if type(v18) == "string" and v19 ~= nil and p15 == p15 and v18 == v12 then
				l__DebugLog__4("Disconnected CallPlayerAsync EventId", v18);
				u7:Disconnect();
				p16(v19);
			end;
		end);
		p14.listeners[v12] = {
			connection = u7, 
			timeout = p14.timeout
		};
		while true do
			l__RunService__5.Stepped:Wait();
			if not u7.Connected then
				break;
			end;
			if not (tick() < v16 + p14.timeout) then
				break;
			end;		
		end;
		p14.listeners[v12] = nil;
		if v16 <= tick() and u7.Connected then
			l__DebugWarn__6("(timeout) Disconnected CallPlayerAsync EventId", v12);
			u7:Disconnect();
			p17("Request to client timed out");
		end;
	end);
end);
function v5.DefaultEventHook(p19, ...)
	({})[1] = ...;
end;
return {
	default = v5
};
