-- Decompiled with the Synapse X Luau decompiler.

local l__HttpService__1 = game:GetService("HttpService");
local l__RunService__2 = game:GetService("RunService");
local v3 = setmetatable({}, {
	__tostring = function()
		return "NetMiddlewareEvent";
	end
});
v3.__index = v3;
function v3.new(...)
	local v4 = setmetatable({}, v3);
	return v4:constructor(...) and v4;
end;
function v3.constructor(p1, p2)
	p1.netInstance = p2;
end;
function v3.GetInstance(p3)
	return p3.netInstance:GetInstance();
end;
local v5 = {};
local l__Parent__6 = script.Parent;
local l___NetManaged__7 = l__Parent__6:FindFirstChild("_NetManaged");
if l___NetManaged__7 then
	local v8 = l___NetManaged__7;
else
	local v9 = Instance.new("Folder", l__Parent__6);
	v9.Name = "_NetManaged";
	v8 = v9;
end;
local u1 = {};
local u2 = _G[script];
local u3 = nil;
local l__CollectionService__4 = game:GetService("CollectionService");
u3 = function(p4, p5)
	if p4 == "AsyncRemoteFunction" then
		for v10, v11 in ipairs((l__CollectionService__4:GetTagged("NetManagedAsyncFunction"))) do
			if v11.Name == p5 == true then
				return v11;
			end;
		end;
		return nil;
	end;
	if p4 == "RemoteEvent" then
		for v12, v13 in ipairs((l__CollectionService__4:GetTagged("NetManagedEvent"))) do
			if v13.Name == p5 == true then
				return v13;
			end;
		end;
		return nil;
	end;
	if p4 ~= "RemoteFunction" then
		error("Invalid Remote Access");
		return;
	end;
	for v14, v15 in ipairs((l__CollectionService__4:GetTagged("NetManagedLegacyFunction"))) do
		if v15.Name == p5 == true then
			return v15;
		end;
	end;
	return nil;
end;
local u5 = not l__RunService__2:IsRunning() or l__RunService__2:IsServer();
if u5 then
	game:GetService("RunService").Stepped:Connect(function(p6, p7)
		for v16, v17 in ipairs(v5) do
			v17();
		end;
	end);
end;
return {
	getGlobalRemote = function(p8)
		return ":\\" .. p8;
	end, 
	isLuaTable = function(p9)
		return type(p9) == "table";
	end, 
	findOrCreateFolder = function(p10, p11)
		local v18 = p10:FindFirstChild(p11);
		if v18 then
			return v18;
		end;
		local v19 = Instance.new("Folder", p10);
		v19.Name = p11;
		return v19;
	end, 
	errorft = function(p12, p13)
		p12 = string.gsub(p12, "{([%w_][%w%d_]*)}", function(p14)
			local v20 = p13[p14];
			if v20 == nil then
				v20 = p14;
			end;
			return v20;
		end);
		error(p12, 2);
	end, 
	warnOnce = function(p15)
		local v21 = debug.traceback();
		if u1[v21] ~= nil then
			return nil;
		end;
		u1[v21] = true;
		warn("[rbx-net] " .. p15);
	end, 
	format = function(p16, p17)
		p16 = string.gsub(p16, "{([%w_][%w%d_]*)}", function(p18)
			local v22 = p17[p18];
			if v22 == nil then
				v22 = p18;
			end;
			return v22;
		end);
		return p16;
	end, 
	waitForRemote = function(p19, p20, p21)
		return u2.Promise.defer(function(p22, p23)
			local v23 = nil;
			local v24 = 0;
			while true do
				v24 = v24 + l__RunService__2.Heartbeat:Wait();
				v23 = u3(p19, p20);
				if not (v24 < p21) then
					break;
				end;
				if v23 then
					break;
				end;			
			end;
			if v23 then
				p22(v23);
				return;
			end;
			p23("Timed out while waiting for " .. p19 .. " '" .. p20 .. "' after " .. tostring(p21) .. " seconds.");
		end);
	end, 
	findRemote = u3, 
	getRemoteOrThrow = function(p24, p25)
		local v25 = u3(p24, p25);
		if v25 then
			return v25;
		end;
		error("Could not find Remote of type " .. p24 .. " called \"" .. p25 .. "\"");
	end, 
	findOrCreateRemote = function(p26, p27, p28)
		local v26 = u3(p26, p27);
		if v26 then
			local v27 = nil;
			if l__CollectionService__4:HasTag(v26, "NetDefinitionManaged") then
				local v28 = debug.traceback();
				if u1[v28] ~= nil then
					return v26;
				else
					u1[v28] = true;
					warn("[rbx-net] " .. "Fetching " .. p26 .. " '" .. p27 .. "', which is a DefinitionsManaged instance from a non-definitions context. This is considered unsafe.");
					v27 = v26;
					return v27;
				end;
			else
				v27 = v26;
				return v27;
			end;
		end;
		if not u5 then
			error("Creation of Events or Functions must be done on server!");
		end;
		local v29 = nil;
		if p26 == "RemoteEvent" then
			v29 = Instance.new("RemoteEvent");
			l__CollectionService__4:AddTag(v29, "NetManagedEvent");
		elseif p26 == "AsyncRemoteFunction" then
			v29 = Instance.new("RemoteEvent");
			l__CollectionService__4:AddTag(v29, "NetManagedAsyncFunction");
		elseif p26 == "RemoteFunction" then
			v29 = Instance.new("RemoteFunction");
			l__CollectionService__4:AddTag(v29, "NetManagedLegacyFunction");
		else
			error("Invalid Remote Type: " .. p26);
		end;
		v29.Name = p27;
		v29.Parent = v8;
		if p28 ~= nil then
			p28(v29);
		end;
		return v29;
	end, 
	checkArguments = function(p29, p30)
		if p30 == nil then
			warn("[net-types] Argument length is zero");
			return false;
		end;
		local v30 = 0;
		local v31 = false;
		while true do
			if v31 then
				v30 = v30 + 1;
			else
				v31 = true;
			end;
			if not (v30 < #p29) then
				break;
			end;
			if not p29[v30 + 1](p30[v30 + 1]) then
				warn("[net-types] Argument at index " .. tostring(v30) .. " was invalid type.");
				return false;
			end;		
		end;
		return true;
	end, 
	IS_SERVER = u5, 
	IS_CLIENT = l__RunService__2:IsRunning() and l__RunService__2:IsClient(), 
	IS_RUNNING = l__RunService__2:IsRunning(), 
	MAX_CLIENT_WAITFORCHILD_TIMEOUT = 10, 
	NetMiddlewareEvent = v3, 
	ServerTickFunctions = v5
};
