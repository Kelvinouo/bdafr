-- Decompiled with the Synapse X Luau decompiler.

local u1 = typeof or type;
local v1 = {
	any = function(p1)
		if p1 ~= nil then
			return true;
		end;
		return false, "any expected, got nil";
	end
};
local u2 = "boolean";
function v1.boolean(p2)
	local v2 = u1(p2);
	if v2 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v2);
end;
u2 = "thread";
function v1.thread(p3)
	local v3 = u1(p3);
	if v3 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v3);
end;
u2 = "function";
function v1.callback(p4)
	local v4 = u1(p4);
	if v4 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v4);
end;
v1["function"] = v1.callback;
u2 = "nil";
function v1.none(p5)
	local v5 = u1(p5);
	if v5 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v5);
end;
v1.nil = v1.none;
u2 = "string";
function v1.string(p6)
	local v6 = u1(p6);
	if v6 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v6);
end;
u2 = "table";
function v1.table(p7)
	local v7 = u1(p7);
	if v7 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v7);
end;
u2 = "userdata";
function v1.userdata(p8)
	local v8 = u1(p8);
	if v8 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v8);
end;
function v1.number(p9)
	local v9 = u1(p9);
	if v9 ~= "number" then
		return false, string.format("number expected, got %s", v9);
	end;
	if p9 == p9 then
		return true;
	end;
	return false, "unexpected NaN value";
end;
function v1.nan(p10)
	if p10 ~= p10 then
		return true;
	end;
	return false, "unexpected non-NaN value";
end;
u2 = "Axes";
function v1.Axes(p11)
	local v10 = u1(p11);
	if v10 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v10);
end;
u2 = "BrickColor";
function v1.BrickColor(p12)
	local v11 = u1(p12);
	if v11 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v11);
end;
u2 = "CFrame";
function v1.CFrame(p13)
	local v12 = u1(p13);
	if v12 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v12);
end;
u2 = "Color3";
function v1.Color3(p14)
	local v13 = u1(p14);
	if v13 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v13);
end;
u2 = "ColorSequence";
function v1.ColorSequence(p15)
	local v14 = u1(p15);
	if v14 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v14);
end;
u2 = "ColorSequenceKeypoint";
function v1.ColorSequenceKeypoint(p16)
	local v15 = u1(p16);
	if v15 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v15);
end;
u2 = "DockWidgetPluginGuiInfo";
function v1.DockWidgetPluginGuiInfo(p17)
	local v16 = u1(p17);
	if v16 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v16);
end;
u2 = "Faces";
function v1.Faces(p18)
	local v17 = u1(p18);
	if v17 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v17);
end;
u2 = "Instance";
function v1.Instance(p19)
	local v18 = u1(p19);
	if v18 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v18);
end;
u2 = "NumberRange";
function v1.NumberRange(p20)
	local v19 = u1(p20);
	if v19 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v19);
end;
u2 = "NumberSequence";
function v1.NumberSequence(p21)
	local v20 = u1(p21);
	if v20 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v20);
end;
u2 = "NumberSequenceKeypoint";
function v1.NumberSequenceKeypoint(p22)
	local v21 = u1(p22);
	if v21 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v21);
end;
u2 = "PathWaypoint";
function v1.PathWaypoint(p23)
	local v22 = u1(p23);
	if v22 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v22);
end;
u2 = "PhysicalProperties";
function v1.PhysicalProperties(p24)
	local v23 = u1(p24);
	if v23 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v23);
end;
u2 = "Random";
function v1.Random(p25)
	local v24 = u1(p25);
	if v24 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v24);
end;
u2 = "Ray";
function v1.Ray(p26)
	local v25 = u1(p26);
	if v25 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v25);
end;
u2 = "Rect";
function v1.Rect(p27)
	local v26 = u1(p27);
	if v26 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v26);
end;
u2 = "Region3";
function v1.Region3(p28)
	local v27 = u1(p28);
	if v27 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v27);
end;
u2 = "Region3int16";
function v1.Region3int16(p29)
	local v28 = u1(p29);
	if v28 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v28);
end;
u2 = "TweenInfo";
function v1.TweenInfo(p30)
	local v29 = u1(p30);
	if v29 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v29);
end;
u2 = "UDim";
function v1.UDim(p31)
	local v30 = u1(p31);
	if v30 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v30);
end;
u2 = "UDim2";
function v1.UDim2(p32)
	local v31 = u1(p32);
	if v31 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v31);
end;
u2 = "Vector2";
function v1.Vector2(p33)
	local v32 = u1(p33);
	if v32 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v32);
end;
u2 = "Vector3";
function v1.Vector3(p34)
	local v33 = u1(p34);
	if v33 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v33);
end;
u2 = "Vector3int16";
function v1.Vector3int16(p35)
	local v34 = u1(p35);
	if v34 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v34);
end;
u2 = "Enum";
function v1.Enum(p36)
	local v35 = u1(p36);
	if v35 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v35);
end;
u2 = "EnumItem";
function v1.EnumItem(p37)
	local v36 = u1(p37);
	if v36 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v36);
end;
u2 = "RBXScriptSignal";
function v1.RBXScriptSignal(p38)
	local v37 = u1(p38);
	if v37 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v37);
end;
u2 = "RBXScriptConnection";
function v1.RBXScriptConnection(p39)
	local v38 = u1(p39);
	if v38 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v38);
end;
function v1.literal(...)
	local v39 = select("#", ...);
	if v39 == 1 then
		local u3 = ...;
		return function(p40)
			if p40 == u3 then
				return true;
			end;
			return false, string.format("expected %s, got %s", tostring(u3), tostring(p40));
		end;
	end;
	local v40 = {};
	for v41 = 1, v39 do
		v40[v41] = v1.literal((select(v41, ...)));
	end;
	return v1.union(table.unpack(v40, 1, v39));
end;
v1.exactly = v1.literal;
function v1.keyOf(p41)
	local v42 = {};
	local v43 = 0;
	for v44 in pairs(p41) do
		v43 = v43 + 1;
		v42[v43] = v44;
	end;
	return v1.literal(table.unpack(v42, 1, v43));
end;
function v1.valueOf(p42)
	local v45 = {};
	local v46 = 0;
	for v47, v48 in pairs(p42) do
		v46 = v46 + 1;
		v45[v46] = v48;
	end;
	return v1.literal(table.unpack(v45, 1, v46));
end;
function v1.integer(p43)
	local v49, v50 = v1.number(p43);
	if not v49 then
		return false, v50 and "";
	end;
	if p43 % 1 == 0 then
		return true;
	end;
	return false, string.format("integer expected, got %s", p43);
end;
function v1.numberMin(p44)
	return function(p45)
		local v51, v52 = v1.number(p45);
		if not v51 then
			return false, v52 and "";
		end;
		if p44 <= p45 then
			return true;
		end;
		return false, string.format("number >= %s expected, got %s", p44, p45);
	end;
end;
function v1.numberMax(p46)
	return function(p47)
		local v53, v54 = v1.number(p47);
		if not v53 then
			return false, v54;
		end;
		if p47 <= p46 then
			return true;
		end;
		return false, string.format("number <= %s expected, got %s", p46, p47);
	end;
end;
function v1.numberMinExclusive(p48)
	return function(p49)
		local v55, v56 = v1.number(p49);
		if not v55 then
			return false, v56 and "";
		end;
		if p48 < p49 then
			return true;
		end;
		return false, string.format("number > %s expected, got %s", p48, p49);
	end;
end;
function v1.numberMaxExclusive(p50)
	return function(p51)
		local v57, v58 = v1.number(p51);
		if not v57 then
			return false, v58 and "";
		end;
		if p51 < p50 then
			return true;
		end;
		return false, string.format("number < %s expected, got %s", p50, p51);
	end;
end;
u2 = 0;
v1.numberPositive = v1.numberMinExclusive(u2);
u2 = 0;
v1.numberNegative = v1.numberMaxExclusive(u2);
function v1.numberConstrained(p52, p53)
	assert(v1.number(p52) and v1.number(p53));
	local u4 = v1.numberMin(p52);
	local u5 = v1.numberMax(p53);
	return function(p54)
		local v59, v60 = u4(p54);
		if not v59 then
			return false, v60 and "";
		end;
		local v61, v62 = u5(p54);
		if v61 then
			return true;
		end;
		return false, v62 and "";
	end;
end;
function v1.numberConstrainedExclusive(p55, p56)
	assert(v1.number(p55) and v1.number(p56));
	local u6 = v1.numberMinExclusive(p55);
	local u7 = v1.numberMaxExclusive(p56);
	return function(p57)
		local v63, v64 = u6(p57);
		if not v63 then
			return false, v64 and "";
		end;
		local v65, v66 = u7(p57);
		if v65 then
			return true;
		end;
		return false, v66 and "";
	end;
end;
function v1.match(p58)
	assert(v1.string(p58));
	return function(p59)
		local v67, v68 = v1.string(p59);
		if not v67 then
			return false, v68;
		end;
		if string.match(p59, p58) ~= nil then
			return true;
		end;
		return false, string.format("%q failed to match pattern %q", p59, p58);
	end;
end;
function v1.optional(p60)
	assert(v1.callback(p60));
	return function(p61)
		if p61 == nil then
			return true;
		end;
		local v69, v70 = p60(p61);
		if v69 then
			return true;
		end;
		return false, string.format("(optional) %s", v70 and "");
	end;
end;
function v1.tuple(...)
	local u8 = { ... };
	return function(...)
		local v71 = { ... };
		local v72, v73, v74 = ipairs(u8);
		while true do
			v72(v73, v74);
			if not v72 then
				break;
			end;
			v74 = v72;
			local v75, v76 = v73(v71[v72]);
			if v75 == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", v72, v76 and "");
			end;		
		end;
		return true;
	end;
end;
function v1.keys(p62)
	assert(v1.callback(p62));
	return function(p63)
		local v77, v78 = v1.table(p63);
		if v77 == false then
			return false, v78 and "";
		end;
		for v79 in pairs(p63) do
			local v80, v81 = p62(v79);
			if v80 == false then
				return false, string.format("bad key %s:\n\t%s", tostring(v79), v81 and "");
			end;
		end;
		return true;
	end;
end;
function v1.values(p64)
	assert(v1.callback(p64));
	return function(p65)
		local v82, v83 = v1.table(p65);
		if v82 == false then
			return false, v83 and "";
		end;
		for v84, v85 in pairs(p65) do
			local v86, v87 = p64(v85);
			if v86 == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(v84), v87 and "");
			end;
		end;
		return true;
	end;
end;
function v1.map(p66, p67)
	assert(v1.callback(p66), v1.callback(p67));
	local u9 = v1.keys(p66);
	local u10 = v1.values(p67);
	return function(p68)
		local v88, v89 = u9(p68);
		if not v88 then
			return false, v89 and "";
		end;
		local v90, v91 = u10(p68);
		if v90 then
			return true;
		end;
		return false, v91 and "";
	end;
end;
function v1.set(p69)
	return v1.map(p69, v1.literal(true));
end;
u2 = v1.integer;
local u11 = v1.keys(u2);
u2 = function(p70)
	assert(v1.callback(p70));
	local u12 = v1.values(p70);
	return function(p71)
		local v92, v93 = u11(p71);
		if v92 == false then
			return false, string.format("[array] %s", v93 and "");
		end;
		local v94 = 0;
		local v95, v96, v97 = ipairs(p71);
		while true do
			v95(v96, v97);
			if not v95 then
				break;
			end;
			v97 = v95;
			v94 = v94 + 1;		
		end;
		for v98 in pairs(p71) do
			if v98 < 1 then
				return false, string.format("[array] key %s must be sequential", tostring(v98));
			end;
			if v94 < v98 then
				return false, string.format("[array] key %s must be sequential", tostring(v98));
			end;
		end;
		local v99, v100 = u12(p71);
		if v99 then
			return true;
		end;
		return false, string.format("[array] %s", v100 and "");
	end;
end;
v1.array = u2;
u2 = function(...)
	local v101 = { ... };
	assert(v1.array(v1.callback)(v101));
	return function(p72)
		local v102, v103 = u11(p72);
		if v102 == false then
			return false, string.format("[strictArray] %s", v103 and "");
		end;
		if #v101 < #p72 then
			return false, string.format("[strictArray] Array size exceeds limit of %d", #v101);
		end;
		for v104, v105 in pairs(v101) do
			local v106, v107 = v105(p72[v104]);
			if not v106 then
				return false, string.format("[strictArray] Array index #%d - %s", v104, v107);
			end;
		end;
		return true;
	end;
end;
v1.strictArray = u2;
u11 = v1.array;
u2 = v1.callback;
u11 = u11(u2);
u2 = function(...)
	local v108 = { ... };
	assert(u11(v108));
	return function(p73)
		local v109, v110, v111 = ipairs(v108);
		while true do
			v109(v110, v111);
			if not v109 then
				break;
			end;
			v111 = v109;
			if v110(p73) then
				return true;
			end;		
		end;
		return false, "bad type for union";
	end;
end;
v1.union = u2;
u2 = v1.union;
v1.some = u2;
u2 = function(...)
	local v112 = { ... };
	assert(u11(v112));
	return function(p74)
		local v113, v114, v115 = ipairs(v112);
		while true do
			v113(v114, v115);
			if not v113 then
				break;
			end;
			v115 = v113;
			local v116, v117 = v114(p74);
			if not v116 then
				return false, v117 and "";
			end;		
		end;
		return true;
	end;
end;
v1.intersection = u2;
u2 = v1.intersection;
v1.every = u2;
u11 = v1.map;
u2 = v1.any;
u11 = u11(u2, v1.callback);
u2 = function(p75)
	assert(u11(p75));
	return function(p76)
		local v118, v119 = v1.table(p76);
		if v118 == false then
			return false, v119 and "";
		end;
		for v120, v121 in pairs(p75) do
			local v122, v123 = v121(p76[v120]);
			if v122 == false then
				return false, string.format("[interface] bad value for %s:\n\t%s", tostring(v120), v123 and "");
			end;
		end;
		return true;
	end;
end;
v1.interface = u2;
u2 = function(p77)
	assert(u11(p77));
	return function(p78)
		local v124, v125 = v1.table(p78);
		if v124 == false then
			return false, v125 and "";
		end;
		for v126, v127 in pairs(p77) do
			local v128, v129 = v127(p78[v126]);
			if v128 == false then
				return false, string.format("[interface] bad value for %s:\n\t%s", tostring(v126), v129 and "");
			end;
		end;
		for v130 in pairs(p78) do
			if not p77[v130] then
				return false, string.format("[interface] unexpected field %q", tostring(v130));
			end;
		end;
		return true;
	end;
end;
v1.strictInterface = u2;
u11 = function(p79, p80)
	assert(v1.string(p79));
	local v131 = nil;
	if p80 ~= nil then
		v131 = v1.children(p80);
	end;
	return function(p81)
		local v132, v133 = v1.Instance(p81);
		if not v132 then
			return false, v133 and "";
		end;
		if p81.ClassName ~= p79 then
			return false, string.format("%s expected, got %s", p79, p81.ClassName);
		end;
		if v131 then
			local v134, v135 = v131(p81);
			if not v134 then
				return false, v135;
			end;
		end;
		return true;
	end;
end;
v1.instanceOf = u11;
u11 = v1.instanceOf;
v1.instance = u11;
u11 = function(p82, p83)
	assert(v1.string(p82));
	local v136 = nil;
	if p83 ~= nil then
		v136 = v1.children(p83);
	end;
	return function(p84)
		local v137, v138 = v1.Instance(p84);
		if not v137 then
			return false, v138 and "";
		end;
		if not p84:IsA(p82) then
			return false, string.format("%s expected, got %s", p82, p84.ClassName);
		end;
		if v136 then
			local v139, v140 = v136(p84);
			if not v139 then
				return false, v140;
			end;
		end;
		return true;
	end;
end;
v1.instanceIsA = u11;
u11 = function(p85)
	assert(v1.Enum(p85));
	return function(p86)
		local v141, v142 = v1.EnumItem(p86);
		if not v141 then
			return false, v142;
		end;
		if p86.EnumType == p85 then
			return true;
		end;
		return false, string.format("enum of %s expected, got enum of %s", tostring(p85), tostring(p86.EnumType));
	end;
end;
v1.enum = u11;
u11 = v1.tuple;
u2 = v1.callback;
u11 = u11(u2, v1.callback);
u2 = function(p87, p88)
	assert(u11(p87, p88));
	return function(...)
		assert(p88(...));
		return p87(...);
	end;
end;
v1.wrap = u2;
u11 = function(p89)
	return function(...)
		assert(p89(...));
	end;
end;
v1.strict = u11;
u11 = v1.map;
u2 = v1.string;
u11 = u11(u2, v1.callback);
u2 = function(p90)
	assert(u11(p90));
	return function(p91)
		local v143, v144 = v1.Instance(p91);
		if not v143 then
			return false, v144 and "";
		end;
		local v145 = {};
		local v146, v147, v148 = ipairs(p91:GetChildren());
		while true do
			v146(v147, v148);
			if not v146 then
				break;
			end;
			v148 = v146;
			local l__Name__149 = v147.Name;
			if p90[l__Name__149] then
				if v145[l__Name__149] then
					return false, string.format("Cannot process multiple children with the same name %q", l__Name__149);
				end;
				v145[l__Name__149] = v147;
			end;		
		end;
		for v150, v151 in pairs(p90) do
			local v152, v153 = v151(v145[v150]);
			if not v152 then
				return false, string.format("[%s.%s] %s", p91:GetFullName(), v150, v153 and "");
			end;
		end;
		return true;
	end;
end;
v1.children = u2;
return v1;
