
-- Decompiled with the Synapse X Luau decompiler.

local u1 = typeof or type;
local function v1(p1)
	return function(p2)
		local v2 = u1(p2);
		if v2 == p1 then
			return true;
		end;
		return false, string.format("%s expected, got %s", p1, v2);
	end;
end;
local v3 = {
	any = function(p3)
		if p3 ~= nil then
			return true;
		end;
		return false, "any expected, got nil";
	end, 
	boolean = v1("boolean"), 
	thread = v1("thread"), 
	callback = v1("function")
};
v3["function"] = v3.callback;
v3.none = v1("nil");
v3.nil = v3.none;
v3.string = v1("string");
v3.table = v1("table");
v3.userdata = v1("userdata");
function v3.number(p4)
	local v4 = u1(p4);
	if v4 ~= "number" then
		return false, string.format("number expected, got %s", v4);
	end;
	if p4 == p4 then
		return true;
	end;
	return false, "unexpected NaN value";
end;
function v3.nan(p5)
	if p5 ~= p5 then
		return true;
	end;
	return false, "unexpected non-NaN value";
end;
v3.Axes = v1("Axes");
v3.BrickColor = v1("BrickColor");
v3.CFrame = v1("CFrame");
v3.Color3 = v1("Color3");
v3.ColorSequence = v1("ColorSequence");
v3.ColorSequenceKeypoint = v1("ColorSequenceKeypoint");
v3.DockWidgetPluginGuiInfo = v1("DockWidgetPluginGuiInfo");
v3.Faces = v1("Faces");
v3.Instance = v1("Instance");
v3.NumberRange = v1("NumberRange");
v3.NumberSequence = v1("NumberSequence");
v3.NumberSequenceKeypoint = v1("NumberSequenceKeypoint");
v3.PathWaypoint = v1("PathWaypoint");
v3.PhysicalProperties = v1("PhysicalProperties");
v3.Random = v1("Random");
v3.Ray = v1("Ray");
v3.Rect = v1("Rect");
v3.Region3 = v1("Region3");
v3.Region3int16 = v1("Region3int16");
v3.TweenInfo = v1("TweenInfo");
v3.UDim = v1("UDim");
v3.UDim2 = v1("UDim2");
v3.Vector2 = v1("Vector2");
v3.Vector3 = v1("Vector3");
v3.Vector3int16 = v1("Vector3int16");
v3.Enum = v1("Enum");
v3.EnumItem = v1("EnumItem");
v3.RBXScriptSignal = v1("RBXScriptSignal");
v3.RBXScriptConnection = v1("RBXScriptConnection");
function v3.literal(...)
	local v5 = select("#", ...);
	if v5 == 1 then
		local u2 = ...;
		return function(p6)
			if p6 == u2 then
				return true;
			end;
			return false, string.format("expected %s, got %s", tostring(u2), tostring(p6));
		end;
	end;
	local v6 = {};
	for v7 = 1, v5 do
		v6[v7] = v3.literal((select(v7, ...)));
	end;
	return v3.union(table.unpack(v6, 1, v5));
end;
v3.exactly = v3.literal;
function v3.keyOf(p7)
	local v8 = {};
	local v9 = 0;
	for v10, v11 in pairs(p7) do
		v9 = v9 + 1;
		v8[v9] = v10;
	end;
	return v3.literal(table.unpack(v8, 1, v9));
end;
function v3.valueOf(p8)
	local v12 = {};
	local v13 = 0;
	for v14, v15 in pairs(p8) do
		v13 = v13 + 1;
		v12[v13] = v15;
	end;
	return v3.literal(table.unpack(v12, 1, v13));
end;
function v3.integer(p9)
	local v16, v17 = v3.number(p9);
	if not v16 then
		return false, v17 and "";
	end;
	if p9 % 1 == 0 then
		return true;
	end;
	return false, string.format("integer expected, got %s", p9);
end;
function v3.numberMin(p10)
	return function(p11)
		local v18, v19 = v3.number(p11);
		if not v18 then
			return false, v19 and "";
		end;
		if p10 <= p11 then
			return true;
		end;
		return false, string.format("number >= %s expected, got %s", p10, p11);
	end;
end;
function v3.numberMax(p12)
	return function(p13)
		local v20, v21 = v3.number(p13);
		if not v20 then
			return false, v21;
		end;
		if p13 <= p12 then
			return true;
		end;
		return false, string.format("number <= %s expected, got %s", p12, p13);
	end;
end;
function v3.numberMinExclusive(p14)
	return function(p15)
		local v22, v23 = v3.number(p15);
		if not v22 then
			return false, v23 and "";
		end;
		if p14 < p15 then
			return true;
		end;
		return false, string.format("number > %s expected, got %s", p14, p15);
	end;
end;
function v3.numberMaxExclusive(p16)
	return function(p17)
		local v24, v25 = v3.number(p17);
		if not v24 then
			return false, v25 and "";
		end;
		if p17 < p16 then
			return true;
		end;
		return false, string.format("number < %s expected, got %s", p16, p17);
	end;
end;
v3.numberPositive = v3.numberMinExclusive(0);
v3.numberNegative = v3.numberMaxExclusive(0);
function v3.numberConstrained(p18, p19)
	assert(v3.number(p18) and v3.number(p19));
	local u3 = v3.numberMin(p18);
	local u4 = v3.numberMax(p19);
	return function(p20)
		local v26, v27 = u3(p20);
		if not v26 then
			return false, v27 and "";
		end;
		local v28, v29 = u4(p20);
		if v28 then
			return true;
		end;
		return false, v29 and "";
	end;
end;
function v3.numberConstrainedExclusive(p21, p22)
	assert(v3.number(p21) and v3.number(p22));
	local u5 = v3.numberMinExclusive(p21);
	local u6 = v3.numberMaxExclusive(p22);
	return function(p23)
		local v30, v31 = u5(p23);
		if not v30 then
			return false, v31 and "";
		end;
		local v32, v33 = u6(p23);
		if v32 then
			return true;
		end;
		return false, v33 and "";
	end;
end;
function v3.match(p24)
	assert(v3.string(p24));
	return function(p25)
		local v34, v35 = v3.string(p25);
		if not v34 then
			return false, v35;
		end;
		if string.match(p25, p24) ~= nil then
			return true;
		end;
		return false, string.format("%q failed to match pattern %q", p25, p24);
	end;
end;
function v3.optional(p26)
	assert(v3.callback(p26));
	return function(p27)
		if p27 == nil then
			return true;
		end;
		local v36, v37 = p26(p27);
		if v36 then
			return true;
		end;
		return false, string.format("(optional) %s", v37 and "");
	end;
end;
function v3.tuple(...)
	local u7 = { ... };
	return function(...)
		local v38 = { ... };
		for v39, v40 in ipairs(u7) do
			local v41, v42 = v40(v38[v39]);
			if v41 == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", v39, v42 and "");
			end;
		end;
		return true;
	end;
end;
function v3.keys(p28)
	assert(v3.callback(p28));
	return function(p29)
		local v43, v44 = v3.table(p29);
		if v43 == false then
			return false, v44 and "";
		end;
		for v45, v46 in pairs(p29) do
			local v47, v48 = p28(v45);
			if v47 == false then
				return false, string.format("bad key %s:\n\t%s", tostring(v45), v48 and "");
			end;
		end;
		return true;
	end;
end;
function v3.values(p30)
	assert(v3.callback(p30));
	return function(p31)
		local v49, v50 = v3.table(p31);
		if v49 == false then
			return false, v50 and "";
		end;
		for v51, v52 in pairs(p31) do
			local v53, v54 = p30(v52);
			if v53 == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(v51), v54 and "");
			end;
		end;
		return true;
	end;
end;
function v3.map(p32, p33)
	assert(v3.callback(p32), v3.callback(p33));
	local u8 = v3.keys(p32);
	local u9 = v3.values(p33);
	return function(p34)
		local v55, v56 = u8(p34);
		if not v55 then
			return false, v56 and "";
		end;
		local v57, v58 = u9(p34);
		if v57 then
			return true;
		end;
		return false, v58 and "";
	end;
end;
function v3.set(p35)
	return v3.map(p35, v3.literal(true));
end;
local u10 = v3.keys(v3.integer);
function v3.array(p36)
	assert(v3.callback(p36));
	local u11 = v3.values(p36);
	return function(p37)
		local v59, v60 = u10(p37);
		if v59 == false then
			return false, string.format("[array] %s", v60 and "");
		end;
		local v61 = 0;
		for v62, v63 in ipairs(p37) do
			v61 = v61 + 1;
		end;
		for v64, v65 in pairs(p37) do
			if v64 < 1 then
				return false, string.format("[array] key %s must be sequential", tostring(v64));
			end;
			if v61 < v64 then
				return false, string.format("[array] key %s must be sequential", tostring(v64));
			end;
		end;
		local v66, v67 = u11(p37);
		if v66 then
			return true;
		end;
		return false, string.format("[array] %s", v67 and "");
	end;
end;
function v3.strictArray(...)
	local v68 = { ... };
	assert(v3.array(v3.callback)(v68));
	return function(p38)
		local v69, v70 = u10(p38);
		if v69 == false then
			return false, string.format("[strictArray] %s", v70 and "");
		end;
		if #v68 < #p38 then
			return false, string.format("[strictArray] Array size exceeds limit of %d", #v68);
		end;
		for v71, v72 in pairs(v68) do
			local v73, v74 = v72(p38[v71]);
			if not v73 then
				return false, string.format("[strictArray] Array index #%d - %s", v71, v74);
			end;
		end;
		return true;
	end;
end;
u10 = v3.array;
u10 = u10(v3.callback);
function v3.union(...)
	local v75 = { ... };
	assert(u10(v75));
	return function(p39)
		for v76, v77 in ipairs(v75) do
			if v77(p39) then
				return true;
			end;
		end;
		return false, "bad type for union";
	end;
end;
v3.some = v3.union;
function v3.intersection(...)
	local v78 = { ... };
	assert(u10(v78));
	return function(p40)
		for v79, v80 in ipairs(v78) do
			local v81, v82 = v80(p40);
			if not v81 then
				return false, v82 and "";
			end;
		end;
		return true;
	end;
end;
v3.every = v3.intersection;
u10 = v3.map;
u10 = u10(v3.any, v3.callback);
function v3.interface(p41)
	assert(u10(p41));
	return function(p42)
		local v83, v84 = v3.table(p42);
		if v83 == false then
			return false, v84 and "";
		end;
		for v85, v86 in pairs(p41) do
			local v87, v88 = v86(p42[v85]);
			if v87 == false then
				return false, string.format("[interface] bad value for %s:\n\t%s", tostring(v85), v88 and "");
			end;
		end;
		return true;
	end;
end;
function v3.strictInterface(p43)
	assert(u10(p43));
	return function(p44)
		local v89, v90 = v3.table(p44);
		if v89 == false then
			return false, v90 and "";
		end;
		for v91, v92 in pairs(p43) do
			local v93, v94 = v92(p44[v91]);
			if v93 == false then
				return false, string.format("[interface] bad value for %s:\n\t%s", tostring(v91), v94 and "");
			end;
		end;
		for v95, v96 in pairs(p44) do
			if not p43[v95] then
				return false, string.format("[interface] unexpected field %q", tostring(v95));
			end;
		end;
		return true;
	end;
end;
u10 = function(p45, p46)
	assert(v3.string(p45));
	local v97 = nil;
	if p46 ~= nil then
		v97 = v3.children(p46);
	end;
	return function(p47)
		local v98, v99 = v3.Instance(p47);
		if not v98 then
			return false, v99 and "";
		end;
		if p47.ClassName ~= p45 then
			return false, string.format("%s expected, got %s", p45, p47.ClassName);
		end;
		if v97 then
			local v100, v101 = v97(p47);
			if not v100 then
				return false, v101;
			end;
		end;
		return true;
	end;
end;
v3.instanceOf = u10;
u10 = v3.instanceOf;
v3.instance = u10;
u10 = function(p48, p49)
	assert(v3.string(p48));
	local v102 = nil;
	if p49 ~= nil then
		v102 = v3.children(p49);
	end;
	return function(p50)
		local v103, v104 = v3.Instance(p50);
		if not v103 then
			return false, v104 and "";
		end;
		if not p50:IsA(p48) then
			return false, string.format("%s expected, got %s", p48, p50.ClassName);
		end;
		if v102 then
			local v105, v106 = v102(p50);
			if not v105 then
				return false, v106;
			end;
		end;
		return true;
	end;
end;
v3.instanceIsA = u10;
u10 = function(p51)
	assert(v3.Enum(p51));
	return function(p52)
		local v107, v108 = v3.EnumItem(p52);
		if not v107 then
			return false, v108;
		end;
		if p52.EnumType == p51 then
			return true;
		end;
		return false, string.format("enum of %s expected, got enum of %s", tostring(p51), tostring(p52.EnumType));
	end;
end;
v3.enum = u10;
u10 = v3.tuple;
u10 = u10(v3.callback, v3.callback);
function v3.wrap(p53, p54)
	assert(u10(p53, p54));
	return function(...)
		assert(p54(...));
		return p53(...);
	end;
end;
u10 = function(p55)
	return function(...)
		assert(p55(...));
	end;
end;
v3.strict = u10;
u10 = v3.map;
u10 = u10(v3.string, v3.callback);
function v3.children(p56)
	assert(u10(p56));
	return function(p57)
		local v109, v110 = v3.Instance(p57);
		if not v109 then
			return false, v110 and "";
		end;
		local v111 = {};
		for v112, v113 in ipairs(p57:GetChildren()) do
			local l__Name__114 = v113.Name;
			if p56[l__Name__114] then
				if v111[l__Name__114] then
					return false, string.format("Cannot process multiple children with the same name %q", l__Name__114);
				end;
				v111[l__Name__114] = v113;
			end;
		end;
		for v115, v116 in pairs(p56) do
			local v117, v118 = v116(v111[v115]);
			if not v117 then
				return false, string.format("[%s.%s] %s", p57:GetFullName(), v115, v118 and "");
			end;
		end;
		return true;
	end;
end;
return v3;

