-- Decompiled with the Synapse X Luau decompiler.

local u1 = typeof or type;
local v1 = {
	any = function(p1)
		if p1 ~= nil then
			return true;
		end;
		return false, "any expected, got nil";
	end
};
local u2 = "boolean";
function v1.boolean(p2)
	local v2 = u1(p2);
	if v2 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v2);
end;
u2 = "thread";
function v1.thread(p3)
	local v3 = u1(p3);
	if v3 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v3);
end;
u2 = "function";
function v1.callback(p4)
	local v4 = u1(p4);
	if v4 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v4);
end;
v1["function"] = v1.callback;
u2 = "nil";
function v1.none(p5)
	local v5 = u1(p5);
	if v5 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v5);
end;
v1.nil = v1.none;
u2 = "string";
function v1.string(p6)
	local v6 = u1(p6);
	if v6 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v6);
end;
u2 = "table";
function v1.table(p7)
	local v7 = u1(p7);
	if v7 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v7);
end;
u2 = "userdata";
function v1.userdata(p8)
	local v8 = u1(p8);
	if v8 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v8);
end;
function v1.number(p9)
	local v9 = u1(p9);
	if v9 ~= "number" then
		return false, string.format("number expected, got %s", v9);
	end;
	if p9 == p9 then
		return true;
	end;
	return false, "unexpected NaN value";
end;
function v1.nan(p10)
	if p10 ~= p10 then
		return true;
	end;
	return false, "unexpected non-NaN value";
end;
u2 = "Axes";
function v1.Axes(p11)
	local v10 = u1(p11);
	if v10 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v10);
end;
u2 = "BrickColor";
function v1.BrickColor(p12)
	local v11 = u1(p12);
	if v11 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v11);
end;
u2 = "CFrame";
function v1.CFrame(p13)
	local v12 = u1(p13);
	if v12 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v12);
end;
u2 = "Color3";
function v1.Color3(p14)
	local v13 = u1(p14);
	if v13 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v13);
end;
u2 = "ColorSequence";
function v1.ColorSequence(p15)
	local v14 = u1(p15);
	if v14 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v14);
end;
u2 = "ColorSequenceKeypoint";
function v1.ColorSequenceKeypoint(p16)
	local v15 = u1(p16);
	if v15 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v15);
end;
u2 = "DockWidgetPluginGuiInfo";
function v1.DockWidgetPluginGuiInfo(p17)
	local v16 = u1(p17);
	if v16 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v16);
end;
u2 = "Faces";
function v1.Faces(p18)
	local v17 = u1(p18);
	if v17 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v17);
end;
u2 = "Instance";
function v1.Instance(p19)
	local v18 = u1(p19);
	if v18 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v18);
end;
u2 = "NumberRange";
function v1.NumberRange(p20)
	local v19 = u1(p20);
	if v19 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v19);
end;
u2 = "NumberSequence";
function v1.NumberSequence(p21)
	local v20 = u1(p21);
	if v20 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v20);
end;
u2 = "NumberSequenceKeypoint";
function v1.NumberSequenceKeypoint(p22)
	local v21 = u1(p22);
	if v21 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v21);
end;
u2 = "PathWaypoint";
function v1.PathWaypoint(p23)
	local v22 = u1(p23);
	if v22 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v22);
end;
u2 = "PhysicalProperties";
function v1.PhysicalProperties(p24)
	local v23 = u1(p24);
	if v23 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v23);
end;
u2 = "Random";
function v1.Random(p25)
	local v24 = u1(p25);
	if v24 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v24);
end;
u2 = "Ray";
function v1.Ray(p26)
	local v25 = u1(p26);
	if v25 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v25);
end;
u2 = "Rect";
function v1.Rect(p27)
	local v26 = u1(p27);
	if v26 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v26);
end;
u2 = "Region3";
function v1.Region3(p28)
	local v27 = u1(p28);
	if v27 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v27);
end;
u2 = "Region3int16";
function v1.Region3int16(p29)
	local v28 = u1(p29);
	if v28 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v28);
end;
u2 = "TweenInfo";
function v1.TweenInfo(p30)
	local v29 = u1(p30);
	if v29 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v29);
end;
u2 = "UDim";
function v1.UDim(p31)
	local v30 = u1(p31);
	if v30 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v30);
end;
u2 = "UDim2";
function v1.UDim2(p32)
	local v31 = u1(p32);
	if v31 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v31);
end;
u2 = "Vector2";
function v1.Vector2(p33)
	local v32 = u1(p33);
	if v32 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v32);
end;
u2 = "Vector3";
function v1.Vector3(p34)
	local v33 = u1(p34);
	if v33 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v33);
end;
u2 = "Vector3int16";
function v1.Vector3int16(p35)
	local v34 = u1(p35);
	if v34 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v34);
end;
u2 = "Enum";
function v1.Enum(p36)
	local v35 = u1(p36);
	if v35 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v35);
end;
u2 = "EnumItem";
function v1.EnumItem(p37)
	local v36 = u1(p37);
	if v36 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v36);
end;
u2 = "RBXScriptSignal";
function v1.RBXScriptSignal(p38)
	local v37 = u1(p38);
	if v37 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v37);
end;
u2 = "RBXScriptConnection";
function v1.RBXScriptConnection(p39)
	local v38 = u1(p39);
	if v38 == u2 then
		return true;
	end;
	return false, string.format("%s expected, got %s", u2, v38);
end;
function v1.literal(...)
	local v39 = select("#", ...);
	if v39 == 1 then
		local u3 = ...;
		return function(p40)
			if p40 == u3 then
				return true;
			end;
			return false, string.format("expected %s, got %s", tostring(u3), tostring(p40));
		end;
	end;
	local v40 = {};
	for v41 = 1, v39 do
		v40[v41] = v1.literal((select(v41, ...)));
	end;
	return v1.union(table.unpack(v40, 1, v39));
end;
v1.exactly = v1.literal;
function v1.keyOf(p41)
	local v42 = {};
	local v43 = 0;
	for v44 in pairs(p41) do
		v43 = v43 + 1;
		v42[v43] = v44;
	end;
	return v1.literal(table.unpack(v42, 1, v43));
end;
function v1.valueOf(p42)
	local v45 = {};
	local v46 = 0;
	for v47, v48 in pairs(p42) do
		v46 = v46 + 1;
		v45[v46] = v48;
	end;
	return v1.literal(table.unpack(v45, 1, v46));
end;
function v1.integer(p43)
	local v49, v50 = v1.number(p43);
	if not v49 then
		return false, v50 and "";
	end;
	if p43 % 1 == 0 then
		return true;
	end;
	return false, string.format("integer expected, got %s", p43);
end;
function v1.numberMin(p44)
	return function(p45)
		local v51, v52 = v1.number(p45);
		if not v51 then
			return false, v52 and "";
		end;
		if p44 <= p45 then
			return true;
		end;
		return false, string.format("number >= %s expected, got %s", p44, p45);
	end;
end;
function v1.numberMax(p46)
	return function(p47)
		local v53, v54 = v1.number(p47);
		if not v53 then
			return false, v54;
		end;
		if p47 <= p46 then
			return true;
		end;
		return false, string.format("number <= %s expected, got %s", p46, p47);
	end;
end;
function v1.numberMinExclusive(p48)
	return function(p49)
		local v55, v56 = v1.number(p49);
		if not v55 then
			return false, v56 and "";
		end;
		if p48 < p49 then
			return true;
		end;
		return false, string.format("number > %s expected, got %s", p48, p49);
	end;
end;
function v1.numberMaxExclusive(p50)
	return function(p51)
		local v57, v58 = v1.number(p51);
		if not v57 then
			return false, v58 and "";
		end;
		if p51 < p50 then
			return true;
		end;
		return false, string.format("number < %s expected, got %s", p50, p51);
	end;
end;
u2 = 0;
v1.numberPositive = v1.numberMinExclusive(u2);
u2 = 0;
v1.numberNegative = v1.numberMaxExclusive(u2);
function v1.numberConstrained(p52, p53)
	assert(v1.number(p52) and v1.number(p53));
	local u4 = v1.numberMin(p52);
	local u5 = v1.numberMax(p53);
	return function(p54)
		local v59, v60 = u4(p54);
		if not v59 then
			return false, v60 and "";
		end;
		local v61, v62 = u5(p54);
		if v61 then
			return true;
		end;
		return false, v62 and "";
	end;
end;
function v1.numberConstrainedExclusive(p55, p56)
	assert(v1.number(p55) and v1.number(p56));
	local u6 = v1.numberMinExclusive(p55);
	local u7 = v1.numberMaxExclusive(p56);
	return function(p57)
		local v63, v64 = u6(p57);
		if not v63 then
			return false, v64 and "";
		end;
		local v65, v66 = u7(p57);
		if v65 then
			return true;
		end;
		return false, v66 and "";
	end;
end;
function v1.match(p58)
	assert(v1.string(p58));
	return function(p59)
		local v67, v68 = v1.string(p59);
		if not v67 then
			return false, v68;
		end;
		if string.match(p59, p58) ~= nil then
			return true;
		end;
		return false, string.format("%q failed to match pattern %q", p59, p58);
	end;
end;
function v1.optional(p60)
	assert(v1.callback(p60));
	return function(p61)
		if p61 == nil then
			return true;
		end;
		local v69, v70 = p60(p61);
		if v69 then
			return true;
		end;
		return false, string.format("(optional) %s", v70 and "");
	end;
end;
function v1.tuple(...)
	local u8 = { ... };
	return function(...)
		local v71 = { ... };
		for v72, v73 in ipairs(u8) do
			local v74, v75 = v73(v71[v72]);
			if v74 == false then
				return false, string.format("Bad tuple index #%s:\n\t%s", v72, v75 and "");
			end;
		end;
		return true;
	end;
end;
function v1.keys(p62)
	assert(v1.callback(p62));
	return function(p63)
		local v76, v77 = v1.table(p63);
		if v76 == false then
			return false, v77 and "";
		end;
		for v78 in pairs(p63) do
			local v79, v80 = p62(v78);
			if v79 == false then
				return false, string.format("bad key %s:\n\t%s", tostring(v78), v80 and "");
			end;
		end;
		return true;
	end;
end;
function v1.values(p64)
	assert(v1.callback(p64));
	return function(p65)
		local v81, v82 = v1.table(p65);
		if v81 == false then
			return false, v82 and "";
		end;
		for v83, v84 in pairs(p65) do
			local v85, v86 = p64(v84);
			if v85 == false then
				return false, string.format("bad value for key %s:\n\t%s", tostring(v83), v86 and "");
			end;
		end;
		return true;
	end;
end;
function v1.map(p66, p67)
	assert(v1.callback(p66), v1.callback(p67));
	local u9 = v1.keys(p66);
	local u10 = v1.values(p67);
	return function(p68)
		local v87, v88 = u9(p68);
		if not v87 then
			return false, v88 and "";
		end;
		local v89, v90 = u10(p68);
		if v89 then
			return true;
		end;
		return false, v90 and "";
	end;
end;
function v1.set(p69)
	return v1.map(p69, v1.literal(true));
end;
u2 = v1.integer;
local u11 = v1.keys(u2);
u2 = function(p70)
	assert(v1.callback(p70));
	local u12 = v1.values(p70);
	return function(p71)
		local v91, v92 = u11(p71);
		if v91 == false then
			return false, string.format("[array] %s", v92 and "");
		end;
		local v93 = 0;
		for v94, v95 in ipairs(p71) do
			v93 = v93 + 1;
		end;
		for v96 in pairs(p71) do
			if v96 < 1 then
				return false, string.format("[array] key %s must be sequential", tostring(v96));
			end;
			if v93 < v96 then
				return false, string.format("[array] key %s must be sequential", tostring(v96));
			end;
		end;
		local v97, v98 = u12(p71);
		if v97 then
			return true;
		end;
		return false, string.format("[array] %s", v98 and "");
	end;
end;
v1.array = u2;
u2 = function(...)
	local v99 = { ... };
	assert(v1.array(v1.callback)(v99));
	return function(p72)
		local v100, v101 = u11(p72);
		if v100 == false then
			return false, string.format("[strictArray] %s", v101 and "");
		end;
		if #v99 < #p72 then
			return false, string.format("[strictArray] Array size exceeds limit of %d", #v99);
		end;
		for v102, v103 in pairs(v99) do
			local v104, v105 = v103(p72[v102]);
			if not v104 then
				return false, string.format("[strictArray] Array index #%d - %s", v102, v105);
			end;
		end;
		return true;
	end;
end;
v1.strictArray = u2;
u11 = v1.array;
u2 = v1.callback;
u11 = u11(u2);
u2 = function(...)
	local v106 = { ... };
	assert(u11(v106));
	return function(p73)
		for v107, v108 in ipairs(v106) do
			if v108(p73) then
				return true;
			end;
		end;
		return false, "bad type for union";
	end;
end;
v1.union = u2;
u2 = v1.union;
v1.some = u2;
u2 = function(...)
	local v109 = { ... };
	assert(u11(v109));
	return function(p74)
		for v110, v111 in ipairs(v109) do
			local v112, v113 = v111(p74);
			if not v112 then
				return false, v113 and "";
			end;
		end;
		return true;
	end;
end;
v1.intersection = u2;
u2 = v1.intersection;
v1.every = u2;
u11 = v1.map;
u2 = v1.any;
u11 = u11(u2, v1.callback);
u2 = function(p75)
	assert(u11(p75));
	return function(p76)
		local v114, v115 = v1.table(p76);
		if v114 == false then
			return false, v115 and "";
		end;
		for v116, v117 in pairs(p75) do
			local v118, v119 = v117(p76[v116]);
			if v118 == false then
				return false, string.format("[interface] bad value for %s:\n\t%s", tostring(v116), v119 and "");
			end;
		end;
		return true;
	end;
end;
v1.interface = u2;
u2 = function(p77)
	assert(u11(p77));
	return function(p78)
		local v120, v121 = v1.table(p78);
		if v120 == false then
			return false, v121 and "";
		end;
		for v122, v123 in pairs(p77) do
			local v124, v125 = v123(p78[v122]);
			if v124 == false then
				return false, string.format("[interface] bad value for %s:\n\t%s", tostring(v122), v125 and "");
			end;
		end;
		for v126 in pairs(p78) do
			if not p77[v126] then
				return false, string.format("[interface] unexpected field %q", tostring(v126));
			end;
		end;
		return true;
	end;
end;
v1.strictInterface = u2;
u11 = function(p79, p80)
	assert(v1.string(p79));
	local v127 = nil;
	if p80 ~= nil then
		v127 = v1.children(p80);
	end;
	return function(p81)
		local v128, v129 = v1.Instance(p81);
		if not v128 then
			return false, v129 and "";
		end;
		if p81.ClassName ~= p79 then
			return false, string.format("%s expected, got %s", p79, p81.ClassName);
		end;
		if v127 then
			local v130, v131 = v127(p81);
			if not v130 then
				return false, v131;
			end;
		end;
		return true;
	end;
end;
v1.instanceOf = u11;
u11 = v1.instanceOf;
v1.instance = u11;
u11 = function(p82, p83)
	assert(v1.string(p82));
	local v132 = nil;
	if p83 ~= nil then
		v132 = v1.children(p83);
	end;
	return function(p84)
		local v133, v134 = v1.Instance(p84);
		if not v133 then
			return false, v134 and "";
		end;
		if not p84:IsA(p82) then
			return false, string.format("%s expected, got %s", p82, p84.ClassName);
		end;
		if v132 then
			local v135, v136 = v132(p84);
			if not v135 then
				return false, v136;
			end;
		end;
		return true;
	end;
end;
v1.instanceIsA = u11;
u11 = function(p85)
	assert(v1.Enum(p85));
	return function(p86)
		local v137, v138 = v1.EnumItem(p86);
		if not v137 then
			return false, v138;
		end;
		if p86.EnumType == p85 then
			return true;
		end;
		return false, string.format("enum of %s expected, got enum of %s", tostring(p85), tostring(p86.EnumType));
	end;
end;
v1.enum = u11;
u11 = v1.tuple;
u2 = v1.callback;
u11 = u11(u2, v1.callback);
u2 = function(p87, p88)
	assert(u11(p87, p88));
	return function(...)
		assert(p88(...));
		return p87(...);
	end;
end;
v1.wrap = u2;
u11 = function(p89)
	return function(...)
		assert(p89(...));
	end;
end;
v1.strict = u11;
u11 = v1.map;
u2 = v1.string;
u11 = u11(u2, v1.callback);
u2 = function(p90)
	assert(u11(p90));
	return function(p91)
		local v139, v140 = v1.Instance(p91);
		if not v139 then
			return false, v140 and "";
		end;
		local v141 = {};
		for v142, v143 in ipairs(p91:GetChildren()) do
			local l__Name__144 = v143.Name;
			if p90[l__Name__144] then
				if v141[l__Name__144] then
					return false, string.format("Cannot process multiple children with the same name %q", l__Name__144);
				end;
				v141[l__Name__144] = v143;
			end;
		end;
		for v145, v146 in pairs(p90) do
			local v147, v148 = v146(v141[v145]);
			if not v147 then
				return false, string.format("[%s.%s] %s", p91:GetFullName(), v145, v148 and "");
			end;
		end;
		return true;
	end;
end;
v1.children = u2;
return v1;
