-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
v1.__index = v1;
local function u1(p1, p2)
	local v2 = typeof(p1);
	if v2 == "number" then
		local v3 = true;
		if p1 ~= p2 then
			v3 = math.abs(p1 - p2) <= (math.abs(p1) + 1) * 0.0001;
		end;
		return v3;
	end;
	if v2 == "Vector3" then
		return p1:FuzzyEq(p2, 0.0001);
	end;
	if v2 == "Vector2" then
		local l__X__4 = p1.X;
		local l__X__5 = p2.X;
		local l__Y__6 = p1.Y;
		local l__Y__7 = p2.Y;
		local v8 = true;
		if l__X__4 ~= l__X__5 then
			if math.abs(l__X__4 - l__X__5) <= (math.abs(l__X__4) + 1) * 0.0001 then
				v8 = true;
				if l__Y__6 ~= l__Y__7 then
					v8 = math.abs(l__Y__6 - l__Y__7) <= (math.abs(l__Y__6) + 1) * 0.0001;
				end;
			else
				v8 = math.abs(l__Y__6 - l__Y__7) <= (math.abs(l__Y__6) + 1) * 0.0001;
			end;
		end;
		return v8;
	end;
	if v2 ~= "CFrame" then
		return false;
	end;
	return p1.Position:FuzzyEq(p2.Position, 0.0001) and (p1.RightVector:FuzzyEq(p2.RightVector, 0.0001) and (p1.UpVector:FuzzyEq(p2.UpVector, 0.0001) and p1.LookVector:FuzzyEq(p2.LookVector, 0.0001)));
end;
local u2 = require(script.Spline);
local function u3(p3, p4)
	if p4 == "Vector2" or p4 == "Vector3" then
		return { p3 };
	end;
	if p4 ~= "CFrame" then
		return nil;
	end;
	local v9 = {};
	local v10, v11 = p3:ToAxisAngle();
	local v12 = v11 / 2;
	local v13 = math.sin(v12) * v10;
	v9[1] = p3.Position;
	v9[2] = { math.cos(v12), v13.X, v13.Y, v13.Z };
	return v9;
end;
function v1.new(p5, p6, p7)
	local v14 = nil;
	local v15 = nil;
	local v16 = nil;
	local v17 = nil;
	p6 = p6 and 0.5;
	p7 = p7 and 0;
	assert(type(p5) == "table", "Points must be a table");
	assert(type(p6) == "number", "Alpha must be a number");
	assert(type(p7) == "number", "Tension must be a number");
	assert(#p5 > 0, "Points table cannot be empty");
	local v18 = typeof(p5[1]);
	local v19 = true;
	if v18 ~= "Vector2" then
		v19 = true;
		if v18 ~= "Vector3" then
			v19 = v18 == "CFrame";
		end;
	end;
	assert(v19, "Points must be a table of Vector2s, Vector3s, or CFrames");
	local v20, v21, v22 = ipairs(p5);
	while true do
		v20(v21, v22);
		if not v20 then
			break;
		end;
		v22 = v20;
		assert(typeof(v21) == v18, "All points must have the same type");	
	end;
	local v23 = {};
	local v24 = p5[1];
	v23[1] = v24;
	local v25 = 2;
	for v26 = 2, #p5 do
		local v27 = p5[v26];
		if not u1(v27, v24) then
			v23[v25] = v27;
			v25 = v25 + 1;
			v24 = v27;
		end;
	end;
	p5 = v23;
	local v28 = #p5;
	if v28 == 1 then
		return setmetatable({
			alpha = p6, 
			tension = p7, 
			splines = { u2.fromPoint((u3(p5[1], v18))) }, 
			domains = { 0 }, 
			length = 0
		}, v1);
	end;
	local v29 = p5[1];
	local v30 = p5[v28];
	if u1(v29, v30) then
		local v31 = p5[v28 - 1];
		local v32 = p5[2];
	else
		v31 = p5[2]:Lerp(v29, 2);
		v32 = p5[v28 - 1]:Lerp(v30, 2);
	end;
	if v28 == 2 then
		local v33 = u2.fromLine(u3(v31, v18), u3(v29, v18), u3(v30, v18), (u3(v32, v18)));
		return setmetatable({
			alpha = p6, 
			tension = p7, 
			splines = { v33 }, 
			domains = { 0 }, 
			length = v33.length
		}, v1);
	end;
	local v34 = v28 - 1;
	local v35 = table.create(v34);
	v14 = u3(v29, v18);
	v15 = u3(p5[2], v18);
	v16 = u3(p5[3] and v32, v18);
	v35[1] = u2.new(u3(v31, v18), v14, v15, v16, p6, p7);
	v17 = 0 + v35[1].length;
	for v36 = 1, v28 - 3 do
		v14 = v15;
		v15 = v16;
		v16 = u3(p5[v36 + 3], v18);
		local v37 = u2.new(v14, v14, v15, v16, p6, p7);
		v17 = v17 + v37.length;
		v35[v36 + 1] = v37;
	end;
	v35[v34] = u2.new(local v38, local v39, local v40, u3(v32, v18), p6, p7);
	local v41 = local v42 + v35[v34].length;
	local v43 = table.create(v34 - 1);
	local v44 = 0;
	local v45, v46, v47 = ipairs(v35);
	while true do
		v45(v46, v47);
		if not v45 then
			break;
		end;
		v47 = v45;
		v43[v45] = v44 / v41;
		v44 = v44 + v46.length;	
	end;
	return setmetatable({
		alpha = p6, 
		tension = p7, 
		splines = v35, 
		domains = v43, 
		length = v41
	}, v1);
end;
function v1.GetSplineFromT(p8, p9)
	local l__splines__48 = p8.splines;
	local l__domains__49 = p8.domains;
	local v50 = #l__splines__48;
	if v50 == 1 then
		return l__splines__48[1], p9;
	end;
	if p9 < 0 then
		return l__splines__48[1], p9 / l__domains__49[1], 1;
	end;
	if p9 == 0 then
		return l__splines__48[1], 0, 1;
	end;
	if p9 == 1 then
		return l__splines__48[v50], 1, v50;
	end;
	if p9 > 1 then
		return l__splines__48[v50], (p9 - l__domains__49[v50]) / (1 - l__domains__49[v50]), v50;
	end;
	local v51 = 1;
	local v52 = v50 + 1;
	while v51 <= v52 do
		local v53 = math.floor((v51 + v52) / 2);
		local v54 = l__domains__49[v53];
		if v54 <= p9 then
			if v53 == v50 then
				local v55 = 1;
			else
				v55 = l__domains__49[v53 + 1];
			end;
			if p9 <= v55 then
				return l__splines__48[v53], (p9 - v54) / (v55 - v54), v53;
			end;
			v51 = v53 + 1;
		else
			v52 = v53 - 1;
		end;	
	end;
	error("Failed to get spline from t");
end;
function v1.PrecomputeArcLengthParams(p10, p11)
	p11 = p11 and math.max(1, math.round(p11)) or 16;
	local v56, v57, v58 = ipairs(p10.splines);
	while true do
		v56(v57, v58);
		if not v56 then
			break;
		end;
		v58 = v56;
		v57:_PrecomputeArcLengthParams(p11);	
	end;
end;
function v1.SolveLength(p12, p13, p14)
	local v59 = nil;
	p13 = p13 and 0;
	p14 = p14 and 1;
	if p13 == 0 and p14 == 1 then
		return p12.length;
	end;
	local v60, v61, v62 = p12:GetSplineFromT(p13);
	local v63, v64, v65 = p12:GetSplineFromT(p14);
	v59 = 0;
	for v66 = v62 + 1, v65 - 1 do
		v59 = v59 + p12.splines[v66].length;
	end;
	return v60:SolveLength(v61, 1) + local v67 + v63:SolveLength(0, v64);
end;
function v1.SolveUniformLength(p15, p16, p17)
	local v68 = nil;
	p16 = p16 and 0;
	p17 = p17 and 1;
	if p16 == 0 and p17 == 1 then
		return p15.length;
	end;
	local v69, v70, v71 = p15:GetSplineFromT(p16);
	local v72, v73, v74 = p15:GetSplineFromT(p17);
	v68 = 0;
	for v75 = v71 + 1, v74 - 1 do
		v68 = v68 + p15.splines[v75].length;
	end;
	return v69:SolveUniformLength(v70, 1) + local v76 + v72:SolveUniformLength(0, v73);
end;
function v1.SolvePosition(p18, p19)
	local v77, v78 = p18:GetSplineFromT(p19);
	return v77:SolvePosition(v78);
end;
function v1.SolveVelocity(p20, p21)
	local v79, v80 = p20:GetSplineFromT(p21);
	return v79:SolveVelocity(v80);
end;
function v1.SolveAcceleration(p22, p23)
	local v81, v82 = p22:GetSplineFromT(p23);
	return v81:SolveAcceleration(v82);
end;
function v1.SolveTangent(p24, p25)
	local v83, v84 = p24:GetSplineFromT(p25);
	return v83:SolveTangent(v84);
end;
function v1.SolveNormal(p26, p27)
	local v85, v86 = p26:GetSplineFromT(p27);
	return v85:SolveNormal(v86);
end;
function v1.SolveBinormal(p28, p29)
	local v87, v88 = p28:GetSplineFromT(p29);
	return v87:SolveBinormal(v88);
end;
function v1.SolveCurvature(p30, p31)
	local v89, v90 = p30:GetSplineFromT(p31);
	return v89:SolveCurvature(v90);
end;
function v1.SolveCFrame(p32, p33)
	local v91, v92 = p32:GetSplineFromT(p33);
	return v91:SolveCFrame(v92);
end;
function v1.SolveRotCFrame(p34, p35)
	local v93, v94 = p34:GetSplineFromT(p35);
	return v93:SolveRotCFrame(v94);
end;
function v1.SolveUniformPosition(p36, p37)
	local v95, v96 = p36:GetSplineFromT(p37);
	return v95:SolveUniformPosition(v96);
end;
function v1.SolveUniformVelocity(p38, p39)
	local v97, v98 = p38:GetSplineFromT(p39);
	return v97:SolveUniformVelocity(v98);
end;
function v1.SolveUniformAcceleration(p40, p41)
	local v99, v100 = p40:GetSplineFromT(p41);
	return v99:SolveUniformAcceleration(v100);
end;
function v1.SolveUniformTangent(p42, p43)
	local v101, v102 = p42:GetSplineFromT(p43);
	return v101:SolveUniformTangent(v102);
end;
function v1.SolveUniformNormal(p44, p45)
	local v103, v104 = p44:GetSplineFromT(p45);
	return v103:SolveUniformNormal(v104);
end;
function v1.SolveUniformBinormal(p46, p47)
	local v105, v106 = p46:GetSplineFromT(p47);
	return v105:SolveUniformBinormal(v106);
end;
function v1.SolveUniformCurvature(p48, p49)
	local v107, v108 = p48:GetSplineFromT(p49);
	return v107:SolveUniformCurvature(v108);
end;
function v1.SolveUniformCFrame(p50, p51)
	local v109, v110 = p50:GetSplineFromT(p51);
	return v109:SolveUniformCFrame(v110);
end;
function v1.SolveUniformRotCFrame(p52, p53)
	local v111, v112 = p52:GetSplineFromT(p53);
	return v111:SolveUniformRotCFrame(v112);
end;
return v1;
