-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
v1.__index = v1;
local function u1(p1, p2)
	local v2 = typeof(p1);
	if v2 == "number" then
		local v3 = true;
		if p1 ~= p2 then
			v3 = math.abs(p1 - p2) <= (math.abs(p1) + 1) * 0.0001;
		end;
		return v3;
	end;
	if v2 == "Vector3" then
		return p1:FuzzyEq(p2, 0.0001);
	end;
	if v2 == "Vector2" then
		local l__X__4 = p1.X;
		local l__X__5 = p2.X;
		local l__Y__6 = p1.Y;
		local l__Y__7 = p2.Y;
		local v8 = true;
		if l__X__4 ~= l__X__5 then
			if math.abs(l__X__4 - l__X__5) <= (math.abs(l__X__4) + 1) * 0.0001 then
				v8 = true;
				if l__Y__6 ~= l__Y__7 then
					v8 = math.abs(l__Y__6 - l__Y__7) <= (math.abs(l__Y__6) + 1) * 0.0001;
				end;
			else
				v8 = math.abs(l__Y__6 - l__Y__7) <= (math.abs(l__Y__6) + 1) * 0.0001;
			end;
		end;
		return v8;
	end;
	if v2 ~= "CFrame" then
		return false;
	end;
	return p1.Position:FuzzyEq(p2.Position, 0.0001) and (p1.RightVector:FuzzyEq(p2.RightVector, 0.0001) and (p1.UpVector:FuzzyEq(p2.UpVector, 0.0001) and p1.LookVector:FuzzyEq(p2.LookVector, 0.0001)));
end;
local u2 = require(script.Spline);
local function u3(p3, p4)
	if p4 == "Vector2" or p4 == "Vector3" then
		return { p3 };
	end;
	if p4 ~= "CFrame" then
		return nil;
	end;
	local v9 = {};
	local v10, v11 = p3:ToAxisAngle();
	local v12 = v11 / 2;
	local v13 = math.sin(v12) * v10;
	v9[1] = p3.Position;
	v9[2] = { math.cos(v12), v13.X, v13.Y, v13.Z };
	return v9;
end;
function v1.new(p5, p6, p7)
	local v14 = nil;
	local v15 = nil;
	local v16 = nil;
	local v17 = nil;
	p6 = p6 and 0.5;
	p7 = p7 and 0;
	assert(type(p5) == "table", "Points must be a table");
	assert(type(p6) == "number", "Alpha must be a number");
	assert(type(p7) == "number", "Tension must be a number");
	assert(#p5 > 0, "Points table cannot be empty");
	local v18 = typeof(p5[1]);
	local v19 = true;
	if v18 ~= "Vector2" then
		v19 = true;
		if v18 ~= "Vector3" then
			v19 = v18 == "CFrame";
		end;
	end;
	assert(v19, "Points must be a table of Vector2s, Vector3s, or CFrames");
	for v20, v21 in ipairs(p5) do
		assert(typeof(v21) == v18, "All points must have the same type");
	end;
	local v22 = {};
	local v23 = p5[1];
	v22[1] = v23;
	local v24 = 2;
	for v25 = 2, #p5 do
		local v26 = p5[v25];
		if not u1(v26, v23) then
			v22[v24] = v26;
			v24 = v24 + 1;
			v23 = v26;
		end;
	end;
	p5 = v22;
	local v27 = #p5;
	if v27 == 1 then
		return setmetatable({
			alpha = p6, 
			tension = p7, 
			splines = { u2.fromPoint((u3(p5[1], v18))) }, 
			domains = { 0 }, 
			length = 0
		}, v1);
	end;
	local v28 = p5[1];
	local v29 = p5[v27];
	if u1(v28, v29) then
		local v30 = p5[v27 - 1];
		local v31 = p5[2];
	else
		v30 = p5[2]:Lerp(v28, 2);
		v31 = p5[v27 - 1]:Lerp(v29, 2);
	end;
	if v27 == 2 then
		local v32 = u2.fromLine(u3(v30, v18), u3(v28, v18), u3(v29, v18), (u3(v31, v18)));
		return setmetatable({
			alpha = p6, 
			tension = p7, 
			splines = { v32 }, 
			domains = { 0 }, 
			length = v32.length
		}, v1);
	end;
	local v33 = v27 - 1;
	local v34 = table.create(v33);
	v14 = u3(v28, v18);
	v15 = u3(p5[2], v18);
	v16 = u3(p5[3] and v31, v18);
	v34[1] = u2.new(u3(v30, v18), v14, v15, v16, p6, p7);
	v17 = 0 + v34[1].length;
	for v35 = 1, v27 - 3 do
		v14 = v15;
		v15 = v16;
		v16 = u3(p5[v35 + 3], v18);
		local v36 = u2.new(v14, v14, v15, v16, p6, p7);
		v17 = v17 + v36.length;
		v34[v35 + 1] = v36;
	end;
	v34[v33] = u2.new(local v37, local v38, local v39, u3(v31, v18), p6, p7);
	local v40 = local v41 + v34[v33].length;
	local v42 = table.create(v33 - 1);
	local v43 = 0;
	for v44, v45 in ipairs(v34) do
		v42[v44] = v43 / v40;
		v43 = v43 + v45.length;
	end;
	return setmetatable({
		alpha = p6, 
		tension = p7, 
		splines = v34, 
		domains = v42, 
		length = v40
	}, v1);
end;
function v1.GetSplineFromT(p8, p9)
	local l__splines__46 = p8.splines;
	local l__domains__47 = p8.domains;
	local v48 = #l__splines__46;
	if v48 == 1 then
		return l__splines__46[1], p9;
	end;
	if p9 < 0 then
		return l__splines__46[1], p9 / l__domains__47[1], 1;
	end;
	if p9 == 0 then
		return l__splines__46[1], 0, 1;
	end;
	if p9 == 1 then
		return l__splines__46[v48], 1, v48;
	end;
	if p9 > 1 then
		return l__splines__46[v48], (p9 - l__domains__47[v48]) / (1 - l__domains__47[v48]), v48;
	end;
	local v49 = 1;
	local v50 = v48 + 1;
	while v49 <= v50 do
		local v51 = math.floor((v49 + v50) / 2);
		local v52 = l__domains__47[v51];
		if v52 <= p9 then
			if v51 == v48 then
				local v53 = 1;
			else
				v53 = l__domains__47[v51 + 1];
			end;
			if p9 <= v53 then
				return l__splines__46[v51], (p9 - v52) / (v53 - v52), v51;
			end;
			v49 = v51 + 1;
		else
			v50 = v51 - 1;
		end;	
	end;
	error("Failed to get spline from t");
end;
function v1.PrecomputeArcLengthParams(p10, p11)
	p11 = p11 and math.max(1, math.round(p11)) or 16;
	for v54, v55 in ipairs(p10.splines) do
		v55:_PrecomputeArcLengthParams(p11);
	end;
end;
function v1.SolveLength(p12, p13, p14)
	local v56 = nil;
	p13 = p13 and 0;
	p14 = p14 and 1;
	if p13 == 0 and p14 == 1 then
		return p12.length;
	end;
	local v57, v58, v59 = p12:GetSplineFromT(p13);
	local v60, v61, v62 = p12:GetSplineFromT(p14);
	v56 = 0;
	for v63 = v59 + 1, v62 - 1 do
		v56 = v56 + p12.splines[v63].length;
	end;
	return v57:SolveLength(v58, 1) + local v64 + v60:SolveLength(0, v61);
end;
function v1.SolveUniformLength(p15, p16, p17)
	local v65 = nil;
	p16 = p16 and 0;
	p17 = p17 and 1;
	if p16 == 0 and p17 == 1 then
		return p15.length;
	end;
	local v66, v67, v68 = p15:GetSplineFromT(p16);
	local v69, v70, v71 = p15:GetSplineFromT(p17);
	v65 = 0;
	for v72 = v68 + 1, v71 - 1 do
		v65 = v65 + p15.splines[v72].length;
	end;
	return v66:SolveUniformLength(v67, 1) + local v73 + v69:SolveUniformLength(0, v70);
end;
function v1.SolvePosition(p18, p19)
	local v74, v75 = p18:GetSplineFromT(p19);
	return v74:SolvePosition(v75);
end;
function v1.SolveVelocity(p20, p21)
	local v76, v77 = p20:GetSplineFromT(p21);
	return v76:SolveVelocity(v77);
end;
function v1.SolveAcceleration(p22, p23)
	local v78, v79 = p22:GetSplineFromT(p23);
	return v78:SolveAcceleration(v79);
end;
function v1.SolveTangent(p24, p25)
	local v80, v81 = p24:GetSplineFromT(p25);
	return v80:SolveTangent(v81);
end;
function v1.SolveNormal(p26, p27)
	local v82, v83 = p26:GetSplineFromT(p27);
	return v82:SolveNormal(v83);
end;
function v1.SolveBinormal(p28, p29)
	local v84, v85 = p28:GetSplineFromT(p29);
	return v84:SolveBinormal(v85);
end;
function v1.SolveCurvature(p30, p31)
	local v86, v87 = p30:GetSplineFromT(p31);
	return v86:SolveCurvature(v87);
end;
function v1.SolveCFrame(p32, p33)
	local v88, v89 = p32:GetSplineFromT(p33);
	return v88:SolveCFrame(v89);
end;
function v1.SolveRotCFrame(p34, p35)
	local v90, v91 = p34:GetSplineFromT(p35);
	return v90:SolveRotCFrame(v91);
end;
function v1.SolveUniformPosition(p36, p37)
	local v92, v93 = p36:GetSplineFromT(p37);
	return v92:SolveUniformPosition(v93);
end;
function v1.SolveUniformVelocity(p38, p39)
	local v94, v95 = p38:GetSplineFromT(p39);
	return v94:SolveUniformVelocity(v95);
end;
function v1.SolveUniformAcceleration(p40, p41)
	local v96, v97 = p40:GetSplineFromT(p41);
	return v96:SolveUniformAcceleration(v97);
end;
function v1.SolveUniformTangent(p42, p43)
	local v98, v99 = p42:GetSplineFromT(p43);
	return v98:SolveUniformTangent(v99);
end;
function v1.SolveUniformNormal(p44, p45)
	local v100, v101 = p44:GetSplineFromT(p45);
	return v100:SolveUniformNormal(v101);
end;
function v1.SolveUniformBinormal(p46, p47)
	local v102, v103 = p46:GetSplineFromT(p47);
	return v102:SolveUniformBinormal(v103);
end;
function v1.SolveUniformCurvature(p48, p49)
	local v104, v105 = p48:GetSplineFromT(p49);
	return v104:SolveUniformCurvature(v105);
end;
function v1.SolveUniformCFrame(p50, p51)
	local v106, v107 = p50:GetSplineFromT(p51);
	return v106:SolveUniformCFrame(v107);
end;
function v1.SolveUniformRotCFrame(p52, p53)
	local v108, v109 = p52:GetSplineFromT(p53);
	return v108:SolveUniformRotCFrame(v109);
end;
return v1;
