-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
v1.__index = v1;
function v1.new(p1, p2, p3, p4, p5, p6)
	local v2 = p1[1];
	local v3 = p2[1];
	local v4 = p3[1];
	local v5 = p4[1];
	local v6 = v3 - v2;
	local v7 = v4 - v3;
	local v8 = v5 - v4;
	local v9 = v6.Magnitude ^ p5 + 0;
	local v10 = v7.Magnitude ^ p5 + v9;
	local v11 = v8.Magnitude ^ p5 + v10;
	local v12 = (1 - p6) * (v10 - v9);
	local v13 = v12 * (v6 / (v9 - 0) - (v4 - v2) / (v10 - 0) + v7 / (v10 - v9));
	local v14 = v12 * (v7 / (v10 - v9) - (v5 - v3) / (v11 - v9) + v8 / (v11 - v10));
	local v15 = setmetatable({
		rot0 = p1[2], 
		rot1 = p2[2], 
		rot2 = p3[2], 
		rot3 = p4[2], 
		length = nil, 
		a = 2 * -v7 + v13 + v14, 
		b = 3 * v7 - 2 * v13 - v14, 
		c = v13, 
		d = v3, 
		arcLengthParamsLUT = nil
	}, v1);
	v15.length = v15:SolveLength();
	return v15;
end;
function v1.fromPoint(p7)
	local v16 = p7[1] * 0;
	return setmetatable({
		rot0 = p7[2], 
		length = 0, 
		a = v16, 
		b = v16, 
		c = v16, 
		d = p7[1], 
		arcLengthParamsLUT = nil
	}, v1);
end;
function v1.fromLine(p8, p9, p10, p11)
	local v17 = p9[1];
	local v18 = v17 * 0;
	local v19 = p10[1] - v17;
	return setmetatable({
		rot0 = p8[2], 
		rot1 = p9[2], 
		rot2 = p10[2], 
		rot3 = p11[2], 
		length = v19.Magnitude, 
		a = v18, 
		b = v18, 
		c = v19, 
		d = v17, 
		arcLengthParamsLUT = nil
	}, v1);
end;
function v1.SolvePosition(p12, p13)
	return p12.d + p13 * (p12.c + p13 * (p12.b + p13 * p12.a));
end;
function v1.SolveVelocity(p14, p15)
	return p14.c + p15 * (2 * p14.b + p15 * 3 * p14.a);
end;
function v1.SolveAcceleration(p16, p17)
	return 6 * p16.a * p17 + 2 * p16.b;
end;
function v1.SolveTangent(p18, p19)
	return p18:SolveVelocity(p19).Unit;
end;
function v1.SolveNormal(p20, p21)
	local v20 = p20:SolveVelocity(p21);
	local v21 = p20:SolveAcceleration(p21);
	return (v21 * v20.Magnitude ^ 2 - v20 * v21:Dot(v20)).Unit;
end;
function v1.SolveBinormal(p22, p23)
	return p22:SolveTangent(p23):Cross(p22:SolveNormal(p23));
end;
function v1.SolveCurvature(p24, p25)
	local v22 = p24:SolveVelocity(p25);
	local v23 = p24:SolveAcceleration(p25);
	local l__Magnitude__24 = v22.Magnitude;
	local v25 = v23 / l__Magnitude__24 - v22 * v22:Dot(v23) / l__Magnitude__24 ^ 3;
	return v25.Magnitude / l__Magnitude__24, v25.Unit;
end;
function v1.SolveCFrame(p26, p27)
	local v26 = nil;
	v26 = p26:SolvePosition(p27);
	local v27 = p26:SolveVelocity(p27);
	if v27.Magnitude ~= 0 then
		return CFrame.lookAt(v26, v26 + v27);
	end;
	local l__rot0__28 = p26.rot0;
	if not l__rot0__28 then
		return CFrame.new(v26);
	end;
	return CFrame.new(v26.X, v26.Y, v26.Z, l__rot0__28[2], l__rot0__28[3], l__rot0__28[4], l__rot0__28[1]);
end;
local u1 = require(script.Parent.Squad);
function v1.SolveRotCFrame(p28, p29)
	local l__rot0__29 = p28.rot0;
	if not l__rot0__29 then
		return p28:SolveCFrame(p29);
	end;
	local l__rot1__30 = p28.rot1;
	if not l__rot1__30 then
		return p28:SolveCFrame(p29);
	end;
	local v31 = p28:SolvePosition(p29);
	local v32, v33, v34, v35 = u1(l__rot0__29, l__rot1__30, p28.rot2, p28.rot3, p29);
	return CFrame.new(v31.X, v31.Y, v31.Z, v33, v34, v35, v32);
end;
local u2 = require(script.Parent.GaussLegendre);
function v1.SolveLength(p30, p31, p32)
	p31 = p31 and 0;
	p32 = p32 and 1;
	if p31 == 0 and p32 == 1 and p30.length then
		return p30.length;
	end;
	return u2.Ten(function(p33)
		return p30:SolveVelocity(p33).Magnitude;
	end, p31, p32);
end;
function v1.Reparameterize(p34, p35)
	if p35 == 0 or p35 == 1 then
		return p35;
	end;
	if p34.length == 0 then
		return 0;
	end;
	local l__arcLengthParams__36 = p34.arcLengthParams;
	if not l__arcLengthParams__36 then
		return p34:_ReparameterizeHybrid(p35);
	end;
	local v37 = #p34.arcLengthParams - 1;
	local v38 = math.floor(p35 * v37) + 1;
	local v39 = p35 * v37 - v38 + 1;
	return l__arcLengthParams__36[v38] * (1 - v39) + l__arcLengthParams__36[v38 + 1] * v39;
end;
function v1._ReparameterizeHybrid(p36, p37)
	if p37 == 0 or p37 == 1 then
		return p37;
	end;
	if p36.length == 0 then
		return 0;
	end;
	local function v40(p38)
		return p36:SolveVelocity(p38).Magnitude;
	end;
	local v41 = 1;
	for v42 = 1, 16 do
		local v43 = u2.Ten(v40, 0, p37) / p36.length - p37;
		if math.abs(v43) < 0.0001 then
			return p37;
		end;
		local v44 = p37 - v43 / (p36:SolveVelocity(p37).Magnitude / p36.length);
		if v43 > 0 then
			v41 = p37;
			local v45 = v44 <= local v46 and (v41 + v46) / 2 or v44;
		else
			v45 = v41 <= v44 and (v41 + p37) / 2 or v44;
		end;
	end;
	warn("Failed to reparameterize; falling back to input");
	return p37;
end;
function v1._PrecomputeArcLengthParams(p39, p40)
	if p39.length == 0 then
		return;
	end;
	local v47 = table.create(p40 + 1);
	v47[1] = 0;
	v47[p40 + 1] = 1;
	for v48 = 2, p40 do
		v47[v48] = p39:_ReparameterizeHybrid((v48 - 1) / p40);
	end;
	p39.arcLengthParamsLUT = v47;
end;
function v1.SolveUniformPosition(p41, p42)
	return p41:SolvePosition(p41:Reparameterize(p42));
end;
function v1.SolveUniformVelocity(p43, p44)
	return p43:SolveVelocity(p43:Reparameterize(p44));
end;
function v1.SolveUniformAcceleration(p45, p46)
	return p45:SolveAcceleration(p45:Reparameterize(p46));
end;
function v1.SolveUniformTangent(p47, p48)
	return p47:SolveTangent(p47:Reparameterize(p48));
end;
function v1.SolveUniformNormal(p49, p50)
	return p49:SolveNormal(p49:Reparameterize(p50));
end;
function v1.SolveUniformBinormal(p51, p52)
	return p51:SolveBinormal(p51:Reparameterize(p52));
end;
function v1.SolveUniformCurvature(p53, p54)
	return p53:SolveCurvature(p53:Reparameterize(p54));
end;
function v1.SolveUniformCFrame(p55, p56)
	return p55:SolveCFrame(p55:Reparameterize(p56));
end;
function v1.SolveUniformRotCFrame(p57, p58)
	return p57:SolveRotCFrame(p57:Reparameterize(p58));
end;
function v1.SolveUniformLength(p59, p60, p61)
	return p59:SolveLength(p59:Reparameterize(p60), p59:Reparameterize(p61));
end;
return v1;
