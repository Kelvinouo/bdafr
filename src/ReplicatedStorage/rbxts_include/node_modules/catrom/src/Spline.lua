
-- Decompiled with the Synapse X Luau decompiler.

local v1 = require(script.Parent.Types);
local v2 = {};
v2.__index = v2;
local l__tOptionalUnitInterval__1 = v1.tOptionalUnitInterval;
local l__tKnots__2 = v1.tKnots;
local u3 = require(script.Parent.FuzzyEq);
function v2.new(p1, p2, p3, p4, p5, p6)
	assert(l__tOptionalUnitInterval__1(p5));
	assert(l__tKnots__2(p1, p2, p3, p4));
	p5 = p5 and 0.5;
	p6 = p6 and 0;
	local v3 = nil;
	local v4 = nil;
	local v5 = nil;
	local v6 = nil;
	local v7 = nil;
	if typeof(p1) == "Vector3" or typeof(p1) == "Vector2" then
		v3 = p1;
		v4 = p2;
		v5 = p3;
		v6 = p4;
		v7 = "VectorSpline";
	elseif typeof(p1) == "CFrame" then
		v3 = p1.Position;
		v4 = p2.Position;
		v5 = p3.Position;
		v6 = p4.Position;
		v7 = "CFrameSpline";
	end;
	if u3(v4, v5) then
		local v8 = v4 * 0;
		local v9 = v8;
		local v10 = v8;
	elseif u3(v3, v4) or u3(v5, v6) then
		v8 = v4 * 0;
		v9 = v8;
		v10 = v5 - v4;
	else
		local v11 = (v4 - v3).Magnitude ^ p5 + 0;
		local v12 = (v5 - v4).Magnitude ^ p5 + v11;
		local v13 = (v6 - v5).Magnitude ^ p5 + v12;
		local v14 = (1 - p6) * (v12 - v11) * ((v4 - v3) / (v11 - 0) - (v5 - v3) / (v12 - 0) + (v5 - v4) / (v12 - v11));
		local v15 = (1 - p6) * (v12 - v11) * ((v5 - v4) / (v12 - v11) - (v6 - v4) / (v13 - v11) + (v6 - v5) / (v13 - v12));
		v8 = 2 * (v4 - v5) + v14 + v15;
		v9 = 3 * (v5 - v4) - 2 * v14 - v15;
		v10 = v14;
	end;
	local v16 = setmetatable({
		ClassName = v7, 
		Length = nil, 
		RiemannSteps = 1000, 
		k0 = p1, 
		k1 = p2, 
		k2 = p3, 
		k3 = p4, 
		a = v8, 
		b = v9, 
		c = v10, 
		d = v4
	}, v2);
	v16.Length = v16:SolveLength();
	return v16;
end;
function v2._Reparameterize(p7, p8)
	if p8 == 0 or p8 == 1 then
		return p8;
	end;
	local v17 = p7.Length * p8;
	local v18 = 0;
	local v19 = p7:SolvePosition(0);
	for v20 = 1, 1000 do
		local v21 = v20 / 1000;
		local v22 = p7:SolvePosition(v21);
		v18 = v18 + (v22 - v19).Magnitude;
		v19 = v22;
		if v17 < v18 then
			return v21;
		end;
	end;
	error("Failed to reparameterize");
end;
function v2.SolvePosition(p9, p10)
	return p9.a * p10 ^ 3 + p9.b * p10 ^ 2 + p9.c * p10 + p9.d;
end;
function v2.SolveVelocity(p11, p12)
	return 3 * p11.a * p12 ^ 2 + 2 * p11.b * p12 + p11.c;
end;
function v2.SolveAcceleration(p13, p14)
	return 6 * p13.a * p14 + 2 * p13.b;
end;
function v2.SolveTangent(p15, p16)
	return p15:SolveVelocity(p16).Unit;
end;
function v2.SolveNormal(p17, p18)
	local v23 = p17:SolveVelocity(p18);
	local v24 = p17:SolveAcceleration(p18);
	return (v24 / v23.Magnitude - v23 * v23:Dot(v24) / v23.Magnitude ^ 3).Unit;
end;
function v2.SolveBinormal(p19, p20)
	return p19:SolveTangent(p20):Cross(p19:SolveNormal(p20));
end;
function v2.SolveCurvature(p21, p22)
	local v25 = p21:SolveVelocity(p22);
	local v26 = p21:SolveAcceleration(p22);
	local v27 = v26 / v25.Magnitude - v25 * v25:Dot(v26) / v25.Magnitude ^ 3;
	return v27.Magnitude / v25.Magnitude, v27.Unit;
end;
function v2.SolveCFrame(p23, p24)
	local v28 = p23:SolvePosition(p24);
	return CFrame.lookAt(v28, v28 + p23:SolveVelocity(p24));
end;
function v2.SolveLength(p25, p26, p27)
	local v29 = nil;
	assert(l__tOptionalUnitInterval__1(p26));
	assert(l__tOptionalUnitInterval__1(p27));
	p26 = p26 and 0;
	p27 = p27 and 1;
	v29 = 0;
	local v30 = p25:SolvePosition(p26);
	local v31 = (p27 - p26) * 1000;
	for v32 = 1, v31 do
		local v33 = p25:SolvePosition(p26 + (p27 - p26) * (v32 / v31));
		v29 = v29 + (v33 - v30).Magnitude;
		v30 = v33;
	end;
	return local v34;
end;
local l__tUnitInterval__4 = v1.tUnitInterval;
local u5 = require(script.Parent.Squad);
function v2.SolveRotCFrame(p28, p29)
	assert(l__tUnitInterval__4(p29));
	local v35 = nil;
	local v36 = nil;
	local v37 = nil;
	local v38 = nil;
	if p28.ClassName == "CFrameSpline" then
		v35 = p28.k0;
		v36 = p28.k1;
		v37 = p28.k2;
		v38 = p28.k3;
	elseif p28.ClassName == "VectorSpline" then
		v35 = CFrame.new(p28.k0);
		v36 = CFrame.new(p28.k1);
		v37 = CFrame.new(p28.k2);
		v38 = CFrame.new(p28.k3);
	end;
	local v39 = p28:SolvePosition(p29);
	local v40 = p28:SolveVelocity(p29);
	local v41, v42, v43, v44 = u5(v35, v36, v37, v38, p29);
	return CFrame.lookAt(v39, v39 + v40, CFrame.new(0, 0, 0, v42, v43, v44, v41).UpVector);
end;
function v2.SolveUniformPosition(p30, p31)
	p31 = p30:_Reparameterize(p31);
	return p30:SolvePosition(p31);
end;
function v2.SolveUniformVelocity(p32, p33)
	p33 = p32:_Reparameterize(p33);
	return p32:SolveVelocity(p33);
end;
function v2.SolveUniformAcceleration(p34, p35)
	p35 = p34:_Reparameterize(p35);
	return p34:SolveAcceleration(p35);
end;
function v2.SolveUniformTangent(p36, p37)
	p37 = p36:_Reparameterize(p37);
	return p36:SolveTangent(p37);
end;
function v2.SolveUniformNormal(p38, p39)
	p39 = p38:_Reparameterize(p39);
	return p38:SolveNormal(p39);
end;
function v2.SolveUniformBinormal(p40, p41)
	p41 = p40:_Reparameterize(p41);
	return p40:SolveBinormal(p41);
end;
function v2.SolveUniformCurvature(p42, p43)
	p43 = p42:_Reparameterize(p43);
	return p42:SolveCurvature(p43);
end;
function v2.SolveUniformCFrame(p44, p45)
	p45 = p44:_Reparameterize(p45);
	return p44:SolveCFrame(p45);
end;
function v2.SolveUniformLength(p46, p47, p48)
	p47 = p46:_Reparameterize(p47);
	p48 = p46:_Reparameterize(p48);
	return p46:SolveLength(p47, p48);
end;
function v2.SolveUniformRotCFrame(p49, p50)
	p50 = p49:_Reparameterize(p50);
	return p49:SolveRotCFrame(p50);
end;
return v2;

