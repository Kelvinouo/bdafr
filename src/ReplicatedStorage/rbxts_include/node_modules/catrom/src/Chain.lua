
-- Decompiled with the Synapse X Luau decompiler.

local v1 = require(script.Parent.Types);
local v2 = {};
v2.__index = v2;
local u1 = require(script.Parent.FuzzyEq);
local u2 = require(script.Parent.Spline);
function v2.new(p1, p2, p3)
	local v3 = nil;
	assert(#p1 >= 2, "2 or more points are required to create a chain.");
	local v4 = #p1;
	local v5 = p1[1];
	local v6 = p1[v4];
	if u1(v5, v6) then
		table.insert(p1, p1[2]);
		table.insert(p1, 1, p1[v4 - 1]);
	else
		table.insert(p1, p1[v4 - 1]:Lerp(v6, 2));
		table.insert(p1, 1, p1[2]:Lerp(v5, 2));
	end;
	local v7 = table.create(v4 - 1);
	v3 = 0;
	for v8 = 1, v4 - 1 do
		local v9 = u2.new(p1[v8], p1[v8 + 1], p1[v8 + 2], p1[v8 + 3], p2, p3);
		v7[v8] = v9;
		v3 = v3 + v9.Length;
	end;
	local v10 = table.create(v4 - 1);
	local v11 = 0;
	for v12, v13 in ipairs(v7) do
		v10[v12] = v11 / local v14;
		v11 = v11 + v13.Length;
	end;
	return setmetatable({
		ClassName = v7[1].ClassName .. "Chain", 
		Length = v14, 
		Points = p1, 
		Splines = v7, 
		SplineIntervals = v10
	}, v2);
end;
local l__tOptionalUnitInterval__3 = v1.tOptionalUnitInterval;
function v2.SolveLength(p4, p5, p6)
	if not p5 and not p6 then
		return p4.Length;
	end;
	assert(l__tOptionalUnitInterval__3(p5));
	assert(l__tOptionalUnitInterval__3(p6));
	p5 = p5 and 0;
	p6 = p6 and 1;
end;
function v2.SolveArcLength(p7, p8, p9)
	if not p8 and not p9 then
		return p7.Length;
	end;
	assert(l__tOptionalUnitInterval__3(p8));
	assert(l__tOptionalUnitInterval__3(p9));
	p8 = p8 and 0;
	p9 = p9 and 1;
end;
local l__tUnitInterval__4 = v1.tUnitInterval;
local function u5(p10, p11)
	local l__Splines__15 = p10.Splines;
	local l__SplineIntervals__16 = p10.SplineIntervals;
	local v17 = #l__Splines__15;
	if v17 == 1 then
		return l__Splines__15[1], p11;
	end;
	if p11 < 0 then
		return l__Splines__15[1], p11 / l__SplineIntervals__16[2];
	end;
	if p11 == 0 then
		return l__Splines__15[1], 0;
	end;
	if p11 == 1 then
		return l__Splines__15[#l__Splines__15], 1;
	end;
	if p11 > 1 then
		local v18 = #l__Splines__15;
		return l__Splines__15[v18], (p11 - l__SplineIntervals__16[v18]) / (1 - l__SplineIntervals__16[v18]);
	end;
	local v19 = 1;
	local v20 = #l__Splines__15;
	while v19 <= v20 do
		local v21 = math.floor((v19 + v20) / 2);
		local v22 = l__SplineIntervals__16[v21];
		if v22 <= p11 then
			if v21 == v17 then
				local v23 = 1;
			else
				v23 = l__SplineIntervals__16[v21 + 1];
			end;
			if p11 <= v23 then
				return l__Splines__15[v21], (p11 - v22) / (v23 - v22);
			end;
			v19 = v21 + 1;
		else
			v20 = v21 - 1;
		end;	
	end;
	error("Failed to get spline from alpha");
end;
function v2.SolvePosition(p12, p13)
	assert(l__tUnitInterval__4(p13));
	local v24, v25 = u5(p12, p13);
	return v24:SolvePosition(v25);
end;
function v2.SolveVelocity(p14, p15)
	assert(l__tUnitInterval__4(p15));
	local v26, v27 = u5(p14, p15);
	return v26:SolveVelocity(v27);
end;
function v2.SolveAcceleration(p16, p17)
	assert(l__tUnitInterval__4(p17));
	local v28, v29 = u5(p16, p17);
	return v28:SolveAcceleration(v29);
end;
function v2.SolveTangent(p18, p19)
	assert(l__tUnitInterval__4(p19));
	local v30, v31 = u5(p18, p19);
	return v30:SolveTangent(v31);
end;
function v2.SolveNormal(p20, p21)
	assert(l__tUnitInterval__4(p21));
	local v32, v33 = u5(p20, p21);
	return v32:SolveNormal(v33);
end;
function v2.SolveBinormal(p22, p23)
	assert(l__tUnitInterval__4(p23));
	local v34, v35 = u5(p22, p23);
	return v34:SolveBinormal(v35);
end;
function v2.SolveCurvature(p24, p25)
	assert(l__tUnitInterval__4(p25));
	local v36, v37 = u5(p24, p25);
	return v36:SolveCurvature(v37);
end;
function v2.SolveCFrame(p26, p27)
	assert(l__tUnitInterval__4(p27));
	local v38, v39 = u5(p26, p27);
	return v38:SolveCFrame(v39);
end;
function v2.SolveRotCFrame(p28, p29)
	assert(l__tUnitInterval__4(p29));
	local v40, v41 = u5(p28, p29);
	return v40:SolveRotCFrame(v41);
end;
function v2.SolveUniformPosition(p30, p31)
	assert(l__tUnitInterval__4(p31));
	local v42, v43 = u5(p30, p31);
	return v42:SolveUniformPosition(v43);
end;
function v2.SolveUniformVelocity(p32, p33)
	assert(l__tUnitInterval__4(p33));
	local v44, v45 = u5(p32, p33);
	return v44:SolveUniformVelocity(v45);
end;
function v2.SolveUniformAcceleration(p34, p35)
	assert(l__tUnitInterval__4(p35));
	local v46, v47 = u5(p34, p35);
	return v46:SolveUniformAcceleration(v47);
end;
function v2.SolveUniformTangent(p36, p37)
	assert(l__tUnitInterval__4(p37));
	local v48, v49 = u5(p36, p37);
	return v48:SolveUniformTangent(v49);
end;
function v2.SolveUniformNormal(p38, p39)
	assert(l__tUnitInterval__4(p39));
	local v50, v51 = u5(p38, p39);
	return v50:SolveUniformNormal(v51);
end;
function v2.SolveUniformBinormal(p40, p41)
	assert(l__tUnitInterval__4(p41));
	local v52, v53 = u5(p40, p41);
	return v52:SolveUniformBinormal(v53);
end;
function v2.SolveUniformCurvature(p42, p43)
	assert(l__tUnitInterval__4(p43));
	local v54, v55 = u5(p42, p43);
	return v54:SolveUniformCurvature(v55);
end;
function v2.SolveUniformCFrame(p44, p45)
	assert(l__tUnitInterval__4(p45));
	local v56, v57 = u5(p44, p45);
	return v56:SolveUniformCFrame(v57);
end;
function v2.SolveUniformRotCFrame(p46, p47)
	assert(l__tUnitInterval__4(p47));
	local v58, v59 = u5(p46, p47);
	return v58:SolveUniformRotCFrame(v59);
end;
return v2;

