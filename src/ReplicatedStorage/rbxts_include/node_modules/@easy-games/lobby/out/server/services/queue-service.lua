-- Decompiled with the Synapse X Luau decompiler.

local v1 = _G[script];
local l__Reflect__2 = v1.import(script, v1.getModule(script, "@flamework", "core").out).Reflect;
local v3 = v1.import(script, v1.getModule(script, "@flamework", "core").out);
local v4 = v1.import(script, v1.getModule(script, "@rbxts", "services"));
local v5 = setmetatable({}, {
	__tostring = function()
		return "QueueService";
	end
});
v5.__index = v5;
function v5.new(...)
	local v6 = setmetatable({}, v5);
	return v6:constructor(...) and v6;
end;
local u1 = v1.import(script, v1.getModule(script, "@rbxts", "mock-memory-store-service").lib);
function v5.constructor(p1, p2, p3, p4, p5, p6)
	p1.playfabService = p2;
	p1.matchmakingService = p3;
	p1.gameTeleportService = p4;
	p1.notificationService = p5;
	p1.playerLocationService = p6;
	p1.Name = "QueueService";
	p1.Client = {};
	p1.reservingMatchAccessCodes = {};
	p1.matchConfigStore = u1:GetSortedMap("LobbyMatchConfig");
	p1.serverAccessCodes = u1:GetSortedMap("server_access_codes");
end;
function v5.onStart(p7)
	p7.matchmakingService:registerMatchFoundObserver(function(p8, p9, p10)
		return p7:onMatchFoundForParty(p8, p9, p10);
	end);
end;
local l__LobbyServerSyncEvents__2 = v1.import(script, script.Parent.Parent, "events", "events").LobbyServerSyncEvents;
local l__QueueState__3 = v1.import(script, script.Parent.Parent.Parent, "shared", "party", "queue-state").QueueState;
local u4 = v1.import(script, v1.getModule(script, "@rbxts", "inspect").inspect);
v5.joinQueue = v1.async(function(p11, p12, p13)
	local v7 = p12:getLeader();
	if v7 and v1.await(p11.playfabService:getPlayerSession(v7)) then
		if l__LobbyServerSyncEvents__2.PartyJoinQueue:fire(p12, p13):isCancelled() then
			return false;
		end;
		local v8 = p12:getPlayers();
		local v9 = v1.async(function(p14)
			return v1.await(p11.playfabService:getPlayerSession(p14));
		end);
		local v10 = {};
		local v11 = 0;
		for v12, v13 in ipairs(v8) do
			local v14 = v9(v13, v12 - 1, v8);
			if v14 ~= nil then
				v11 = v11 + 1;
				v10[v11] = v14;
			end;
		end;
		v1.await(p11.matchmakingService:bulkCancelMatchmakingTickets(v1.await(v1.Promise.all(v10)), p13));
		p12:setQueueState(l__QueueState__3.JOINING_QUEUE);
		p12:sendPartyInfoEvent();
		local v15, v16 = v1.try(function()
			local v17 = v1.await(p11.matchmakingService:createMatchmakingTicketForParty(p12, p13));
			if not v17 then
				error("Missing matchResult");
			end;
			print("[Queue]: " .. v7.Name .. " joined queue \"" .. p13 .. "\"");
			p12:setQueueData({
				ticketId = v17.TicketId, 
				queueType = p13, 
				joinTime = os.time(), 
				pollAttempts = 0, 
				lastPollTime = 0
			});
			p12:setQueueState(l__QueueState__3.IN_QUEUE);
			p12:sendPartyInfoEvent();
			return v1.TRY_RETURN, { true };
		end, function(p15)
			p11.notificationService:sendErrorNotification({ v7 }, {
				message = "Failed to join the queue. Please try again."
			});
			p12:setQueueData(nil);
			p12:setQueueState(l__QueueState__3.NONE);
			p12:sendPartyInfoEvent();
			warn("Failed to join queue:", u4(p15));
		end);
		if v15 then
			return unpack(v16);
		end;
	end;
	return false;
end);
v5.leaveQueue = v1.async(function(p16, p17, p18)
	if p18 == nil then
		p18 = false;
	end;
	local v18 = p17:getQueueData();
	if v18 then
		local v19 = p17:getPlayers();
		local v20 = v1.async(function(p19)
			return v1.await(p16.playfabService:getPlayerSession(p19));
		end);
		local v21 = {};
		local v22 = 0;
		for v23, v24 in ipairs(v19) do
			local v25 = v20(v24, v23 - 1, v19);
			if v25 ~= nil then
				v22 = v22 + 1;
				v21[v22] = v25;
			end;
		end;
		v1.await(p16.matchmakingService:bulkCancelMatchmakingTickets(v1.await(v1.Promise.all(v21)), v18.queueType));
		p17:setQueueData(nil);
		p17:setQueueState(l__QueueState__3.NONE);
		p17:sendPartyInfoEvent();
		l__LobbyServerSyncEvents__2.PartyLeaveQueue:fire(p17, v18.queueType, p18);
	end;
end);
local l__AnalyticsService__5 = v4.AnalyticsService;
function v5.logMatchFound(p20, p21)
	l__AnalyticsService__5:FireCustomEvent(nil, "Teleport_To_Match", {
		party = p21:getPlayers(), 
		partySize = #p21:getPlayers()
	});
end;
local l__TeleportService__6 = v4.TeleportService;
local u7 = v1.import(script, v1.getModule(script, "@rbxts", "make"));
v5.onMatchFoundForParty = v1.async(function(p22, p23, p24, p25)
	local v26 = p23:getLeader();
	local v27 = p23:getQueueData();
	if not v27 then
		return nil;
	end;
	p23:setQueueState(l__QueueState__3.MATCH_FOUND);
	p23:sendPartyInfoEvent();
	local v28 = p23:getPlayers();
	local v29 = v1.async(function(p26)
		return v1.await(p22.playfabService:getPlayerSession(p26));
	end);
	local v30 = {};
	local v31 = 0;
	for v32, v33 in ipairs(v28) do
		local v34 = v29(v33, v32 - 1, v28);
		if v34 ~= nil then
			v31 = v31 + 1;
			v30[v31] = v34;
		end;
	end;
	local v35 = v1.async(function(p27)
		return v1.await(p27).Entity.Id;
	end);
	local v36 = table.create(#v30);
	for v37, v38 in ipairs(v30) do
		v36[v37] = v35(v38, v37 - 1, v30);
	end;
	local v39 = v1.await(v1.Promise.all(v36));
	local u8 = false;
	v1.Promise.defer(function()
		wait(12);
		if not u8 and p23:getQueueState() == l__QueueState__3.MATCH_FOUND then
			p22:joinQueue(p23, v27.queueType);
		end;
	end);
	print("[Queue]: Leader entity:", p25.Members[1].Entity.Id);
	if table.find(v39, p25.Members[1].Entity.Id) ~= nil then
		if p22.reservingMatchAccessCodes[p24] ~= nil then
			print("[Queue]: Already reserving match server " .. p24 .. ". Skipping..");
			return nil;
		end;
		p22.reservingMatchAccessCodes[p24] = true;
		local v40 = p22.gameTeleportService:getGamePlaceIdForQueueType(v27.queueType);
		local v41, v42 = l__TeleportService__6:ReserveServer(v40);
		task.spawn(function()
			p22:saveServerAccessCode(p24, v41);
			p22.reservingMatchAccessCodes[p24] = nil;
			for v43, v44 in ipairs(p23:getPlayers()) do
				p22.playerLocationService:registerPlayer(v44, v40, v41);
			end;
		end);
		local v45 = u7("TeleportOptions", {
			ReservedServerAccessCode = v41
		});
		local v46 = p22:getMatchTeleportData(v27.queueType, p25, v26.UserId, #p23:getPlayers());
		v45:SetTeleportData(v46);
		p22.matchConfigStore:SetAsync(v42, v46, 180);
		if v1.await(p22.gameTeleportService:teleportRetry(p22.gameTeleportService:getGamePlaceIdForQueueType(v27.queueType), p23:getPlayers(), v45)) then
			p22:logMatchFound(p23);
		else
			print("[Queue]: Failed final teleport for match leader:", v26);
		end;
	else
		local v47 = p22:getServerAccessCode(p24);
		if v47 == nil then
			local v48 = 0;
			local v49 = 2;
			if v48 > 2 then
				v49 = 4;
			end;
			while v47 == nil and p23:getLeader().Parent ~= nil and v48 < 10 and { wait(v49) } do
				print("[Queue]: Retrying access code fetch (" .. tostring(v48 + 1) .. ")");
				v47 = p22:getServerAccessCode(p24);
				v48 = v48 + 1;			
			end;
		end;
		if v47 ~= "" and v47 then
			print("[Queue]: Found server access code: " .. v47);
			local v50 = u7("TeleportOptions", {
				ReservedServerAccessCode = v47
			});
			v50:SetTeleportData(p22:getMatchTeleportData(v27.queueType, p25, v26.UserId, #p23:getPlayers()));
			local u9 = p22.gameTeleportService:getGamePlaceIdForQueueType(v27.queueType);
			task.spawn(function()
				for v51, v52 in ipairs(p23:getPlayers()) do
					p22.playerLocationService:registerPlayer(v52, u9, v47);
				end;
			end);
			v1.await(p22.gameTeleportService:teleportRetry(u9, p23:getPlayers(), v50));
			p22:logMatchFound(p23);
			u8 = true;
		else
			warn("[Queue]: Failed to find server access code for Party " .. p23:getLeader().Name);
		end;
	end;
end);
function v5.getMatchTeleportData(p28, p29, p30, p31, p32)
	return {
		match = {
			matchId = p30.MatchId, 
			queueType = p29, 
			teamLeaderUserId = p31
		}, 
		party = {
			leaderUserId = p31, 
			partySize = p32
		}
	};
end;
function v5.getServerAccessCode(p33, p34)
	if not p33.serverAccessCodes then
		return "offline";
	end;
	return p33.serverAccessCodes:GetAsync(p34);
end;
function v5.saveServerAccessCode(p35, p36, p37)
	if p35.serverAccessCodes then
		p35.serverAccessCodes:SetAsync(p36, p37, 30);
	end;
end;
function v5.downloadMatchConfig(p38)
	return p38.matchConfigStore:GetAsync(game.PrivateServerId);
end;
function v5.uploadMatchConfig(p39, p40, p41)
	return p39.matchConfigStore:SetAsync(p40, p41, 180);
end;
l__Reflect__2.defineMetadata(v5, "identifier", "@easy-games/lobby:server/services/queue-service@QueueService");
l__Reflect__2.defineMetadata(v5, "flamework:parameters", { "@easy-games/lobby:server/services/playfab-service@PlayFabService", "@easy-games/lobby:server/services/matchmaking-service@MatchmakingService", "@easy-games/lobby:server/services/game-teleport-service@GameTeleportService", "@easy-games/game-core:server/services/notification-service@NotificationService", "@easy-games/lobby:server/services/player-location-service@PlayerLocationService" });
l__Reflect__2.defineMetadata(v5, "flamework:implements", { "$:flamework@OnStart" });
l__Reflect__2.decorate(v5, "$:flamework@Service", v3.Service, {});
l__Reflect__2.decorate(v5, "$:flamework@External", v3.External, {});
return {
	QueueService = v5
};
