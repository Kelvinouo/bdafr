-- Decompiled with the Synapse X Luau decompiler.

local v1 = _G[script];
local l__Reflect__2 = v1.import(script, v1.getModule(script, "@flamework", "core").out).Reflect;
local v3 = v1.import(script, v1.getModule(script, "@flamework", "core").out);
local v4 = v1.import(script, v1.getModule(script, "@rbxts", "services"));
local v5 = setmetatable({}, {
	__tostring = function()
		return "QueueService";
	end
});
v5.__index = v5;
function v5.new(...)
	local v6 = setmetatable({}, v5);
	return v6:constructor(...) and v6;
end;
local u1 = v1.import(script, v1.getModule(script, "@rbxts", "mock-memory-store-service").lib);
local l__DataStoreService__2 = v4.DataStoreService;
function v5.constructor(p1, p2, p3, p4, p5, p6)
	p1.playfabService = p2;
	p1.matchmakingService = p3;
	p1.gameTeleportService = p4;
	p1.notificationService = p5;
	p1.playerLocationService = p6;
	p1.Name = "QueueService";
	p1.Client = {};
	p1.reservingMatchAccessCodes = {};
	p1.matchConfigStore = u1:GetSortedMap("LobbyMatchConfig");
	p1.accessCodeDataStoreFallback = l__DataStoreService__2:GetDataStore("server_access_codes");
end;
function v5.onStart(p7)
	p7.matchmakingService:registerMatchFoundObserver(function(p8, p9, p10)
		return p7:onMatchFoundForParty(p8, p9, p10);
	end);
end;
local l__LobbyServerSyncEvents__3 = v1.import(script, script.Parent.Parent, "events", "events").LobbyServerSyncEvents;
local l__QueueState__4 = v1.import(script, script.Parent.Parent.Parent, "shared", "party", "queue-state").QueueState;
local u5 = v1.import(script, v1.getModule(script, "@rbxts", "inspect").inspect);
v5.joinQueue = v1.async(function(p11, p12, p13)
	local v7 = p12:getLeader();
	if v7 then
		local v8 = v1.await(p11.playfabService:getPlayerSession(v7));
		if v8 then
			if l__LobbyServerSyncEvents__3.PartyJoinQueue:fire(p12, p13):isCancelled() then
				return false;
			end;
			v1.await(p11.matchmakingService:bulkCancelMatchmakingTickets({ v8 }, p13));
			p12:setQueueState(l__QueueState__4.JOINING_QUEUE);
			p12:sendPartyInfoEvent();
			local v9, v10 = v1.try(function()
				local v11 = v1.await(p11.matchmakingService:createMatchmakingTicketForParty(p12, p13));
				if not v11 then
					error("Missing matchResult");
				end;
				print("[Queue]: " .. v7.Name .. " joined queue \"" .. p13 .. "\"");
				p12:setQueueData({
					ticketId = v11.TicketId, 
					queueType = p13, 
					joinTime = os.time(), 
					pollAttempts = 0, 
					lastPollTime = 0
				});
				p12:setQueueState(l__QueueState__4.IN_QUEUE);
				p12:sendPartyInfoEvent();
				return v1.TRY_RETURN, { true };
			end, function(p14)
				p11.notificationService:sendErrorNotification({ v7 }, {
					message = "Failed to join the queue. Please try again."
				});
				p12:setQueueData(nil);
				p12:setQueueState(l__QueueState__4.NONE);
				p12:sendPartyInfoEvent();
				warn("Failed to join queue:", u5(p14));
			end);
			if v9 then
				return unpack(v10);
			end;
		end;
	end;
	return false;
end);
v5.leaveQueue = v1.async(function(p15, p16, p17)
	if p17 == nil then
		p17 = false;
	end;
	local v12 = p16:getQueueData();
	if v12 then
		local v13 = v1.await(p15.playfabService:getPlayerSession(p16:getLeader()));
		if v13 then
			v1.await(p15.matchmakingService:bulkCancelMatchmakingTickets({ v13 }, v12.queueType));
		end;
		p16:setQueueData(nil);
		p16:setQueueState(l__QueueState__4.NONE);
		p16:sendPartyInfoEvent();
		l__LobbyServerSyncEvents__3.PartyLeaveQueue:fire(p16, v12.queueType, p17);
	end;
end);
local l__AnalyticsService__6 = v4.AnalyticsService;
function v5.logMatchFound(p18, p19)
	l__AnalyticsService__6:FireCustomEvent(nil, "Teleport_To_Match", {
		party = p19:getPlayers(), 
		partySize = #p19:getPlayers()
	});
end;
local l__TeleportService__7 = v4.TeleportService;
local u8 = v1.import(script, v1.getModule(script, "@rbxts", "make"));
v5.onMatchFoundForParty = v1.async(function(p20, p21, p22, p23)
	local v14 = p21:getLeader();
	local v15 = p21:getQueueData();
	if not v15 then
		return nil;
	end;
	p21:setQueueState(l__QueueState__4.MATCH_FOUND);
	p21:sendPartyInfoEvent();
	local v16 = p21:getPlayers();
	local v17 = v1.async(function(p24)
		return v1.await(p20.playfabService:getPlayerSession(p24));
	end);
	local v18 = {};
	local v19 = 0;
	local v20, v21, v22 = ipairs(v16);
	while true do
		v20(v21, v22);
		if not v20 then
			break;
		end;
		v22 = v20;
		local v23 = v17(v21, v20 - 1, v16);
		if v23 ~= nil then
			v19 = v19 + 1;
			v18[v19] = v23;
		end;	
	end;
	local v24 = v1.async(function(p25)
		return v1.await(p25).Entity.Id;
	end);
	local v25 = table.create(#v18);
	local v26, v27, v28 = ipairs(v18);
	while true do
		v26(v27, v28);
		if not v26 then
			break;
		end;
		v28 = v26;
		v25[v26] = v24(v27, v26 - 1, v18);	
	end;
	local v29 = v1.await(v1.Promise.all(v25));
	local u9 = false;
	v1.Promise.defer(function()
		wait(22);
		if not u9 and p21:getQueueState() == l__QueueState__4.MATCH_FOUND then
			p20:joinQueue(p21, v15.queueType);
		end;
	end);
	print("[Queue]: Leader entity:", p23.Members[1].Entity.Id);
	if table.find(v29, p23.Members[1].Entity.Id) ~= nil then
		if p20.reservingMatchAccessCodes[p22] ~= nil then
			print("[Queue]: Already reserving match server " .. p22 .. ". Skipping..");
			return nil;
		end;
		p20.reservingMatchAccessCodes[p22] = true;
		local v30 = p20.gameTeleportService:getGamePlaceIdForQueueType(v15.queueType);
		local v31, v32 = l__TeleportService__7:ReserveServer(v30);
		task.spawn(function()
			p20:saveServerAccessCode(p22, v31);
			p20.reservingMatchAccessCodes[p22] = nil;
			local v33, v34, v35 = ipairs(p21:getPlayers());
			while true do
				v33(v34, v35);
				if not v33 then
					break;
				end;
				v35 = v33;
				p20.playerLocationService:registerPlayer(v34, v30, v31);			
			end;
		end);
		local v36 = u8("TeleportOptions", {
			ReservedServerAccessCode = v31
		});
		local v37 = p20:getMatchTeleportData(v15.queueType, p23, v14.UserId, #p21:getPlayers());
		v36:SetTeleportData(v37);
		p20.matchConfigStore:SetAsync(v32, v37, 180);
		if v1.await(p20.gameTeleportService:teleportRetry(p20.gameTeleportService:getGamePlaceIdForQueueType(v15.queueType), p21:getPlayers(), v36)) then
			p20:logMatchFound(p21);
		else
			print("[Queue]: Failed final teleport for match leader:", v14);
		end;
	else
		local v38 = p20:getServerAccessCode(p22);
		if v38 == nil then
			local v39 = 0;
			while v38 == nil and p21:getLeader().Parent ~= nil and v39 < 5 and { wait(2) } do
				print("[Queue]: Retrying access code fetch (" .. tostring(v39 + 1) .. ")");
				v38 = p20:getServerAccessCode(p22);
				v39 = v39 + 1;			
			end;
			if v38 == "" or not v38 then
				v38 = p20:getServerAccessCode(p22, true);
			end;
		end;
		if v38 ~= "" and v38 then
			print("[Queue]: Found server access code: " .. v38);
			local v40 = u8("TeleportOptions", {
				ReservedServerAccessCode = v38
			});
			v40:SetTeleportData(p20:getMatchTeleportData(v15.queueType, p23, v14.UserId, #p21:getPlayers()));
			local u10 = p20.gameTeleportService:getGamePlaceIdForQueueType(v15.queueType);
			task.spawn(function()
				local v41, v42, v43 = ipairs(p21:getPlayers());
				while true do
					v41(v42, v43);
					if not v41 then
						break;
					end;
					v43 = v41;
					p20.playerLocationService:registerPlayer(v42, u10, v38);				
				end;
			end);
			v1.await(p20.gameTeleportService:teleportRetry(u10, p21:getPlayers(), v40));
			p20:logMatchFound(p21);
			u9 = true;
		else
			warn("[Queue]: Failed to find server access code for Party " .. p21:getLeader().Name);
		end;
	end;
end);
function v5.getMatchTeleportData(p26, p27, p28, p29, p30)
	return {
		match = {
			matchId = p28.MatchId, 
			queueType = p27, 
			teamLeaderUserId = p29
		}, 
		party = {
			leaderUserId = p29, 
			partySize = p30
		}
	};
end;
function v5.getServerAccessCode(p31, p32, p33)
	if p33 == nil then
		p33 = false;
	end;
	if p33 then
		local v44, v45 = v1.try(function()
			return v1.TRY_RETURN, { p31.accessCodeDataStoreFallback:GetAsync(p32) };
		end, function(p34)
			warn("[QueueService] Failed to fetch datastore access code:\n" .. tostring(p34));
		end);
		if v44 then
			return unpack(v45);
		else
			return nil;
		end;
	end;
	local v46, v47 = v1.try(function()
		return v1.TRY_RETURN, { (p31:getAccessCodeMemoryStore(p32):GetAsync(p32)) };
	end, function(p35)
		warn("[QueueService] Failed to fetch access code:\n" .. tostring(p35));
	end);
	if not v46 then
		return nil;
	end;
	return unpack(v47);
end;
function v5.saveServerAccessCode(p36, p37, p38)
	v1.try(function()
		p36:getAccessCodeMemoryStore(p37):SetAsync(p37, p38, 30);
	end, function(p39)
		warn("[QueueService] Failed to save access code:\n" .. tostring(p39));
		p36.accessCodeDataStoreFallback:SetAsync(p37, p38);
	end);
end;
function v5.downloadMatchConfig(p40)
	return p40.matchConfigStore:GetAsync(game.PrivateServerId);
end;
function v5.uploadMatchConfig(p41, p42, p43)
	return p41.matchConfigStore:SetAsync(p42, p43, 180);
end;
function v5.getAccessCodeMemoryStore(p44, p45)
	local v48 = tonumber(string.sub(p45, 0, 5), 16);
	if v48 == nil then
		v48 = 0;
	end;
	return u1:GetSortedMap("server_access_codes_" .. tostring(v48 % 10));
end;
l__Reflect__2.defineMetadata(v5, "identifier", "@easy-games/lobby:server/services/queue-service@QueueService");
l__Reflect__2.defineMetadata(v5, "flamework:parameters", { "@easy-games/lobby:server/services/playfab-service@PlayFabService", "@easy-games/lobby:server/services/matchmaking-service@MatchmakingService", "@easy-games/lobby:server/services/game-teleport-service@GameTeleportService", "@easy-games/game-core:server/services/notification-service@NotificationService", "@easy-games/lobby:server/services/player-location-service@PlayerLocationService" });
l__Reflect__2.defineMetadata(v5, "flamework:implements", { "$:flamework@OnStart" });
l__Reflect__2.decorate(v5, "$:flamework@Service", v3.Service, {});
l__Reflect__2.decorate(v5, "$:flamework@External", v3.External, {});
return {
	QueueService = v5
};
