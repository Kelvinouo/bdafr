-- Decompiled with the Synapse X Luau decompiler.

local v1 = {
	Tau = 0.5, 
	InitialVolatility = 0.06
};
v1.__index = v1;
function v1.gv(p1, p2, p3, p4)
	return setmetatable({
		Rating = p1, 
		RD = p2, 
		Vol = p3 or v1.InitialVolatility, 
		Version = p4 and 2
	}, v1);
end;
function v1.g1(p5, p6, p7)
	return v1.gv(p5 and 1500, p6 and 350, p7, 1);
end;
function v1.g2(p8, p9, p10)
	return v1.gv(p8 and 0, p9 and 2.014761872416068, p10, 2);
end;
function v1.copy(p11)
	return v1.gv(p11.Rating, p11.RD, p11.Vol, p11.Version);
end;
function v1.to2(p12)
	if p12.Version == 2 then
		local v2 = p12:copy();
		v2.Score = p12.Score;
		return v2;
	end;
	local v3 = v1.g2((p12.Rating - 1500) / 173.7178, p12.RD / 173.7178, p12.Vol);
	if p12.Score then
		v3.Score = p12.Score;
	end;
	return v3;
end;
function v1.to1(p13)
	if p13.Version == 1 then
		local v4 = p13:copy();
		v4.Score = p13.Score;
		return v4;
	end;
	local v5 = v1.g1(p13.Rating * 173.7178 + 1500, p13.RD * 173.7178, p13.Vol);
	if p13.Score then
		v5.Score = p13.Score;
	end;
	return v5;
end;
function v1.serialize(p14)
	return { p14.Rating, p14.RD, p14.Vol, p14.Score };
end;
function v1.deserialize(p15, p16)
	local v6 = nil;
	if p16 == 1 then
		v6 = v1.g1;
	elseif p16 == 2 then
		v6 = v1.g2;
	else
		error("Version must be specified for deserialization", 2);
	end;
	local v7 = v6(p15[1], p15[2], p15[3]);
	if p15[4] then
		v7 = v7:score(p15[4]);
	end;
	return v7;
end;
function v1.score(p17, p18)
	local v8 = p17:copy();
	v8.Score = p18 and 0;
	return v8;
end;
local l__math_sqrt__1 = math.sqrt;
local l__math_exp__2 = math.exp;
local l__math_log__3 = math.log;
function v1.update(p19, p20)
	local v9 = p19;
	local l__Version__10 = v9.Version;
	if l__Version__10 == 1 then
		v9 = v9:to2();
	end;
	for v11, v12 in ipairs(p20) do
		if v12.Version == 1 then
			p20[v11] = v12:to2();
		end;
	end;
	local v13 = 0;
	for v14, v15 in ipairs(p20) do
		local v16 = 1 / (1 + l__math_exp__2(-(1 / l__math_sqrt__1(1 + 3 * v15.RD ^ 2 / math.pi ^ 2)) * (v9.Rating - v15.Rating)));
		v13 = v13 + (1 / l__math_sqrt__1(1 + 3 * v15.RD ^ 2 / math.pi ^ 2)) ^ 2 * v16 * (1 - v16);
	end;
	local v17 = 1 / v13;
	local v18 = 0;
	for v19, v20 in ipairs(p20) do
		v18 = v18 + 1 / l__math_sqrt__1(1 + 3 * v20.RD ^ 2 / math.pi ^ 2) * (v20.Score - 1 / (1 + l__math_exp__2(-(1 / l__math_sqrt__1(1 + 3 * v20.RD ^ 2 / math.pi ^ 2)) * (v9.Rating - v20.Rating))));
	end;
	local v21 = v18 * v17;
	local v22 = l__math_log__3(v9.Vol ^ 2);
	local u4 = v21;
	local u5 = v9;
	local u6 = v17;
	local u7 = l__math_log__3(v9.Vol ^ 2);
	local function v23(p21)
		return l__math_exp__2(p21) * (u4 ^ 2 - u5.RD ^ 2 - u6 - l__math_exp__2(p21)) / (2 * (u5.RD ^ 2 + u6 + l__math_exp__2(p21)) ^ 2) - (p21 - u7) / v1.Tau ^ 2;
	end;
	u5 = v22;
	u6 = 0;
	u4 = v21 ^ 2;
	u7 = v9.RD ^ 2 + v17;
	if u7 < u4 then
		u7 = v21 ^ 2 - v9.RD ^ 2 - v17;
		u4 = l__math_log__3;
		u4 = u4(u7);
		u6 = u4;
	else
		u4 = 1;
		while true do
			u7 = v23;
			u7 = u7(v22 - u4 * v1.Tau);
			if not (u7 < 0) then
				break;
			end;
			u4 = u4 + 1;		
		end;
		u7 = u4 * v1.Tau;
		u6 = v22 - u7;
	end;
	u4 = v23;
	u7 = u5;
	u4 = u4(u7);
	u7 = v23;
	u7 = u7(u6);
	while math.abs(u6 - u5) > 1E-06 do
		local v24 = u5 + (u5 - u6) * u4 / (u7 - u4);
		local v25 = v23(v24);
		if v25 * u7 < 0 then
			u5 = u6;
			u4 = u7;
		else
			u4 = u4 / 2;
		end;
		u6 = v24;
		u7 = v25;	
	end;
	local v26 = v9.Vol;
	if #p20 > 0 then
		v26 = l__math_exp__2(u5 / 2);
	end;
	local v27 = l__math_sqrt__1(v9.RD ^ 2 + v26 ^ 2);
	local v28 = v9.Rating;
	if #p20 > 0 then
		v27 = 1 / l__math_sqrt__1(1 / v27 ^ 2 + 1 / v17);
		local v29 = 0;
		for v30, v31 in ipairs(p20) do
			v29 = v29 + 1 / l__math_sqrt__1(1 + 3 * v31.RD ^ 2 / math.pi ^ 2) * (v31.Score - 1 / (1 + l__math_exp__2(-(1 / l__math_sqrt__1(1 + 3 * v31.RD ^ 2 / math.pi ^ 2)) * (v9.Rating - v31.Rating))));
		end;
		v28 = v9.Rating + v27 ^ 2 * v29;
	end;
	local v32 = v1.g2(v28, v27, v26);
	if l__Version__10 == 1 then
		v32 = v32:to1();
	end;
	return v32;
end;
function v1.deviation(p22, p23)
	p23 = p23 and 2;
	local v33 = p22.RD * p23;
	return p22.Rating - v33, p22.Rating + v33;
end;
function v1.range(p24, p25)
	p25 = p25 and 0;
	local v34, v35 = p24:deviation();
	return v34 - p25, v35 + p25;
end;
function v1.percent(p26, p27)
	p27 = math.clamp(p27, 0, 1);
	assert(p27 < 1, "Percentage cannot be equal or greater than 1");
	return p26:deviation(0.5877 * math.log((1 + p27) / (1 - p27)));
end;
return {
	Glicko2 = v1
};
