-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
local function u1(p1)
	assert(type(p1) == "table", "First argument must be a table");
	local v2 = table.create(#p1);
	for v3, v4 in pairs(p1) do
		if type(v4) == "table" then
			v2[v3] = u1(v4);
		else
			v2[v3] = v4;
		end;
	end;
	return v2;
end;
local function u2(p2, p3)
	assert(type(p2) == "table", "First argument must be a table");
	assert(type(p3) == "table", "Second argument must be a table");
	for v5, v6 in pairs(p2) do
		local v7 = p3[v5];
		if v7 == nil then
			p2[v5] = nil;
		elseif type(v6) ~= type(v7) then
			if type(v7) == "table" then
				p2[v5] = u1(v7);
			else
				p2[v5] = v7;
			end;
		elseif type(v6) == "table" then
			u2(v6, v7);
		end;
	end;
	for v8, v9 in pairs(p3) do
		if p2[v8] == nil then
			if type(v9) == "table" then
				p2[v8] = u1(v9);
			else
				p2[v8] = v9;
			end;
		end;
	end;
end;
local l__HttpService__3 = game:GetService("HttpService");
local l__table_find__4 = table.find;
v1.Copy = u1;
function v1.CopyShallow(p4)
	local v10 = table.create(#p4);
	for v11, v12 in pairs(p4) do
		v10[v11] = v12;
	end;
	return v10;
end;
v1.Sync = u2;
function v1.FastRemove(p5, p6)
	local v13 = #p5;
	p5[p6] = p5[v13];
	p5[v13] = nil;
end;
function v1.FastRemoveFirstValue(p7, p8)
	local v14 = l__table_find__4(p7, p8);
	if not v14 then
		return false, nil;
	end;
	local v15 = #p7;
	p7[v14] = p7[v15];
	p7[v15] = nil;
	return true, v14;
end;
function v1.Print(p9, p10, p11)
	local v16 = p9;
	assert(type(v16) == "table", "First argument must be a table");
	local v17 = true;
	if p10 ~= nil then
		v16 = p10;
		v17 = type(v16) == "string";
	end;
	assert(v17, "Second argument must be a string or nil");
	p10 = p10 and "TABLE";
	local u5 = {};
	local function u6(p12, p13)
		return tostring(p12.k) < tostring(p13.k);
	end;
	local function u7(p14, p15, p16)
		u5[#u5 + 1] = (" - "):rep(p15 - 1) .. (p16 .. ":") .. "\n";
		local v18 = {};
		local v19 = {};
		local v20 = 0;
		local v21, v22, v23 = pairs(p14);
		while true do
			local v24, v25 = v21(v22, v23);
			if not v24 then
				break;
			end;
			if type(v25) == "table" then
				table.insert(v19, {
					k = v24, 
					v = v25
				});
			else
				table.insert(v18, {
					k = v24, 
					v = "[" .. typeof(v25) .. "] " .. tostring(v25)
				});
			end;
			local v26 = #tostring(v24) + 1;
			if v20 < v26 then
				v20 = v26;
			end;		
		end;
		table.sort(v18, u6);
		table.sort(v19, u6);
		for v27, v28 in ipairs(v18) do
			u5[#u5 + 1] = (" - "):rep(p15) .. (tostring(v28.k) .. ":" .. (" "):rep(v20 - #tostring(v28.k)) .. v28.v) .. "\n";
		end;
		if p11 then
			for v29, v30 in ipairs(v19) do
				u7(v30.v, p15 + 1, tostring(v30.k) .. (" "):rep(v20 - #tostring(v30.k)) .. " [Table]");
			end;
			return;
		end;
		for v31, v32 in ipairs(v19) do
			u5[#u5 + 1] = (" - "):rep(p15) .. (tostring(v32.k) .. ":" .. (" "):rep(v20 - #tostring(v32.k)) .. "[Table]") .. "\n";
		end;
	end;
	u7(p9, 1, p10);
	print(table.concat(u5, ""));
end;
function v1.Map(p17, p18)
	assert(type(p17) == "table", "First argument must be a table");
	assert(type(p18) == "function", "Second argument must be a function");
	local v33 = table.create(#p17);
	for v34, v35 in pairs(p17) do
		v33[v34] = p18(v35, v34, p17);
	end;
	return v33;
end;
function v1.Filter(p19, p20)
	assert(type(p19) == "table", "First argument must be a table");
	assert(type(p20) == "function", "Second argument must be a function");
	local v36 = table.create(#p19);
	if #p19 > 0 then
		for v37, v38 in ipairs(p19) do
			if p20(v38, v37, p19) then
				v36[v37] = v38;
			end;
		end;
		return v36;
	end;
	for v39, v40 in pairs(p19) do
		if p20(v40, v39, p19) then
			v36[v39] = v40;
		end;
	end;
	return v36;
end;
function v1.Reduce(p21, p22, p23)
	assert(type(p21) == "table", "First argument must be a table");
	assert(type(p22) == "function", "Second argument must be a function");
	local v41 = true;
	if p23 ~= nil then
		v41 = type(p23) == "number";
	end;
	assert(v41, "Third argument must be a number or nil");
	local v42 = p23 and 0;
	for v43, v44 in pairs(p21) do
		v42 = p22(v42, v44, v43, p21);
	end;
	return v42;
end;
function v1.Assign(p24, ...)
	for v45, v46 in ipairs({ ... }) do
		for v47, v48 in pairs(v46) do
			p24[v47] = v48;
		end;
	end;
	return p24;
end;
function v1.Extend(p25, p26)
	for v49, v50 in pairs(p26) do
		p25[v49] = v50;
	end;
end;
v1.IndexOf = l__table_find__4;
function v1.Reverse(p27)
	local v51 = #p27;
	local v52 = table.create(v51);
	for v53 = 1, v51 do
		v52[v53] = p27[v51 - v53 + 1];
	end;
	return v52;
end;
function v1.Shuffle(p28)
	assert(type(p28) == "table", "First argument must be a table");
	local v54 = Random.new();
	for v55 = #p28, 2, -1 do
		local v56 = v54:NextInteger(1, v55);
		p28[v55] = p28[v56];
		p28[v56] = p28[v55];
	end;
end;
function v1.IsEmpty(p29)
	return next(p29) == nil;
end;
function v1.EncodeJSON(p30)
	return l__HttpService__3:JSONEncode(p30);
end;
function v1.DecodeJSON(p31)
	return l__HttpService__3:JSONDecode(p31);
end;
return v1;
