-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
local function u1(p1)
	assert(type(p1) == "table", "First argument must be a table");
	local v2 = table.create(#p1);
	for v3, v4 in pairs(p1) do
		if type(v4) == "table" then
			v2[v3] = u1(v4);
		else
			v2[v3] = v4;
		end;
	end;
	return v2;
end;
local function u2(p2, p3)
	assert(type(p2) == "table", "First argument must be a table");
	assert(type(p3) == "table", "Second argument must be a table");
	for v5, v6 in pairs(p2) do
		local v7 = p3[v5];
		if v7 == nil then
			p2[v5] = nil;
		elseif type(v6) ~= type(v7) then
			if type(v7) == "table" then
				p2[v5] = u1(v7);
			else
				p2[v5] = v7;
			end;
		elseif type(v6) == "table" then
			u2(v6, v7);
		end;
	end;
	for v8, v9 in pairs(p3) do
		if p2[v8] == nil then
			if type(v9) == "table" then
				p2[v8] = u1(v9);
			else
				p2[v8] = v9;
			end;
		end;
	end;
end;
local l__HttpService__3 = game:GetService("HttpService");
local l__table_find__4 = table.find;
v1.Copy = u1;
function v1.CopyShallow(p4)
	local v10 = table.create(#p4);
	for v11, v12 in pairs(p4) do
		v10[v11] = v12;
	end;
	return v10;
end;
v1.Sync = u2;
function v1.FastRemove(p5, p6)
	local v13 = #p5;
	p5[p6] = p5[v13];
	p5[v13] = nil;
end;
function v1.FastRemoveFirstValue(p7, p8)
	local v14 = l__table_find__4(p7, p8);
	if not v14 then
		return false, nil;
	end;
	local v15 = #p7;
	p7[v14] = p7[v15];
	p7[v15] = nil;
	return true, v14;
end;
function v1.Print(p9, p10, p11)
	local v16 = p9;
	assert(type(v16) == "table", "First argument must be a table");
	local v17 = true;
	if p10 ~= nil then
		v16 = p10;
		v17 = type(v16) == "string";
	end;
	assert(v17, "Second argument must be a string or nil");
	p10 = p10 and "TABLE";
	local u5 = {};
	local function u6(p12, p13)
		return tostring(p12.k) < tostring(p13.k);
	end;
	local function u7(p14, p15, p16)
		u5[#u5 + 1] = (" - "):rep(p15 - 1) .. (p16 .. ":") .. "\n";
		local v18 = {};
		local v19 = {};
		local v20 = 0;
		local v21, v22, v23 = pairs(p14);
		while true do
			local v24, v25 = v21(v22, v23);
			if not v24 then
				break;
			end;
			if type(v25) == "table" then
				table.insert(v19, {
					k = v24, 
					v = v25
				});
			else
				table.insert(v18, {
					k = v24, 
					v = "[" .. typeof(v25) .. "] " .. tostring(v25)
				});
			end;
			local v26 = #tostring(v24) + 1;
			if v20 < v26 then
				v20 = v26;
			end;		
		end;
		table.sort(v18, u6);
		table.sort(v19, u6);
		local v27, v28, v29 = ipairs(v18);
		while true do
			v27(v28, v29);
			if not v27 then
				break;
			end;
			v29 = v27;
			u5[#u5 + 1] = (" - "):rep(p15) .. (tostring(v28.k) .. ":" .. (" "):rep(v20 - #tostring(v28.k)) .. v28.v) .. "\n";		
		end;
		if p11 then
			local v30, v31, v32 = ipairs(v19);
			while true do
				v30(v31, v32);
				if not v30 then
					break;
				end;
				v32 = v30;
				u7(v31.v, p15 + 1, tostring(v31.k) .. (" "):rep(v20 - #tostring(v31.k)) .. " [Table]");			
			end;
			return;
		end;
		local v33, v34, v35 = ipairs(v19);
		while true do
			v33(v34, v35);
			if not v33 then
				break;
			end;
			v35 = v33;
			u5[#u5 + 1] = (" - "):rep(p15) .. (tostring(v34.k) .. ":" .. (" "):rep(v20 - #tostring(v34.k)) .. "[Table]") .. "\n";		
		end;
	end;
	u7(p9, 1, p10);
	print(table.concat(u5, ""));
end;
function v1.Map(p17, p18)
	assert(type(p17) == "table", "First argument must be a table");
	assert(type(p18) == "function", "Second argument must be a function");
	local v36 = table.create(#p17);
	for v37, v38 in pairs(p17) do
		v36[v37] = p18(v38, v37, p17);
	end;
	return v36;
end;
function v1.Filter(p19, p20)
	assert(type(p19) == "table", "First argument must be a table");
	assert(type(p20) == "function", "Second argument must be a function");
	local v39 = table.create(#p19);
	if #p19 > 0 then
		local v40, v41, v42 = ipairs(p19);
		while true do
			v40(v41, v42);
			if not v40 then
				break;
			end;
			v42 = v40;
			if p20(v41, v40, p19) then
				v39[v40] = v41;
			end;		
		end;
		return v39;
	end;
	for v43, v44 in pairs(p19) do
		if p20(v44, v43, p19) then
			v39[v43] = v44;
		end;
	end;
	return v39;
end;
function v1.Reduce(p21, p22, p23)
	assert(type(p21) == "table", "First argument must be a table");
	assert(type(p22) == "function", "Second argument must be a function");
	local v45 = true;
	if p23 ~= nil then
		v45 = type(p23) == "number";
	end;
	assert(v45, "Third argument must be a number or nil");
	local v46 = p23 and 0;
	for v47, v48 in pairs(p21) do
		v46 = p22(v46, v48, v47, p21);
	end;
	return v46;
end;
function v1.Assign(p24, ...)
	local v49, v50, v51 = ipairs({ ... });
	while true do
		v49(v50, v51);
		if not v49 then
			break;
		end;
		v51 = v49;
		for v52, v53 in pairs(v50) do
			p24[v52] = v53;
		end;	
	end;
	return p24;
end;
function v1.Extend(p25, p26)
	for v54, v55 in pairs(p26) do
		p25[v54] = v55;
	end;
end;
v1.IndexOf = l__table_find__4;
function v1.Reverse(p27)
	local v56 = #p27;
	local v57 = table.create(v56);
	for v58 = 1, v56 do
		v57[v58] = p27[v56 - v58 + 1];
	end;
	return v57;
end;
function v1.Shuffle(p28)
	assert(type(p28) == "table", "First argument must be a table");
	local v59 = Random.new();
	for v60 = #p28, 2, -1 do
		local v61 = v59:NextInteger(1, v60);
		p28[v60] = p28[v61];
		p28[v61] = p28[v60];
	end;
end;
function v1.IsEmpty(p29)
	return next(p29) == nil;
end;
function v1.EncodeJSON(p30)
	return l__HttpService__3:JSONEncode(p30);
end;
function v1.DecodeJSON(p31)
	return l__HttpService__3:JSONDecode(p31);
end;
return v1;
