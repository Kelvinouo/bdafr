-- Script Hash: bc19981a302ee3c77751461e8e7ebb41a8aff0865bf2f77833a79991f5d05eb4f23e02c07faa70add7f6315de1033cb7
-- Decompiled with the Synapse X Luau decompiler.

local v1 = {
	digestLength = 32, 
	blockSize = 64
};
local v2 = table.create(0, 0);
table.insert(v2, 1116352408);
table.insert(v2, 1899447441);
table.insert(v2, 3049323471);
table.insert(v2, 3921009573);
table.insert(v2, 961987163);
table.insert(v2, 1508970993);
table.insert(v2, 2453635748);
table.insert(v2, 2870763221);
table.insert(v2, 3624381080);
table.insert(v2, 310598401);
table.insert(v2, 607225278);
table.insert(v2, 1426881987);
table.insert(v2, 1925078388);
table.insert(v2, 2162078206);
table.insert(v2, 2614888103);
table.insert(v2, 3248222580);
table.insert(v2, 3835390401);
table.insert(v2, 4022224774);
table.insert(v2, 264347078);
table.insert(v2, 604807628);
table.insert(v2, 770255983);
table.insert(v2, 1249150122);
table.insert(v2, 1555081692);
table.insert(v2, 1996064986);
table.insert(v2, 2554220882);
table.insert(v2, 2821834349);
table.insert(v2, 2952996808);
table.insert(v2, 3210313671);
table.insert(v2, 3336571891);
table.insert(v2, 3584528711);
table.insert(v2, 113926993);
table.insert(v2, 338241895);
table.insert(v2, 666307205);
table.insert(v2, 773529912);
table.insert(v2, 1294757372);
table.insert(v2, 1396182291);
table.insert(v2, 1695183700);
table.insert(v2, 1986661051);
table.insert(v2, 2177026350);
table.insert(v2, 2456956037);
table.insert(v2, 2730485921);
table.insert(v2, 2820302411);
table.insert(v2, 3259730800);
table.insert(v2, 3345764771);
table.insert(v2, 3516065817);
table.insert(v2, 3600352804);
table.insert(v2, 4094571909);
table.insert(v2, 275423344);
table.insert(v2, 430227734);
table.insert(v2, 506948616);
table.insert(v2, 659060556);
table.insert(v2, 883997877);
table.insert(v2, 958139571);
table.insert(v2, 1322822218);
table.insert(v2, 1537002063);
table.insert(v2, 1747873779);
table.insert(v2, 1955562222);
table.insert(v2, 2024104815);
table.insert(v2, 2227730452);
table.insert(v2, 2361852424);
table.insert(v2, 2428436474);
table.insert(v2, 2756734187);
table.insert(v2, 3204031479);
table.insert(v2, 3329325298);
local v3 = setmetatable({}, {
	__tostring = function()
		return "Hash";
	end
});
v3.__index = v3;
function v3.new(...)
	local v4 = setmetatable({}, v3);
	return v4:constructor(...) and v4;
end;
function v3.constructor(p1)
	p1.digestLength = 32;
	p1.blockSize = 64;
	p1.state = table.create(8, 0);
	p1.temp = table.create(64, 0);
	p1.buffer = table.create(128, 0);
	p1.bufferLength = 0;
	p1.bytesHashed = 0;
	p1.finished = false;
	p1:reset();
end;
function v3.reset(p2)
	p2.state[1] = 1779033703;
	p2.state[2] = 3144134277;
	p2.state[3] = 1013904242;
	p2.state[4] = 2773480762;
	p2.state[5] = 1359893119;
	p2.state[6] = 2600822924;
	p2.state[7] = 528734635;
	p2.state[8] = 1541459225;
	p2.bufferLength = 0;
	p2.bytesHashed = 0;
	p2.finished = false;
	return p2;
end;
function v3.clean(p3)
	local v5 = 0;
	local v6 = false;
	while true do
		if v6 then
			v5 = v5 + 1;
		else
			v6 = true;
		end;
		if not (v5 < #p3.buffer) then
			break;
		end;
		p3.buffer[v5 + 1] = 0;	
	end;
	local v7 = 0;
	local v8 = false;
	while true do
		if v8 then
			v7 = v7 + 1;
		else
			v8 = true;
		end;
		if not (v7 < #p3.temp) then
			break;
		end;
		p3.temp[v7 + 1] = 0;	
	end;
	p3:reset();
end;
local function u1(p4, p5, p6, p7, p8)
	while p8 >= 64 do
		local v9 = p5[1];
		local v10 = p5[2];
		local v11 = p5[3];
		local v12 = p5[4];
		local v13 = p5[5];
		local v14 = p5[6];
		local v15 = p5[7];
		local v16 = p5[8];
		local v17 = 0;
		local v18 = false;
		while true do
			if v18 then
				v17 = v17 + 1;
			else
				v18 = true;
			end;
			if not (v17 < 16) then
				break;
			end;
			local v19 = p7 + v17 * 4;
			p4[v17 + 1] = bit32.bor(bit32.bor(bit32.bor(bit32.lshift(bit32.band(p6[v19 + 1], 255), 24), (bit32.lshift(bit32.band(p6[v19 + 1 + 1], 255), 16))), (bit32.lshift(bit32.band(p6[v19 + 2 + 1], 255), 8))), (bit32.band(p6[v19 + 3 + 1], 255)));		
		end;
		local v20 = 16;
		local v21 = false;
		while true do
			if v21 then
				v20 = v20 + 1;
			else
				v21 = true;
			end;
			if not (v20 < 64) then
				break;
			end;
			local v22 = p4[v20 - 2 + 1];
			local v23 = p4[v20 - 15 + 1];
			p4[v20 + 1] = bit32.bor(bit32.bxor(bit32.bxor(bit32.bor(bit32.rshift(v22, 17), (bit32.lshift(v22, 15))), (bit32.bor(bit32.rshift(v22, 19), (bit32.lshift(v22, 13))))), (bit32.rshift(v22, 10))) + p4[v20 - 7 + 1], 0) + bit32.bor(bit32.bxor(bit32.bxor(bit32.bor(bit32.rshift(v23, 7), (bit32.lshift(v23, 25))), (bit32.bor(bit32.rshift(v23, 18), (bit32.lshift(v23, 14))))), (bit32.rshift(v23, 3))) + p4[v20 - 16 + 1], 0);		
		end;
		local v24 = 0;
		local v25 = false;
		while true do
			if v25 then
				v24 = v24 + 1;
			else
				v25 = true;
			end;
			if not (v24 < 64) then
				break;
			end;
			local v26 = bit32.bor(bit32.bor(bit32.bxor(bit32.bxor(bit32.bor(bit32.rshift(v13, 6), (bit32.lshift(v13, 26))), (bit32.bor(bit32.rshift(v13, 11), (bit32.lshift(v13, 21))))), (bit32.bor(bit32.rshift(v13, 25), (bit32.lshift(v13, 7))))) + bit32.bxor(bit32.band(v13, v14), (bit32.band(bit32.bnot(v13), v15))), 0) + bit32.bor(v16 + bit32.bor(v2[v24 + 1] + p4[v24 + 1], 0), 0), 0);
			v16 = v15;
			v15 = v14;
			v14 = v13;
			v13 = bit32.bor(v12 + v26, 0);
			v12 = v11;
			v11 = v10;
			v10 = v9;
			v9 = bit32.bor(v26 + bit32.bor(bit32.bxor(bit32.bxor(bit32.bor(bit32.rshift(v9, 2), (bit32.lshift(v9, 30))), (bit32.bor(bit32.rshift(v9, 13), (bit32.lshift(v9, 19))))), (bit32.bor(bit32.rshift(v9, 22), (bit32.lshift(v9, 10))))) + bit32.bxor(bit32.bxor(bit32.band(v9, v10), (bit32.band(v9, v11))), (bit32.band(v10, v11))), 0), 0);		
		end;
		p5[1] = p5[1] + v9;
		p5[2] = p5[2] + v10;
		p5[3] = p5[3] + v11;
		p5[4] = p5[4] + v12;
		p5[5] = p5[5] + v13;
		p5[6] = p5[6] + v14;
		p5[7] = p5[7] + v15;
		p5[8] = p5[8] + v16;
		p7 = p7 + 64;
		p8 = p8 - 64;	
	end;
	return p7;
end;
function v3.update(p9, p10, p11)
	if p11 == nil then
		p11 = #p10;
	end;
	if p9.finished then
		error("SHA256: can't update because hash was finished.");
	end;
	local v27 = 0;
	p9.bytesHashed = p9.bytesHashed + p11;
	if p9.bufferLength > 0 then
		while p9.bufferLength < 64 and p11 > 0 do
			p9.bufferLength = p9.bufferLength + 1;
			v27 = v27 + 1;
			p9.buffer[p9.bufferLength + 1] = p10[v27 + 1];
			p11 = p11 - 1;		
		end;
		if p9.bufferLength == 64 then
			u1(p9.temp, p9.state, p9.buffer, 0, 64);
			p9.bufferLength = 0;
		end;
	end;
	if p11 >= 64 then
		v27 = u1(p9.temp, p9.state, p10, v27, p11);
		p11 = p11 % 64;
	end;
	while p11 > 0 do
		p9.bufferLength = p9.bufferLength + 1;
		v27 = v27 + 1;
		p9.buffer[p9.bufferLength + 1] = p10[v27 + 1];
		p11 = p11 - 1;	
	end;
	return p9;
end;
function v3.finish(p12, p13)
	if not p12.finished then
		local l__bytesHashed__28 = p12.bytesHashed;
		local l__bufferLength__29 = p12.bufferLength;
		local v30 = bit32.bor(l__bytesHashed__28 / 536870912, 0);
		local v31 = bit32.lshift(l__bytesHashed__28, 3);
		if l__bytesHashed__28 % 64 < 56 then
			local v32 = 64;
		else
			v32 = 128;
		end;
		p12.buffer[l__bufferLength__29 + 1] = 128;
		local v33 = l__bufferLength__29 + 1;
		local v34 = false;
		while true do
			if v34 then
				v33 = v33 + 1;
			else
				v34 = true;
			end;
			if not (v33 < v32 - 8) then
				break;
			end;
			p12.buffer[v33 + 1] = 0;		
		end;
		p12.buffer[v32 - 8 + 1] = bit32.band(bit32.rshift(v30, 24), 255);
		p12.buffer[v32 - 7 + 1] = bit32.band(bit32.rshift(v30, 16), 255);
		p12.buffer[v32 - 6 + 1] = bit32.band(bit32.rshift(v30, 8), 255);
		p12.buffer[v32 - 5 + 1] = bit32.band(bit32.rshift(v30, 0), 255);
		p12.buffer[v32 - 4 + 1] = bit32.band(bit32.rshift(v31, 24), 255);
		p12.buffer[v32 - 3 + 1] = bit32.band(bit32.rshift(v31, 16), 255);
		p12.buffer[v32 - 2 + 1] = bit32.band(bit32.rshift(v31, 8), 255);
		p12.buffer[v32 - 1 + 1] = bit32.band(bit32.rshift(v31, 0), 255);
		u1(p12.temp, p12.state, p12.buffer, 0, v32);
		p12.finished = true;
	end;
	local v35 = 0;
	local v36 = false;
	while true do
		if v36 then
			v35 = v35 + 1;
		else
			v36 = true;
		end;
		if not (v35 < 8) then
			break;
		end;
		p13[v35 * 4 + 0 + 1] = bit32.band(bit32.rshift(p12.state[v35 + 1], 24), 255);
		p13[v35 * 4 + 1 + 1] = bit32.band(bit32.rshift(p12.state[v35 + 1], 16), 255);
		p13[v35 * 4 + 2 + 1] = bit32.band(bit32.rshift(p12.state[v35 + 1], 8), 255);
		p13[v35 * 4 + 3 + 1] = bit32.band(bit32.rshift(p12.state[v35 + 1], 0), 255);	
	end;
	return p12;
end;
function v3.digest(p14)
	local v37 = table.create(p14.digestLength, 0);
	p14:finish(v37);
	return v37;
end;
function v3._saveState(p15, p16)
	local v38 = 0;
	local v39 = false;
	while true do
		if v39 then
			v38 = v38 + 1;
		else
			v39 = true;
		end;
		if not (v38 < #p15.state) then
			break;
		end;
		p16[v38 + 1] = p15.state[v38 + 1];	
	end;
end;
function v3._restoreState(p17, p18, p19)
	local v40 = 0;
	local v41 = false;
	while true do
		if v41 then
			v40 = v40 + 1;
		else
			v41 = true;
		end;
		if not (v40 < #p17.state) then
			break;
		end;
		p17.state[v40 + 1] = p18[v40 + 1];	
	end;
	p17.bytesHashed = p19;
	p17.finished = false;
	p17.bufferLength = 0;
end;
v1.Hash = v3;
local v42 = setmetatable({}, {
	__tostring = function()
		return "HMAC";
	end
});
v42.__index = v42;
function v42.new(...)
	local v43 = setmetatable({}, v42);
	return v43:constructor(...) and v43;
end;
function v42.constructor(p20, p21)
	p20.inner = v3.new();
	p20.outer = v3.new();
	p20.blockSize = p20.inner.blockSize;
	p20.digestLength = p20.inner.digestLength;
	local v44 = table.create(p20.blockSize, 0);
	if p20.blockSize < #p21 then
		v3.new():update(p21):finish(v44):clean();
	else
		local v45 = 0;
		local v46 = false;
		while true do
			if v46 then
				v45 = v45 + 1;
			else
				v46 = true;
			end;
			if not (v45 < #p21) then
				break;
			end;
			v44[v45 + 1] = p21[v45 + 1];		
		end;
	end;
	local v47 = 0;
	local v48 = false;
	while true do
		if v48 then
			v47 = v47 + 1;
		else
			v48 = true;
		end;
		if not (v47 < #v44) then
			break;
		end;
		local v49 = v47 + 1;
		v44[v49] = bit32.bxor(v44[v49], 54);	
	end;
	p20.inner:update(v44);
	local v50 = 0;
	local v51 = false;
	while true do
		if v51 then
			v50 = v50 + 1;
		else
			v51 = true;
		end;
		if not (v50 < #v44) then
			break;
		end;
		local v52 = v50 + 1;
		v44[v52] = bit32.bxor(v44[v52], bit32.bxor(54, 92));	
	end;
	p20.outer:update(v44);
	p20.istate = table.create(8, 0);
	p20.ostate = table.create(8, 0);
	p20.inner:_saveState(p20.istate);
	p20.outer:_saveState(p20.ostate);
	local v53 = 0;
	local v54 = false;
	while true do
		if v54 then
			v53 = v53 + 1;
		else
			v54 = true;
		end;
		if not (v53 < #v44) then
			break;
		end;
		v44[v53 + 1] = 0;	
	end;
end;
function v42.reset(p22)
	p22.inner:_restoreState(p22.istate, p22.inner.blockSize);
	p22.outer:_restoreState(p22.ostate, p22.outer.blockSize);
	return p22;
end;
function v42.clean(p23)
	local v55 = 0;
	local v56 = false;
	while true do
		if v56 then
			v55 = v55 + 1;
		else
			v56 = true;
		end;
		if not (v55 < #p23.istate) then
			break;
		end;
		local l__istate__57 = p23.istate;
		local v58 = v55 + 1;
		l__istate__57[v58] = 0;
		p23.ostate[v55 + 1] = l__istate__57[v58];	
	end;
	p23.inner:clean();
	p23.outer:clean();
end;
function v42.update(p24, p25)
	p24.inner:update(p25);
	return p24;
end;
function v42.finish(p26, p27)
	if p26.outer.finished then
		p26.outer:finish(p27);
		return p26;
	end;
	p26.inner:finish(p27);
	p26.outer:update(p27, p26.digestLength):finish(p27);
	return p26;
end;
function v42.digest(p28)
	local v59 = table.create(p28.digestLength, 0);
	p28:finish(v59);
	return v59;
end;
v1.HMAC = v42;
function v1.hash(p29)
	local v60 = v3.new():update(p29);
	local v61 = v60:digest();
	v60:clean();
	return v61;
end;
local function v62(p30, p31)
	local v63 = v42.new(p30):update(p31);
	local v64 = v63:digest();
	v63:clean();
	return v64;
end;
v1.hmac = v62;
local u2 = table.create(32, 0);
local function u3(p32, p33, p34, p35)
	local v65 = p35[1];
	if v65 == 0 then
		error("hkdf: cannot expand more");
	end;
	p33:reset();
	if v65 > 1 then
		p33:update(p32);
	end;
	if p34 then
		p33:update(p34);
	end;
	p33:update(p35);
	p33:finish(p32);
	p35[1] = p35[1] + 1;
end;
function v1.hkdf(p36, p37, p38, p39)
	if p37 == nil then
		p37 = u2;
	end;
	if p39 == nil then
		p39 = 32;
	end;
	local v66 = table.create(1, 0);
	table.insert(v66, 1);
	local v67 = v42.new((v62(p37, p36)));
	local v68 = table.create(v67.digestLength, 0);
	local v69 = #v68;
	local v70 = table.create(p39, 0);
	local v71 = 0;
	local v72 = false;
	while true do
		if v72 then
			v71 = v71 + 1;
		else
			v72 = true;
		end;
		if not (v71 < p39) then
			break;
		end;
		if v69 == #v68 then
			u3(v68, v67, p38, v66);
			v69 = 0;
		end;
		v69 = v69 + 1;
		v70[v71 + 1] = v68[v69 + 1];	
	end;
	v67:clean();
	local v73 = 0;
	local v74 = false;
	while true do
		if v74 then
			v73 = v73 + 1;
		else
			v74 = true;
		end;
		if not (v73 < #v68) then
			break;
		end;
		v68[v73 + 1] = 0;	
	end;
	while #v66 < v67.digestLength do
		table.insert(v68, 0);	
	end;
	return v70;
end;
function v1.pbkdf2(p40, p41, p42, p43)
	local v75 = v42.new(p40);
	local l__digestLength__76 = v75.digestLength;
	local v77 = table.create(4, 0);
	local v78 = table.create(l__digestLength__76, 0);
	local v79 = table.create(l__digestLength__76, 0);
	local v80 = table.create(p43, 0);
	local v81 = 0;
	local v82 = false;
	while true do
		if v82 then
			v81 = v81 + 1;
		else
			v82 = true;
		end;
		if not (v81 * l__digestLength__76 < p43) then
			break;
		end;
		local v83 = v81 + 1;
		v77[1] = bit32.band(bit32.rshift(v83, 24), 255);
		v77[2] = bit32.band(bit32.rshift(v83, 16), 255);
		v77[3] = bit32.band(bit32.rshift(v83, 8), 255);
		v77[4] = bit32.band(bit32.rshift(v83, 0), 255);
		v75:reset();
		v75:update(p41);
		v75:update(v77);
		v75:finish(v79);
		local v84 = 0;
		local v85 = false;
		while true do
			if v85 then
				v84 = v84 + 1;
			else
				v85 = true;
			end;
			if not (v84 < l__digestLength__76) then
				break;
			end;
			v78[v84 + 1] = v79[v84 + 1];		
		end;
		local v86 = 2;
		local v87 = false;
		while true do
			if v87 then
				v86 = v86 + 1;
			else
				v87 = true;
			end;
			if not (v86 <= p42) then
				break;
			end;
			v75:reset();
			v75:update(v79):finish(v79);
			local v88 = 0;
			local v89 = false;
			while true do
				if v89 then
					v88 = v88 + 1;
				else
					v89 = true;
				end;
				if not (v88 < l__digestLength__76) then
					break;
				end;
				local v90 = v88 + 1;
				v78[v90] = bit32.bxor(v78[v90], v79[v88 + 1]);			
			end;		
		end;
		local v91 = 0;
		local v92 = false;
		while true do
			if v92 then
				v91 = v91 + 1;
			else
				v92 = true;
			end;
			if not (v91 < l__digestLength__76) then
				break;
			end;
			if not (v81 * l__digestLength__76 + v91 < p43) then
				break;
			end;
			v80[v81 * l__digestLength__76 + v91 + 1] = v78[v91 + 1];		
		end;	
	end;
	local v93 = 0;
	local v94 = false;
	while true do
		if v94 then
			v93 = v93 + 1;
		else
			v94 = true;
		end;
		if not (v93 < l__digestLength__76) then
			break;
		end;
		local v95 = v93 + 1;
		v79[v95] = 0;
		v78[v93 + 1] = v79[v95];	
	end;
	local v96 = 0;
	local v97 = false;
	while true do
		if v97 then
			v96 = v96 + 1;
		else
			v97 = true;
		end;
		if not (v96 < 4) then
			break;
		end;
		v77[v96 + 1] = 0;	
	end;
	v75:clean();
	return v80;
end;
function v1.equal(p44, p45)
	if #p44 ~= #p45 then
		return false;
	end;
	local v98 = 0;
	local v99 = false;
	while true do
		if v99 then
			v98 = v98 + 1;
		else
			v99 = true;
		end;
		if not (v98 < #p44) then
			break;
		end;
		if p44[v98 + 1] ~= p45[v98 + 1] then
			return false;
		end;	
	end;
	return true;
end;
return {
	HashUtil = v1
};
