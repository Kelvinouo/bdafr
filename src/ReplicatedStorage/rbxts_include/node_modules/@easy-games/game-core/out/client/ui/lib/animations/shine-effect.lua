-- Decompiled with the Synapse X Luau decompiler.

local v1 = _G[script];
local v2 = {};
local v3 = setmetatable({}, {
	__index = v2
});
v3.gradient = 0;
v2[0] = "gradient";
v3.gradientLarge = 1;
v2[1] = "gradientLarge";
v3.solid = 2;
v2[2] = "solid";
v3.trailing = 3;
v2[3] = "trailing";
local u1 = v1.import(script, v1.getModule(script, "@rbxts", "roact").src);
local l__TweenService__2 = v1.import(script, v1.getModule(script, "@rbxts", "services")).TweenService;
return {
	ShineEffectVariation = v3, 
	ShineEffect = v1.import(script, v1.getModule(script, "@rbxts", "roact-hooks").src).new(u1)(function(p1, p2)
		local v4 = {};
		for v5, v6 in pairs(p1) do
			v4[v5] = v6;
		end;
		local v7 = v4.Speed;
		if v7 == nil then
			v7 = 0.7;
		end;
		local v8 = v4.Loop;
		if v8 == nil then
			v8 = true;
		end;
		local v9 = v4.DelayTime;
		if v9 == nil then
			v9 = 4;
		end;
		local v10 = v4.Color;
		if v10 == nil then
			v10 = Color3.fromRGB(255, 255, 255);
		end;
		local v11 = v4.Variation;
		if v11 == nil then
			v11 = v3.gradient;
		end;
		local u3 = u1.createRef();
		p2.useEffect(function()
			local v12 = u3:getValue();
			if v11 == v3.gradient then
				v12.Transparency = NumberSequence.new({ NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.35, 1), NumberSequenceKeypoint.new(0.5, 0.25), NumberSequenceKeypoint.new(0.65, 1), NumberSequenceKeypoint.new(1, 1) });
			elseif v11 == v3.gradientLarge then
				v12.Transparency = NumberSequence.new({ NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.35, 0.75), NumberSequenceKeypoint.new(0.5, 0.5), NumberSequenceKeypoint.new(0.75, 0.75), NumberSequenceKeypoint.new(1, 1) });
			elseif v11 == v3.solid then
				v12.Transparency = NumberSequence.new({ NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.34, 1), NumberSequenceKeypoint.new(0.35, 0.25), NumberSequenceKeypoint.new(0.45, 0.25), NumberSequenceKeypoint.new(0.46, 0.5), NumberSequenceKeypoint.new(0.51, 0.5), NumberSequenceKeypoint.new(0.52, 1), NumberSequenceKeypoint.new(1, 1) });
			elseif v11 == v3.trailing then
				v12.Transparency = NumberSequence.new({ NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.35, 0.75), NumberSequenceKeypoint.new(0.5, 0), NumberSequenceKeypoint.new(0.51, 1), NumberSequenceKeypoint.new(1, 1) });
			else
				v12.Transparency = NumberSequence.new({ NumberSequenceKeypoint.new(0, 1), NumberSequenceKeypoint.new(0.35, 0.1), NumberSequenceKeypoint.new(0.5, 0.1), NumberSequenceKeypoint.new(0.65, 1), NumberSequenceKeypoint.new(1, 1) });
			end;
			v12.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, v10), ColorSequenceKeypoint.new(1, v10) });
			if v8 then
				local v13 = -1;
			else
				v13 = 1;
			end;
			local v14 = TweenInfo.new(v7, Enum.EasingStyle.Circular, Enum.EasingDirection.Out, v13, false, v9);
			local v15 = {
				Offset = Vector2.new(1.1, 0)
			};
			if not p1.OnHover then
				l__TweenService__2:Create(u3:getValue(), v14, v15):Play();
				return;
			end;
			local v16 = l__TweenService__2:Create(u3:getValue(), TweenInfo.new(v7, Enum.EasingStyle.Circular, Enum.EasingDirection.Out), {
				Offset = Vector2.new(-1, 0)
			});
			local u4 = l__TweenService__2:Create(u3:getValue(), TweenInfo.new(v7, Enum.EasingStyle.Circular, Enum.EasingDirection.Out), v15);
			v12.Parent.MouseEnter:Connect(function()
				u4:Play();
			end);
			v12.Parent.MouseLeave:Connect(function()
				v16:Play();
			end);
		end, {});
		local v17 = {};
		for v18, v19 in pairs(p1) do
			v17[v18] = v19;
		end;
		v17.Speed = nil;
		v17.Loop = nil;
		v17.DelayTime = nil;
		v17.Color = nil;
		v17.Variation = nil;
		v17.OnHover = nil;
		local v20 = {
			Size = UDim2.fromScale(1, 1), 
			BorderSizePixel = 0
		};
		for v21, v22 in pairs(v17) do
			v20[v21] = v22;
		end;
		return u1.createElement("Frame", v20, { u1.createElement("UIGradient", {
				Rotation = 30, 
				[u1.Ref] = u3, 
				Offset = Vector2.new(-1, 0)
			}) });
	end)
};
