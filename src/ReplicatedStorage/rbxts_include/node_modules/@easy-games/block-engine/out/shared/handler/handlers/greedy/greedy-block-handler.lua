-- Decompiled with the Synapse X Luau decompiler.

local v1 = _G[script];
local l__BlockHandler__2 = v1.import(script, script.Parent.Parent.Parent, "block-handler").BlockHandler;
local v3 = setmetatable({}, {
	__tostring = function()
		return "GreedyBlockHandler";
	end, 
	__index = l__BlockHandler__2
});
v3.__index = v3;
function v3.new(...)
	local v4 = setmetatable({}, v3);
	return v4:constructor(...) and v4;
end;
function v3.constructor(p1, ...)
	l__BlockHandler__2.constructor(p1, ...);
	p1.containedPositionMap = {};
	p1.textureReferences = {};
	p1.faceOrder = { Enum.NormalId.Top, Enum.NormalId.Bottom, Enum.NormalId.Left, Enum.NormalId.Front, Enum.NormalId.Right, Enum.NormalId.Back };
end;
local l__PositionUtil__1 = v1.import(script, script.Parent.Parent.Parent.Parent, "lib", "position-util").PositionUtil;
function v3.place(p2, p3, p4, p5)
	local v5 = p2:createNewInstance(p4);
	v5.CFrame = CFrame.new(l__PositionUtil__1.convertToWorldPosition(p3));
	v5:SetAttribute("GreedyBlock", true);
	return v5;
end;
local l__BLOCK_SIZE__2 = v1.import(script, script.Parent.Parent.Parent.Parent, "block", "block-constants").BLOCK_SIZE;
function v3.resize(p6, p7, p8, p9)
	p7.CFrame = CFrame.new((p8 - Vector3.new(1, 1, 1) / 2 + p9 / 2) * l__BLOCK_SIZE__2);
	p7.Size = p9 * l__BLOCK_SIZE__2;
end;
function v3.getMinBlockPosition(p10, p11)
	return p11.Position / l__BLOCK_SIZE__2 - p11.Size / l__BLOCK_SIZE__2 / 2 + Vector3.new(1, 1, 1) / 2;
end;
function v3.getContainedPositions(p12, p13)
	debug.profilebegin("get-contained-positions");
	local v6 = p13.Size / l__BLOCK_SIZE__2;
	local v7 = p12.containedPositionMap[p13];
	local v8 = v7;
	if v8 ~= nil then
		v8 = v8.size;
	end;
	if v8 == v6 then
		debug.profileend();
		return v7.containedPositions;
	end;
	local v9 = {};
	local v10 = p12:getMinBlockPosition(p13);
	local v11 = v10.X;
	local v12 = false;
	while true do
		if v12 then
			v11 = v11 + 1;
		else
			v12 = true;
		end;
		if not (v11 < v10.X + v6.X) then
			break;
		end;
		local v13 = v10.Y;
		local v14 = false;
		while true do
			if v14 then
				v13 = v13 + 1;
			else
				v14 = true;
			end;
			if not (v13 < v10.Y + v6.Y) then
				break;
			end;
			local v15 = v10.Z;
			local v16 = false;
			while true do
				if v16 then
					v15 = v15 + 1;
				else
					v16 = true;
				end;
				if not (v15 < v10.Z + v6.Z) then
					break;
				end;
				table.insert(v9, (Vector3.new(v11, v13, v15)));			
			end;		
		end;	
	end;
	p12.containedPositionMap[p13] = {
		size = v6, 
		containedPositions = v9
	};
	debug.profileend();
	return v9;
end;
function v3.getAdjacentBlockPositions(p14, p15, p16)
	debug.profilebegin("adj-pos");
	local v17 = p14:getAdjacentWall(p15, p16);
	local l__min__18 = v17.min;
	local l__max__19 = v17.max;
	local v20 = {};
	local v21 = l__min__18.X;
	local v22 = false;
	while true do
		if v22 then
			v21 = v21 + 1;
		else
			v22 = true;
		end;
		if not (v21 <= l__max__19.X) then
			break;
		end;
		local v23 = l__min__18.Y;
		local v24 = false;
		while true do
			if v24 then
				v23 = v23 + 1;
			else
				v24 = true;
			end;
			if not (v23 <= l__max__19.Y) then
				break;
			end;
			local v25 = l__min__18.Z;
			local v26 = false;
			while true do
				if v26 then
					v25 = v25 + 1;
				else
					v26 = true;
				end;
				if not (v25 <= l__max__19.Z) then
					break;
				end;
				table.insert(v20, (Vector3.new(v21, v23, v25)));			
			end;		
		end;	
	end;
	debug.profileend();
	return v20;
end;
function v3.findAdjacentPosition(p17, p18, p19, p20)
	debug.profilebegin("adj-pos-query");
	local v27 = p17:getAdjacentWall(p18, p19);
	local l__min__28 = v27.min;
	local l__max__29 = v27.max;
	local v30 = {};
	local v31 = l__min__28.X;
	local v32 = false;
	while true do
		if v32 then
			v31 = v31 + 1;
		else
			v32 = true;
		end;
		if not (v31 <= l__max__29.X) then
			break;
		end;
		local v33 = l__min__28.Y;
		local v34 = false;
		while true do
			if v34 then
				v33 = v33 + 1;
			else
				v34 = true;
			end;
			if not (v33 <= l__max__29.Y) then
				break;
			end;
			local v35 = l__min__28.Z;
			local v36 = false;
			while true do
				if v36 then
					v35 = v35 + 1;
				else
					v36 = true;
				end;
				if not (v35 <= l__max__29.Z) then
					break;
				end;
				local v37 = Vector3.new(v31, v33, v35);
				if p20(v37) then
					debug.profileend();
					return v37;
				end;			
			end;		
		end;	
	end;
	debug.profileend();
	return nil;
end;
function v3.getAdjacentWall(p21, p22, p23)
	local v38 = p22.Size / l__BLOCK_SIZE__2;
	local v39 = p22.Position / l__BLOCK_SIZE__2 + v38 / 2 * Vector3.FromNormalId(p23) + Vector3.new(1, 1, 1) / 2 * Vector3.FromNormalId(p23);
	local v40 = Vector3.new(1, 1, 1) - Vector3.FromNormalId(p23) * Vector3.FromNormalId(p23);
	local v41 = v39 - v38 / 2 * v40 + Vector3.new(1, 1, 1) / 2 * v40;
	local v42 = v39 + v38 / 2 * v40 - Vector3.new(1, 1, 1) / 2 * v40;
	return {
		min = Vector3.new(math.min(v41.X, v42.X), math.min(v41.Y, v42.Y), math.min(v41.Z, v42.Z)), 
		max = Vector3.new(math.max(v41.X, v42.X), math.max(v41.Y, v42.Y), math.max(v41.Z, v42.Z))
	};
end;
function v3.checkCulling(p24, p25, p26, p27, p28)
	p24:setFaceVisible(p27, p28, p24:findAdjacentPosition(p27, p28, function(p29)
		local v43 = p25:getBlockAt(p29);
		if v43 == nil then
			return true;
		end;
		local v44 = p26:getHandler(v43.Name);
		if v44 ~= nil then
			v44 = v44:getBlockMeta();
		end;
		if v44 and v44.seeThrough then
			return true;
		end;
		return false;
	end) ~= nil);
end;
function v3.setFaceVisible(p30, p31, p32, p33)
	if not p30.blockMeta.greedyMesh then
		return nil;
	end;
	if p33 then
		if not p31:FindFirstChild(p32.Name) then
			local v45 = p30:createFace(p31, p31:GetAttribute("Data"), p32);
			if v45 then
				v45.Parent = p31;
				return;
			end;
		end;
	else
		local v46 = p31:FindFirstChild(p32.Name);
		if v46 then
			v46:Destroy();
		end;
	end;
end;
local u3 = v1.import(script, v1.getModule(script, "@rbxts", "make"));
function v3.createFace(p34, p35, p36, p37)
	local v47 = p34:getTextureId(p37);
	if v47 == "" or not v47 then
		return nil;
	end;
	debug.profilebegin("create-face");
	local v48 = (p34.textureReferences[p37] or u3("Texture", {
		Name = p37.Name, 
		Face = p37, 
		StudsPerTileU = l__BLOCK_SIZE__2, 
		StudsPerTileV = l__BLOCK_SIZE__2, 
		OffsetStudsU = 0, 
		OffsetStudsV = 0, 
		Texture = v47
	})):Clone();
	debug.profileend();
	return v48;
end;
function v3.destroyFace(p38, p39, p40)
	local v49 = p39:FindFirstChild(p40.Name);
	if v49 then
		v49:Destroy();
	end;
end;
function v3.destroy(p41, p42, p43)
	p42:Destroy();
end;
function v3.createNewInstance(p44, p45)
	local v50 = u3("Part", {
		Name = p44:getBlockType(), 
		Size = Vector3.new(l__BLOCK_SIZE__2, l__BLOCK_SIZE__2, l__BLOCK_SIZE__2), 
		Material = p44.blockMeta.greedyMesh.material or Enum.Material.Fabric, 
		Color = p44.blockMeta.greedyMesh.materialColor, 
		CanCollide = true, 
		Anchored = true
	});
	local v51, v52, v53 = ipairs(Enum.NormalId:GetEnumItems());
	while true do
		v51(v52, v53);
		if not v51 then
			break;
		end;
		v53 = v51;
		local v54 = p44:createFace(v50, p45, v52);
		if v54 then
			v54.Parent = v50;
		end;	
	end;
	return v50;
end;
function v3.getTextureId(p46, p47)
	if not p46.blockMeta.greedyMesh then
		return nil;
	end;
	if not (#p46.blockMeta.greedyMesh.textures > 1) then
		return p46.blockMeta.greedyMesh.textures[1];
	end;
	return p46.blockMeta.greedyMesh.textures[(table.find(p46.faceOrder, p47) and 0) - 1 + 1];
end;
return {
	GreedyBlockHandler = v3
};
