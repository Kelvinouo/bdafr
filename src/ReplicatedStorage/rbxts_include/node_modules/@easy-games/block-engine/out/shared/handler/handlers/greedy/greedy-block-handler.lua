-- Decompiled with the Synapse X Luau decompiler.

local v1 = _G[script];
local l__BlockHandler__2 = v1.import(script, script.Parent.Parent.Parent, "block-handler").BlockHandler;
local v3 = setmetatable({}, {
	__tostring = function()
		return "GreedyBlockHandler";
	end, 
	__index = l__BlockHandler__2
});
v3.__index = v3;
function v3.new(...)
	local v4 = setmetatable({}, v3);
	return v4:constructor(...) and v4;
end;
local u1 = l__BlockHandler__2;
function v3.constructor(p1, ...)
	u1.constructor(p1, ...);
	p1.faceOrder = { Enum.NormalId.Top, Enum.NormalId.Bottom, Enum.NormalId.Left, Enum.NormalId.Front, Enum.NormalId.Right, Enum.NormalId.Back };
end;
local l__PositionUtil__2 = v1.import(script, script.Parent.Parent.Parent.Parent, "lib", "position-util").PositionUtil;
function v3.place(p2, p3, p4, p5)
	local v5 = p2:createNewInstance(p4);
	v5.CFrame = CFrame.new(l__PositionUtil__2.convertToWorldPosition(p3));
	v5:SetAttribute("GreedyBlock", true);
	return v5;
end;
local l__BLOCK_SIZE__3 = v1.import(script, script.Parent.Parent.Parent.Parent, "block", "block-constants").BLOCK_SIZE;
function v3.resize(p6, p7, p8, p9)
	p7.CFrame = CFrame.new((p8 - Vector3.new(1, 1, 1) / 2 + p9 / 2) * l__BLOCK_SIZE__3);
	p7.Size = p9 * l__BLOCK_SIZE__3;
end;
function v3.getMinBlockPosition(p10, p11)
	return p11.Position / l__BLOCK_SIZE__3 - p11.Size / l__BLOCK_SIZE__3 / 2 + Vector3.new(1, 1, 1) / 2;
end;
function v3.getContainedPositions(p12, p13)
	local v6 = p13.Size / l__BLOCK_SIZE__3;
	local v7 = {};
	local v8 = p12:getMinBlockPosition(p13);
	local v9 = v8.X;
	local v10 = false;
	while true do
		if v10 then
			v9 = v9 + 1;
		else
			v10 = true;
		end;
		if not (v9 < v8.X + v6.X) then
			break;
		end;
		local v11 = v8.Y;
		local v12 = false;
		while true do
			if v12 then
				v11 = v11 + 1;
			else
				v12 = true;
			end;
			if not (v11 < v8.Y + v6.Y) then
				break;
			end;
			local v13 = v8.Z;
			local v14 = false;
			while true do
				if v14 then
					v13 = v13 + 1;
				else
					v14 = true;
				end;
				if not (v13 < v8.Z + v6.Z) then
					break;
				end;
				v7[#v7 + 1] = Vector3.new(v9, v11, v13);			
			end;		
		end;	
	end;
	return v7;
end;
function v3.getAdjacentBlockPositions(p14, p15, p16, p17)
	local v15 = p15.Size / l__BLOCK_SIZE__3;
	local v16 = p15.Position / l__BLOCK_SIZE__3 + v15 / 2 * Vector3.FromNormalId(p16) + Vector3.new(1, 1, 1) / 2 * Vector3.FromNormalId(p16);
	local v17 = Vector3.new(1, 1, 1) - Vector3.FromNormalId(p16) * Vector3.FromNormalId(p16);
	local v18 = v16 - v15 / 2 * v17 + Vector3.new(1, 1, 1) / 2 * v17;
	local v19 = v16 + v15 / 2 * v17 - Vector3.new(1, 1, 1) / 2 * v17;
	local v20 = Vector3.new(math.min(v18.X, v19.X), math.min(v18.Y, v19.Y), math.min(v18.Z, v19.Z));
	local v21 = Vector3.new(math.max(v18.X, v19.X), math.max(v18.Y, v19.Y), math.max(v18.Z, v19.Z));
	local v22 = {};
	local v23 = v20.X;
	local v24 = false;
	while true do
		if v24 then
			v23 = v23 + 1;
		else
			v24 = true;
		end;
		if not (v23 <= v21.X) then
			break;
		end;
		local v25 = v20.Y;
		local v26 = false;
		while true do
			if v26 then
				v25 = v25 + 1;
			else
				v26 = true;
			end;
			if not (v25 <= v21.Y) then
				break;
			end;
			local v27 = v20.Z;
			local v28 = false;
			while true do
				if v28 then
					v27 = v27 + 1;
				else
					v28 = true;
				end;
				if not (v27 <= v21.Z) then
					break;
				end;
				v22[#v22 + 1] = Vector3.new(v23, v25, v27);			
			end;		
		end;	
	end;
	return v22;
end;
function v3.checkCulling(p18, p19, p20, p21, p22, p23)
	local v29 = false;
	local v30, v31, v32 = ipairs((p18:getAdjacentBlockPositions(p21, p22, p23)));
	while true do
		local v33, v34 = v30(v31, v32);
		if not v33 then
			break;
		end;
		local v35 = p19:getBlockAt(v34);
		if v35 == nil then
			v29 = true;
			break;
		end;
		local v36 = p20:getHandler(v35.Name);
		if v36 ~= nil then
			v36 = v36:getBlockMeta();
		end;
		if v36 and v36.seeThrough then
			v29 = true;
			break;
		end;	
	end;
	if v29 then
		if p21:FindFirstChild(p22.Name) then
			return;
		end;
	else
		local v37 = p21:FindFirstChild(p22.Name);
		if v37 then
			v37:Destroy();
		end;
		return;
	end;
	p18:createFace(p21, p21:GetAttribute("Data"), p22).Parent = p21;
end;
local u4 = v1.import(script, v1.getModule(script, "@rbxts", "make"));
function v3.createFace(p24, p25, p26, p27)
	return u4("Texture", {
		Name = p27.Name, 
		Face = p27, 
		StudsPerTileU = l__BLOCK_SIZE__3, 
		StudsPerTileV = l__BLOCK_SIZE__3, 
		OffsetStudsU = 0, 
		OffsetStudsV = 0, 
		Texture = p24:getTextureId(p27)
	});
end;
function v3.destroyFace(p28, p29, p30)
	local v38 = p29:FindFirstChild(p30.Name);
	if v38 then
		v38:Destroy();
	end;
end;
function v3.destroy(p31, p32)
	p32:Destroy();
end;
function v3.createNewInstance(p33, p34)
	local v39 = u4("Part", {
		Name = p33:getBlockType(), 
		Size = Vector3.new(l__BLOCK_SIZE__3, l__BLOCK_SIZE__3, l__BLOCK_SIZE__3), 
		Material = Enum.Material.Fabric, 
		CanCollide = true, 
		Anchored = true
	});
	for v40, v41 in ipairs(Enum.NormalId:GetEnumItems()) do
		p33:createFace(v39, p34, v41).Parent = v39;
	end;
	return v39;
end;
function v3.getTextureId(p35, p36)
	if not (#p35.blockMeta.greedyMesh.textures > 1) then
		return p35.blockMeta.greedyMesh.textures[1];
	end;
	return p35.blockMeta.greedyMesh.textures[(table.find(p35.faceOrder, p36) and 0) - 1 + 1];
end;
u1 = {
	GreedyBlockHandler = v3
};
return l__BlockHandler__2;
