--[[VARIABLE DEFINITION ANOMALY DETECTED, DECOMPILATION OUTPUT POTENTIALLY INCORRECT]]--
-- Decompiled with the Synapse X Luau decompiler.

local function v1(p1, p2)
	local v2 = {};
	for v3, v4 in ipairs(p2) do
		v2[v4] = v4;
	end;
	local v5 = {};
	function v5.__index(p3, p4)
		error(string.format("%s is not in %s!", p4, p1), 2);
	end;
	function v5.__newindex()
		error(string.format("Creating new members in %s is not allowed!", p1), 2);
	end;
	return setmetatable(v2, v5);
end;
local v6 = {
	Kind = v1("Promise.Error.Kind", { "ExecutionError", "AlreadyCancelled", "NotResolvedInTime", "TimedOut" })
};
v6.__index = v6;
function v6.new(p5, p6)
	p5 = p5 or {};
	return setmetatable({
		error = tostring(p5.error) and "[This error has no error text.]", 
		trace = p5.trace, 
		context = p5.context, 
		kind = p5.kind, 
		parent = p6, 
		createdTick = os.clock(), 
		createdTrace = debug.traceback()
	}, v6);
end;
function v6.is(p7)
	local v7 = nil;
	if type(p7) == "table" then
		v7 = getmetatable(p7);
		if type(v7) ~= "table" then
			return false;
		end;
	else
		return false;
	end;
	local v8 = false;
	if rawget(p7, "error") ~= nil then
		v8 = type(rawget(v7, "extend")) == "function";
	end;
	return v8;
end;
function v6.isKind(p8, p9)
	assert(p9 ~= nil, "Argument #2 to Promise.Error.isKind must not be nil");
	return v6.is(p8) and p8.kind == p9;
end;
function v6.extend(p10, p11)
	p11 = p11 or {};
	p11.kind = p11.kind or p10.kind;
	return v6.new(p11, p10);
end;
function v6.getErrorChain(p12)
	local v9 = { p12 };
	while v9[#v9].parent do
		table.insert(v9, v9[#v9].parent);	
	end;
	return v9;
end;
function v6.__tostring(p13)
	local v10 = { string.format("-- Promise.Error(%s) --", p13.kind and "?") };
	for v11, v12 in ipairs(p13:getErrorChain()) do
		table.insert(v10, table.concat({ v12.trace or v12.error, v12.context }, "\n"));
	end;
	return table.concat(v10, "\n");
end;
local function u1(p14, ...)
	return p14, select("#", ...), { ... };
end;
local function u2(p15)
	assert(p15 ~= nil);
	return function(p16)
		if type(p16) == "table" then
			return p16;
		end;
		return v6.new({
			error = p16, 
			kind = v6.Kind.ExecutionError, 
			trace = debug.traceback(tostring(p16), 2), 
			context = "Promise created at:\n\n" .. p15
		});
	end;
end;
local function u3(p17, p18, ...)
	return u1(xpcall(p18, u2(p17), ...));
end;
local v13 = {
	Error = v6, 
	Status = v1("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }), 
	_getTime = os.clock, 
	_timeEvent = game:GetService("RunService").Heartbeat, 
	prototype = {}
};
v13.__index = v13.prototype;
local u4 = {
	__mode = "k"
};
function v13._new(p19, p20, p21)
	if p21 ~= nil and not v13.is(p21) then
		error("Argument #2 to Promise.new must be a promise or nil", 2);
	end;
	local v14 = {
		_source = p19, 
		_status = v13.Status.Started, 
		_values = nil, 
		_valuesLength = -1, 
		_unhandledRejection = true, 
		_queuedResolve = {}, 
		_queuedReject = {}, 
		_queuedFinally = {}, 
		_cancellationHook = nil, 
		_parent = p21, 
		_consumers = setmetatable({}, u4)
	};
	if p21 and p21._status == v13.Status.Started then
		p21._consumers[v14] = true;
	end;
	setmetatable(v14, v13);
	local function u5(...)
		v14:_resolve(...);
	end;
	local function u6(...)
		v14:_reject(...);
	end;
	local function u7(p22)
		if p22 then
			if v14._status == v13.Status.Cancelled then
				p22();
			else
				v14._cancellationHook = p22;
			end;
		end;
		return v14._status == v13.Status.Cancelled;
	end;
	coroutine.wrap(function()
		local v15, v16, v17 = u3(v14._source, p20, u5, u6, u7);
		if not v15 then
			u6(v17[1]);
		end;
	end)();
	return v14;
end;
function v13.new(p23)
	return v13._new(debug.traceback(nil, 2), p23);
end;
function v13.__tostring(p24)
	return string.format("Promise(%s)", p24:getStatus());
end;
function v13.defer(p25)
	local v18 = debug.traceback(nil, 2);
	return v13._new(v18, function(p26, p27, p28)
		local u8 = nil;
		u8 = v13._timeEvent:Connect(function()
			u8:Disconnect();
			local v19, v20, v21 = u3(v18, p25, p26, p27, p28);
			if not v19 then
				p27(v21[1]);
			end;
		end);
	end);
end;
v13.async = v13.defer;
local function u9(...)
	return select("#", ...), { ... };
end;
function v13.resolve(...)
	local v22, v23 = u9(...);
	return v13._new(debug.traceback(nil, 2), function(p29)
		p29(unpack(v23, 1, v22));
	end);
end;
function v13.reject(...)
	local v24, v25 = u9(...);
	return v13._new(debug.traceback(nil, 2), function(p30, p31)
		p31(unpack(v25, 1, v24));
	end);
end;
function v13._try(p32, p33, ...)
	local v26, v27 = u9(...);
	return v13._new(p32, function(p34)
		p34(p33(unpack(v27, 1, v26)));
	end);
end;
function v13.try(...)
	return v13._try(debug.traceback(nil, 2), ...);
end;
function v13._all(p35, p36, p37)
	if type(p36) ~= "table" then
		error(string.format("Please pass a list of promises to %s", "Promise.all"), 3);
	end;
	for v28, v29 in pairs(p36) do
		if not v13.is(v29) then
			error(string.format("Non-promise value passed into %s at index %s", "Promise.all", tostring(v28)), 3);
		end;
	end;
	if #p36 ~= 0 and p37 ~= 0 then
		return v13._new(p35, function(p38, p39, p40)
			local v30 = 0;
			local u10 = {};
			local u11 = false;
			local u12 = 0;
			local u13 = {};
			local function u14()
				for v31, v32 in ipairs(u10) do
					v32:cancel();
				end;
			end;
			local function v33(p41, ...)
				if u11 then
					return;
				end;
				u12 = u12 + 1;
				if p37 == nil then
					u13[p41] = ...;
				else
					u13[u12] = ...;
				end;
				if (p37 or #p36) <= u12 then
					u11 = true;
					p38(u13);
					u14();
				end;
			end;
			p40(u14);
			for v34, v35 in ipairs(p36) do
				local u15 = v30;
				u10[v34] = v35:andThen(function(...)
					v33(v34, ...);
				end, function(...)
					u15 = u15 + 1;
					if p37 == nil or #p36 - u15 < p37 then
						u14();
						u11 = true;
						p39(...);
					end;
				end);
			end;
			if u11 then
				u14();
			end;
		end);
	end;
	return v13.resolve({});
end;
function v13.all(p42)
	return v13._all(debug.traceback(nil, 2), p42);
end;
function v13.some(p43, p44)
	assert(type(p44) == "number", "Bad argument #2 to Promise.some: must be a number");
	return v13._all(debug.traceback(nil, 2), p43, p44);
end;
function v13.any(p45)
	return v13._all(debug.traceback(nil, 2), p45, 1):andThen(function(p46)
		return p46[1];
	end);
end;
function v13.allSettled(p47)
	if type(p47) ~= "table" then
		error(string.format("Please pass a list of promises to %s", "Promise.allSettled"), 2);
	end;
	for v36, v37 in pairs(p47) do
		if not v13.is(v37) then
			error(string.format("Non-promise value passed into %s at index %s", "Promise.allSettled", tostring(v36)), 2);
		end;
	end;
	if #p47 == 0 then
		return v13.resolve({});
	end;
	return v13._new(debug.traceback(nil, 2), function(p48, p49, p50)
		local u16 = 0;
		local u17 = {};
		local function v38(p51, ...)
			u16 = u16 + 1;
			u17[p51] = ...;
			if #p47 <= u16 then
				p48(u17);
			end;
		end;
		local u18 = {};
		p50(function()
			for v39, v40 in ipairs(u18) do
				v40:cancel();
			end;
		end);
		for v41, v42 in ipairs(p47) do
			u18[v41] = v42:finally(function(...)
				v38(v41, ...);
			end);
		end;
	end);
end;
function v13.race(p52)
	assert(type(p52) == "table", string.format("Please pass a list of promises to %s", "Promise.race"));
	for v43, v44 in pairs(p52) do
		assert(v13.is(v44), string.format("Non-promise value passed into %s at index %s", "Promise.race", tostring(v43)));
	end;
	return v13._new(debug.traceback(nil, 2), function(p53, p54, p55)
		local u19 = {};
		local function u20()
			for v45, v46 in ipairs(u19) do
				v46:cancel();
			end;
		end;
		local u21 = false;
		local function v47(p56)
			return function(...)
				u20();
				u21 = true;
				return p56(...);
			end;
		end;
		if p55(v47(p54)) then
			return;
		end;
		for v48, v49 in ipairs(p52) do
			u19[v48] = v49:andThen(v47(p53), v47(p54));
		end;
		if u21 then
			u20();
		end;
	end);
end;
function v13.each(p57, p58)
	assert(type(p57) == "table", string.format("Please pass a list of promises to %s", "Promise.each"));
	assert(type(p58) == "function", string.format("Please pass a handler function to %s!", "Promise.each"));
	return v13._new(debug.traceback(nil, 2), function(p59, p60, p61)
		local v50 = {};
		local u22 = {};
		local u23 = false;
		local function u24()
			for v51, v52 in ipairs(u22) do
				v52:cancel();
			end;
		end;
		p61(function()
			u23 = true;
			u24();
		end);
		local v53 = {};
		for v54, v55 in ipairs(p57) do
			if v13.is(v55) then
				if v55:getStatus() == v13.Status.Cancelled then
					u24();
					return p60(v6.new({
						error = "Promise is cancelled", 
						kind = v6.Kind.AlreadyCancelled, 
						context = string.format("The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s", v54, v55._source)
					}));
				end;
				if v55:getStatus() == v13.Status.Rejected then
					u24();
					return p60(select(2, v55:await()));
				end;
				local v56 = v55:andThen(function(...)
					return ...;
				end);
				table.insert(u22, v56);
				v53[v54] = v56;
			else
				v53[v54] = v55;
			end;
		end;
		local v57, v58, v59 = ipairs(v53);
		while true do
			local v60 = nil;
			local v61, v62 = v57(v58, v59);
			if not v61 then
				break;
			end;
			v59 = v61;
			if v13.is(v62) then
				local v63, v64 = v62:await();
				v62 = v64;
				if not v63 then
					u24();
					return p60(v62);
				end;
			end;
			if u23 then
				return;
			end;
			local v65 = v13.resolve(p58(v62, v61));
			table.insert(u22, v65);
			local v66 = nil;
			v66, v60 = v65:await();
			if not v66 then
				u24();
				return p60(v60);
			end;
			v50[v61] = v60;		
		end;
		p59(v50);
	end);
end;
function v13.is(p62)
	if type(p62) ~= "table" then
		return false;
	end;
	local v67 = getmetatable(p62);
	if v67 == v13 then
		return true;
	end;
	if v67 == nil then
		return type(p62.andThen) == "function";
	end;
	if type(v67) == "table" and type(rawget(v67, "__index")) == "table" and type(rawget(rawget(v67, "__index"), "andThen")) == "function" then
		return true;
	end;
	return false;
end;
function v13.promisify(p63)
	return function(...)
		return v13._try(debug.traceback(nil, 2), p63, ...);
	end;
end;
local u25 = nil;
local u26 = nil;
function v13.delay(p64)
	assert(type(p64) == "number", "Bad argument #1 to Promise.delay, must be a number.");
	if not (p64 >= 0.016666666666666666) or p64 == math.huge then
		p64 = 0.016666666666666666;
	end;
	return v13._new(debug.traceback(nil, 2), function(p65, p66, p67)
		local v68 = v13._getTime();
		local v69 = v68 + p64;
		local v70 = {
			resolve = p65, 
			startTime = v68, 
			endTime = v69
		};
		if u25 == nil then
			u26 = v70;
			u25 = v13._timeEvent:Connect(function()
				while u26 ~= nil and u26.endTime < v13._getTime() do
					u26 = u26.next;
					if u26 == nil then
						u25:Disconnect();
						u25 = nil;
					else
						u26.previous = nil;
					end;
					u26.resolve(v13._getTime() - u26.startTime);				
				end;
			end);
		elseif u26.endTime < v69 then
			local v71 = u26;
			local v72 = v71.next;
			while v72 ~= nil and v72.endTime < v69 do
				v71 = v72;
				v72 = v71.next;			
			end;
			v71.next = v70;
			v70.previous = v71;
			if v72 ~= nil then
				v70.next = v72;
				v72.previous = v70;
			end;
		else
			v70.next = u26;
			u26.previous = v70;
			u26 = v70;
		end;
		p67(function()
			local l__next__73 = v70.next;
			if u26 ~= v70 then
				local l__previous__74 = v70.previous;
				l__previous__74.next = l__next__73;
				if l__next__73 ~= nil then
					l__next__73.previous = l__previous__74;
				end;
				return;
			end;
			if l__next__73 == nil then
				u25:Disconnect();
				u25 = nil;
			else
				l__next__73.previous = nil;
			end;
			u26 = l__next__73;
		end);
	end);
end;
v13.prototype.timeout = function(p68, p69, p70)
	local v75 = {};
	local u27 = debug.traceback(nil, 2);
	v75[1] = v13.delay(p69):andThen(function()
		if p70 == nil then
			local v76 = v6.new({
				kind = v6.Kind.TimedOut, 
				error = "Timed out", 
				context = string.format("Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s", p69, u27)
			}) or p70;
		else
			v76 = p70;
		end;
		return v13.reject(v76);
	end);
	v75[2] = p68;
	return v13.race(v75);
end;
v13.prototype.getStatus = function(p71)
	return p71._status;
end;
local function u28(p72, p73, p74, p75)
	return function(...)
		local v77 = nil;
		local v78 = nil;
		local v79 = nil;
		v78, v79, v77 = u3(p72, p73, ...);
		if not v78 then
			p75(v77[1]);
			return;
		end;
		p74(unpack(v77, 1, v79));
	end;
end;
v13.prototype._andThen = function(p76, p77, p78, p79)
	p76._unhandledRejection = false;
	return v13._new(p77, function(p80, p81)
		local v80 = p80;
		if p78 then
			v80 = u28(p77, p78, p80, p81);
		end;
		local v81 = p81;
		if p79 then
			v81 = u28(p77, p79, p80, p81);
		end;
		if p76._status == v13.Status.Started then
			table.insert(p76._queuedResolve, v80);
			table.insert(p76._queuedReject, v81);
			return;
		end;
		if p76._status == v13.Status.Resolved then
			v80(unpack(p76._values, 1, p76._valuesLength));
			return;
		end;
		if p76._status == v13.Status.Rejected then
			v81(unpack(p76._values, 1, p76._valuesLength));
			return;
		end;
		if p76._status == v13.Status.Cancelled then
			p81(v6.new({
				error = "Promise is cancelled", 
				kind = v6.Kind.AlreadyCancelled, 
				context = "Promise created at\n\n" .. p77
			}));
		end;
	end, p76);
end;
v13.prototype.andThen = function(p82, p83, p84)
	local v82 = true;
	if p83 ~= nil then
		v82 = type(p83) == "function";
	end;
	assert(v82, string.format("Please pass a handler function to %s!", "Promise:andThen"));
	local v83 = true;
	if p84 ~= nil then
		v83 = type(p84) == "function";
	end;
	assert(v83, string.format("Please pass a handler function to %s!", "Promise:andThen"));
	return p82:_andThen(debug.traceback(nil, 2), p83, p84);
end;
v13.prototype.catch = function(p85, p86)
	local v84 = true;
	if p86 ~= nil then
		v84 = type(p86) == "function";
	end;
	assert(v84, string.format("Please pass a handler function to %s!", "Promise:catch"));
	return p85:_andThen(debug.traceback(nil, 2), nil, p86);
end;
v13.prototype.tap = function(p87, p88)
	assert(type(p88) == "function", string.format("Please pass a handler function to %s!", "Promise:tap"));
	return p87:_andThen(debug.traceback(nil, 2), function(...)
		local v85 = p88(...);
		if not v13.is(v85) then
			return ...;
		end;
		local v86, v87 = u9(...);
		return v85:andThen(function()
			return unpack(v87, 1, v86);
		end);
	end);
end;
v13.prototype.andThenCall = function(p89, p90, ...)
	assert(type(p90) == "function", string.format("Please pass a handler function to %s!", "Promise:andThenCall"));
	local v88, v89 = u9(...);
	return p89:_andThen(debug.traceback(nil, 2), function()
		return p90(unpack(v89, 1, v88));
	end);
end;
v13.prototype.andThenReturn = function(p91, ...)
	local v90, v91 = u9(...);
	return p91:_andThen(debug.traceback(nil, 2), function()
		return unpack(v91, 1, v90);
	end);
end;
v13.prototype.cancel = function(p92)
	if p92._status ~= v13.Status.Started then
		return;
	end;
	p92._status = v13.Status.Cancelled;
	if p92._cancellationHook then
		p92._cancellationHook();
	end;
	if p92._parent then
		p92._parent:_consumerCancelled(p92);
	end;
	for v92, v93 in pairs(p92._consumers) do
		v92:cancel();
	end;
	p92:_finalize();
end;
v13.prototype._consumerCancelled = function(p93, p94)
	if p93._status ~= v13.Status.Started then
		return;
	end;
	p93._consumers[p94] = nil;
	if next(p93._consumers) == nil then
		p93:cancel();
	end;
end;
v13.prototype._finally = function(p95, p96, p97, p98)
	if not p98 then
		p95._unhandledRejection = false;
	end;
	return v13._new(p96, function(p99, p100)
		local v94 = p99;
		if p97 then
			v94 = u28(p96, p97, p99, p100);
		end;
		if p98 then
			v94 = function(...)
				if p95._status == v13.Status.Rejected then
					return p99(p95);
				end;
				return v94(...);
			end;
		end;
		if p95._status == v13.Status.Started then
			table.insert(p95._queuedFinally, v94);
			return;
		end;
		v94(p95._status);
	end, p95);
end;
v13.prototype.finally = function(p101, p102)
	local v95 = true;
	if p102 ~= nil then
		v95 = type(p102) == "function";
	end;
	assert(v95, string.format("Please pass a handler function to %s!", "Promise:finally"));
	return p101:_finally(debug.traceback(nil, 2), p102);
end;
v13.prototype.finallyCall = function(p103, p104, ...)
	assert(type(p104) == "function", string.format("Please pass a handler function to %s!", "Promise:finallyCall"));
	local v96, v97 = u9(...);
	return p103:_finally(debug.traceback(nil, 2), function()
		return p104(unpack(v97, 1, v96));
	end);
end;
v13.prototype.finallyReturn = function(p105, ...)
	local v98, v99 = u9(...);
	return p105:_finally(debug.traceback(nil, 2), function()
		return unpack(v99, 1, v98);
	end);
end;
v13.prototype.done = function(p106, p107)
	local v100 = true;
	if p107 ~= nil then
		v100 = type(p107) == "function";
	end;
	assert(v100, string.format("Please pass a handler function to %s!", "Promise:done"));
	return p106:_finally(debug.traceback(nil, 2), p107, true);
end;
v13.prototype.doneCall = function(p108, p109, ...)
	assert(type(p109) == "function", string.format("Please pass a handler function to %s!", "Promise:doneCall"));
	local v101, v102 = u9(...);
	return p108:_finally(debug.traceback(nil, 2), function()
		return p109(unpack(v102, 1, v101));
	end, true);
end;
v13.prototype.doneReturn = function(p110, ...)
	local v103, v104 = u9(...);
	return p110:_finally(debug.traceback(nil, 2), function()
		return unpack(v104, 1, v103);
	end, true);
end;
v13.prototype.awaitStatus = function(p111)
	p111._unhandledRejection = false;
	if p111._status == v13.Status.Started then
		local u29 = Instance.new("BindableEvent");
		p111:finally(function()
			u29:Fire();
		end);
		u29.Event:Wait();
		u29:Destroy();
	end;
	if p111._status == v13.Status.Resolved then
		return p111._status, unpack(p111._values, 1, p111._valuesLength);
	end;
	if p111._status ~= v13.Status.Rejected then
		return p111._status;
	end;
	return p111._status, unpack(p111._values, 1, p111._valuesLength);
end;
local function u30(p112, ...)
	return p112 == v13.Status.Resolved, ...;
end;
v13.prototype.await = function(p113)
	return u30(p113:awaitStatus());
end;
local function u31(p114, ...)
	if p114 ~= v13.Status.Resolved then
		if ... == nil then
			local v105 = "Expected Promise rejected with no value.";
		else
			v105 = ...;
		end;
		error(v105, 3);
	end;
	return ...;
end;
v13.prototype.expect = function(p115)
	return u31(p115:awaitStatus());
end;
v13.prototype.awaitValue = v13.prototype.expect;
v13.prototype._unwrap = function(p116)
	if p116._status == v13.Status.Started then
		error("Promise has not resolved or rejected.", 2);
	end;
	return p116._status == v13.Status.Resolved, unpack(p116._values, 1, p116._valuesLength);
end;
v13.prototype._resolve = function(p117, ...)
	if p117._status ~= v13.Status.Started then
		if v13.is((...)) then
			(...):_consumerCancelled(p117);
		end;
		return;
	end;
	if not v13.is((...)) then
		p117._status = v13.Status.Resolved;
		local v106, v107 = u9(...);
		p117._valuesLength = v106;
		p117._values = v107;
		for v108, v109 in ipairs(p117._queuedResolve) do
			coroutine.wrap(v109)(...);
		end;
		p117:_finalize();
		return;
	end;
	if select("#", ...) > 1 then
		warn((string.format("When returning a Promise from andThen, extra arguments are discarded! See:\n\n%s", p117._source)));
	end;
	local u32 = ...;
	local v110 = u32:andThen(function(...)
		p117:_resolve(...);
	end, function(...)
		local v111 = u32._values[1];
		if u32._error then
			v111 = v6.new({
				error = u32._error, 
				kind = v6.Kind.ExecutionError, 
				context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]"
			});
		end;
		if not v6.isKind(v111, v6.Kind.ExecutionError) then
			p117:_reject(...);
			return;
		end;
		return p117:_reject(v111:extend({
			error = "This Promise was chained to a Promise that errored.", 
			trace = "", 
			context = string.format("The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n", p117._source)
		}));
	end);
	if v110._status == v13.Status.Cancelled then
		p117:cancel();
		return;
	end;
	if v110._status == v13.Status.Started then
		p117._parent = v110;
		v110._consumers[p117] = true;
	end;
end;
local function u33(p118)
	return next(p118) == nil;
end;
v13.prototype._reject = function(p119, ...)
	if p119._status ~= v13.Status.Started then
		return;
	end;
	p119._status = v13.Status.Rejected;
	local v112, v113 = u9(...);
	p119._valuesLength = v112;
	p119._values = v113;
	if not u33(p119._queuedReject) then
		for v114, v115 in ipairs(p119._queuedReject) do
			coroutine.wrap(v115)(...);
		end;
	else
		local u34 = tostring((...));
		coroutine.wrap(function()
			v13._timeEvent:Wait();
			if not p119._unhandledRejection then
				return;
			end;
			if v13.TEST then
				return;
			end;
			warn((string.format("Unhandled Promise rejection:\n\n%s\n\n%s", u34, p119._source)));
		end)();
	end;
	p119:_finalize();
end;
v13.prototype._finalize = function(p120)
	for v116, v117 in ipairs(p120._queuedFinally) do
		coroutine.wrap(v117)(p120._status);
	end;
	p120._queuedFinally = nil;
	p120._queuedReject = nil;
	p120._queuedResolve = nil;
	if not v13.TEST then
		p120._parent = nil;
		p120._consumers = nil;
	end;
end;
v13.prototype.now = function(p121, p122)
	local v118 = nil;
	v118 = debug.traceback(nil, 2);
	if p121:getStatus() == v13.Status.Resolved then
		return p121:_andThen(v118, function(...)
			return ...;
		end);
	end;
	if p122 == nil then
		local v119 = v6.new({
			kind = v6.Kind.NotResolvedInTime, 
			error = "This Promise was not resolved in time for :now()", 
			context = ":now() was called at:\n\n" .. v118
		}) or p122;
	else
		v119 = p122;
	end;
	return v13.reject(v119);
end;
function v13.retry(p123, p124, ...)
	assert(type(p123) == "function", "Parameter #1 to Promise.retry must be a function");
	assert(type(p124) == "number", "Parameter #2 to Promise.retry must be a number");
	local u35 = { ... };
	local u36 = select("#", ...);
	return v13.resolve(p123(...)):catch(function(...)
		if not (p124 > 0) then
			return v13.reject(...);
		end;
		return v13.retry(p123, p124 - 1, unpack(u35, 1, u36));
	end);
end;
function v13.fromEvent(p125, p126)
	p126 = p126 or function()
		return true;
	end;
	return v13._new(debug.traceback(nil, 2), function(p127, p128, p129)
		local u37 = nil;
		local function u38()
			u37:Disconnect();
			u37 = nil;
		end;
		local u39 = false;
		u37 = p125:Connect(function(...)
			local v120 = p126(...);
			if v120 == true then
				p127(...);
				if u37 then
					u38();
					return;
				else
					u39 = true;
					return;
				end;
			end;
			if type(v120) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean");
			end;
		end);
		if u39 and u37 then
			return u38();
		end;
		p129(function()
			u38();
		end);
	end);
end;
return v13;
