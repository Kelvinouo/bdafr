--[[VARIABLE DEFINITION ANOMALY DETECTED, DECOMPILATION OUTPUT POTENTIALLY INCORRECT]]--
-- Decompiled with the Synapse X Luau decompiler.

local function v1(p1, p2)
	local v2 = {};
	local v3, v4, v5 = ipairs(p2);
	while true do
		v3(v4, v5);
		if not v3 then
			break;
		end;
		v5 = v3;
		v2[v4] = v4;	
	end;
	local v6 = {};
	function v6.__index(p3, p4)
		error(string.format("%s is not in %s!", p4, p1), 2);
	end;
	function v6.__newindex()
		error(string.format("Creating new members in %s is not allowed!", p1), 2);
	end;
	return setmetatable(v2, v6);
end;
local v7 = {
	Kind = v1("Promise.Error.Kind", { "ExecutionError", "AlreadyCancelled", "NotResolvedInTime", "TimedOut" })
};
v7.__index = v7;
function v7.new(p5, p6)
	p5 = p5 or {};
	return setmetatable({
		error = tostring(p5.error) and "[This error has no error text.]", 
		trace = p5.trace, 
		context = p5.context, 
		kind = p5.kind, 
		parent = p6, 
		createdTick = os.clock(), 
		createdTrace = debug.traceback()
	}, v7);
end;
function v7.is(p7)
	local v8 = nil;
	if type(p7) == "table" then
		v8 = getmetatable(p7);
		if type(v8) ~= "table" then
			return false;
		end;
	else
		return false;
	end;
	local v9 = false;
	if rawget(p7, "error") ~= nil then
		v9 = type(rawget(v8, "extend")) == "function";
	end;
	return v9;
end;
function v7.isKind(p8, p9)
	assert(p9 ~= nil, "Argument #2 to Promise.Error.isKind must not be nil");
	return v7.is(p8) and p8.kind == p9;
end;
function v7.extend(p10, p11)
	p11 = p11 or {};
	p11.kind = p11.kind or p10.kind;
	return v7.new(p11, p10);
end;
function v7.getErrorChain(p12)
	local v10 = { p12 };
	while v10[#v10].parent do
		table.insert(v10, v10[#v10].parent);	
	end;
	return v10;
end;
function v7.__tostring(p13)
	local v11 = { string.format("-- Promise.Error(%s) --", p13.kind and "?") };
	local v12, v13, v14 = ipairs(p13:getErrorChain());
	while true do
		v12(v13, v14);
		if not v12 then
			break;
		end;
		v14 = v12;
		table.insert(v11, table.concat({ v13.trace or v13.error, v13.context }, "\n"));	
	end;
	return table.concat(v11, "\n");
end;
local function u1(p14, ...)
	return p14, select("#", ...), { ... };
end;
local function u2(p15, p16, ...)
	assert(p15 ~= nil);
	return u1(xpcall(p16, function(p17)
		if type(p17) == "table" then
			return p17;
		end;
		return v7.new({
			error = p17, 
			kind = v7.Kind.ExecutionError, 
			trace = debug.traceback(tostring(p17), 2), 
			context = "Promise created at:\n\n" .. p15
		});
	end, ...));
end;
local v15 = {
	Error = v7, 
	Status = v1("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }), 
	_getTime = os.clock, 
	_timeEvent = game:GetService("RunService").Heartbeat, 
	prototype = {}
};
v15.__index = v15.prototype;
local u3 = {
	__mode = "k"
};
function v15._new(p18, p19, p20)
	if p20 ~= nil and not v15.is(p20) then
		error("Argument #2 to Promise.new must be a promise or nil", 2);
	end;
	local v16 = {
		_source = p18, 
		_status = v15.Status.Started, 
		_values = nil, 
		_valuesLength = -1, 
		_unhandledRejection = true, 
		_queuedResolve = {}, 
		_queuedReject = {}, 
		_queuedFinally = {}, 
		_cancellationHook = nil, 
		_parent = p20, 
		_consumers = setmetatable({}, u3)
	};
	if p20 and p20._status == v15.Status.Started then
		p20._consumers[v16] = true;
	end;
	setmetatable(v16, v15);
	local function u4(...)
		v16:_resolve(...);
	end;
	local function u5(...)
		v16:_reject(...);
	end;
	local function u6(p21)
		if p21 then
			if v16._status == v15.Status.Cancelled then
				p21();
			else
				v16._cancellationHook = p21;
			end;
		end;
		return v16._status == v15.Status.Cancelled;
	end;
	coroutine.wrap(function()
		local v17, v18, v19 = u2(v16._source, p19, u4, u5, u6);
		if not v17 then
			u5(v19[1]);
		end;
	end)();
	return v16;
end;
function v15.new(p22)
	return v15._new(debug.traceback(nil, 2), p22);
end;
function v15.__tostring(p23)
	return string.format("Promise(%s)", p23:getStatus());
end;
function v15.defer(p24)
	local v20 = debug.traceback(nil, 2);
	return v15._new(v20, function(p25, p26, p27)
		local u7 = nil;
		u7 = v15._timeEvent:Connect(function()
			u7:Disconnect();
			local v21, v22, v23 = u2(v20, p24, p25, p26, p27);
			if not v21 then
				p26(v23[1]);
			end;
		end);
	end);
end;
v15.async = v15.defer;
local function u8(...)
	return select("#", ...), { ... };
end;
function v15.resolve(...)
	local v24, v25 = u8(...);
	return v15._new(debug.traceback(nil, 2), function(p28)
		p28(unpack(v25, 1, v24));
	end);
end;
function v15.reject(...)
	local v26, v27 = u8(...);
	return v15._new(debug.traceback(nil, 2), function(p29, p30)
		p30(unpack(v27, 1, v26));
	end);
end;
function v15._try(p31, p32, ...)
	local v28, v29 = u8(...);
	return v15._new(p31, function(p33)
		p33(p32(unpack(v29, 1, v28)));
	end);
end;
function v15.try(...)
	return v15._try(debug.traceback(nil, 2), ...);
end;
function v15._all(p34, p35, p36)
	if type(p35) ~= "table" then
		error(string.format("Please pass a list of promises to %s", "Promise.all"), 3);
	end;
	for v30, v31 in pairs(p35) do
		if not v15.is(v31) then
			error(string.format("Non-promise value passed into %s at index %s", "Promise.all", tostring(v30)), 3);
		end;
	end;
	if #p35 ~= 0 and p36 ~= 0 then
		return v15._new(p34, function(p37, p38, p39)
			local v32 = 0;
			local u9 = {};
			local u10 = false;
			local u11 = 0;
			local u12 = {};
			local function v33(p40, ...)
				if u10 then
					return;
				end;
				u11 = u11 + 1;
				if p36 == nil then
					u12[p40] = ...;
				else
					u12[u11] = ...;
				end;
				if (p36 or #p35) <= u11 then
					u10 = true;
					p37(u12);
					local v34, v35, v36 = ipairs(u9);
					while true do
						v34(v35, v36);
						if not v34 then
							break;
						end;
						v36 = v34;
						v35:cancel();					
					end;
				end;
			end;
			p39(function()
				local v37, v38, v39 = ipairs(u9);
				while true do
					v37(v38, v39);
					if not v37 then
						break;
					end;
					v39 = v37;
					v38:cancel();				
				end;
			end);
			local v40, v41, v42 = ipairs(p35);
			while true do
				v40(v41, v42);
				if not v40 then
					break;
				end;
				v42 = v40;
				local u13 = v32;
				u9[v40] = v41:andThen(function(...)
					v33(v40, ...);
				end, function(...)
					u13 = u13 + 1;
					if p36 == nil or #p35 - u13 < p36 then
						local v43, v44, v45 = ipairs(u9);
						while true do
							v43(v44, v45);
							if not v43 then
								break;
							end;
							v45 = v43;
							v44:cancel();						
						end;
						u10 = true;
						p38(...);
					end;
				end);			
			end;
			if u10 then
				local v46, v47, v48 = ipairs(u9);
				while true do
					v46(v47, v48);
					if not v46 then
						break;
					end;
					v48 = v46;
					v47:cancel();				
				end;
			end;
		end);
	end;
	return v15.resolve({});
end;
function v15.all(p41)
	return v15._all(debug.traceback(nil, 2), p41);
end;
function v15.some(p42, p43)
	assert(type(p43) == "number", "Bad argument #2 to Promise.some: must be a number");
	return v15._all(debug.traceback(nil, 2), p42, p43);
end;
function v15.any(p44)
	return v15._all(debug.traceback(nil, 2), p44, 1):andThen(function(p45)
		return p45[1];
	end);
end;
function v15.allSettled(p46)
	if type(p46) ~= "table" then
		error(string.format("Please pass a list of promises to %s", "Promise.allSettled"), 2);
	end;
	for v49, v50 in pairs(p46) do
		if not v15.is(v50) then
			error(string.format("Non-promise value passed into %s at index %s", "Promise.allSettled", tostring(v49)), 2);
		end;
	end;
	if #p46 == 0 then
		return v15.resolve({});
	end;
	return v15._new(debug.traceback(nil, 2), function(p47, p48, p49)
		local u14 = 0;
		local u15 = {};
		local function v51(p50, ...)
			u14 = u14 + 1;
			u15[p50] = ...;
			if #p46 <= u14 then
				p47(u15);
			end;
		end;
		local u16 = {};
		p49(function()
			local v52, v53, v54 = ipairs(u16);
			while true do
				v52(v53, v54);
				if not v52 then
					break;
				end;
				v54 = v52;
				v53:cancel();			
			end;
		end);
		local v55, v56, v57 = ipairs(p46);
		while true do
			v55(v56, v57);
			if not v55 then
				break;
			end;
			v57 = v55;
			u16[v55] = v56:finally(function(...)
				v51(v55, ...);
			end);		
		end;
	end);
end;
function v15.race(p51)
	assert(type(p51) == "table", string.format("Please pass a list of promises to %s", "Promise.race"));
	for v58, v59 in pairs(p51) do
		assert(v15.is(v59), string.format("Non-promise value passed into %s at index %s", "Promise.race", tostring(v58)));
	end;
	return v15._new(debug.traceback(nil, 2), function(p52, p53, p54)
		local u17 = {};
		local u18 = false;
		if p54(function(...)
			local v60, v61, v62 = ipairs(u17);
			while true do
				v60(v61, v62);
				if not v60 then
					break;
				end;
				v62 = v60;
				v61:cancel();			
			end;
			u18 = true;
			return p53(...);
		end) then
			return;
		end;
		local v63, v64, v65 = ipairs(p51);
		while true do
			v63(v64, v65);
			if not v63 then
				break;
			end;
			v65 = v63;
			u17[v63] = v64:andThen(function(...)
				local v66, v67, v68 = ipairs(u17);
				while true do
					v66(v67, v68);
					if not v66 then
						break;
					end;
					v68 = v66;
					v67:cancel();				
				end;
				u18 = true;
				return p52(...);
			end, function(...)
				local v69, v70, v71 = ipairs(u17);
				while true do
					v69(v70, v71);
					if not v69 then
						break;
					end;
					v71 = v69;
					v70:cancel();				
				end;
				u18 = true;
				return p53(...);
			end);		
		end;
		if u18 then
			local v72, v73, v74 = ipairs(u17);
			while true do
				v72(v73, v74);
				if not v72 then
					break;
				end;
				v74 = v72;
				v73:cancel();			
			end;
		end;
	end);
end;
function v15.each(p55, p56)
	assert(type(p55) == "table", string.format("Please pass a list of promises to %s", "Promise.each"));
	assert(type(p56) == "function", string.format("Please pass a handler function to %s!", "Promise.each"));
	return v15._new(debug.traceback(nil, 2), function(p57, p58, p59)
		local v75 = {};
		local u19 = {};
		local u20 = false;
		p59(function()
			u20 = true;
			local v76, v77, v78 = ipairs(u19);
			while true do
				v76(v77, v78);
				if not v76 then
					break;
				end;
				v78 = v76;
				v77:cancel();			
			end;
		end);
		local v79 = {};
		local v80, v81, v82 = ipairs(p55);
		while true do
			v80(v81, v82);
			if not v80 then
				break;
			end;
			v82 = v80;
			if v15.is(v81) then
				if v81:getStatus() == v15.Status.Cancelled then
					local v83, v84, v85 = ipairs(u19);
					while true do
						v83(v84, v85);
						if not v83 then
							break;
						end;
						v85 = v83;
						v84:cancel();					
					end;
					return p58(v7.new({
						error = "Promise is cancelled", 
						kind = v7.Kind.AlreadyCancelled, 
						context = string.format("The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s", v80, v81._source)
					}));
				end;
				if v81:getStatus() == v15.Status.Rejected then
					local v86, v87, v88 = ipairs(u19);
					while true do
						v86(v87, v88);
						if not v86 then
							break;
						end;
						v88 = v86;
						v87:cancel();					
					end;
					return p58(select(2, v81:await()));
				end;
				local v89 = v81:andThen(function(...)
					return ...;
				end);
				table.insert(u19, v89);
				v79[v80] = v89;
			else
				v79[v80] = v81;
			end;		
		end;
		local v90, v91, v92 = ipairs(v79);
		while true do
			local v93 = v91;
			v90(v93, v92);
			if not v90 then
				break;
			end;
			v92 = v90;
			if v15.is(v93) then
				local v94, v95 = v93:await();
				v93 = v95;
				if not v94 then
					local v96, v97, v98 = ipairs(u19);
					while true do
						v96(v97, v98);
						if not v96 then
							break;
						end;
						v98 = v96;
						v97:cancel();					
					end;
					return p58(v93);
				end;
			end;
			if u20 then
				return;
			end;
			local v99 = v15.resolve(p56(v93, v90));
			table.insert(u19, v99);
			local v100, v101 = v99:await();
			if not v100 then
				local v102, v103, v104 = ipairs(u19);
				while true do
					v102(v103, v104);
					if not v102 then
						break;
					end;
					v104 = v102;
					v103:cancel();				
				end;
				return p58(v101);
			end;
			v75[v90] = v101;		
		end;
		p57(v75);
	end);
end;
function v15.is(p60)
	if type(p60) ~= "table" then
		return false;
	end;
	local v105 = getmetatable(p60);
	if v105 == v15 then
		return true;
	end;
	if v105 == nil then
		return type(p60.andThen) == "function";
	end;
	if type(v105) == "table" and type(rawget(v105, "__index")) == "table" and type(rawget(rawget(v105, "__index"), "andThen")) == "function" then
		return true;
	end;
	return false;
end;
function v15.promisify(p61)
	return function(...)
		return v15._try(debug.traceback(nil, 2), p61, ...);
	end;
end;
local u21 = nil;
local u22 = nil;
function v15.delay(p62)
	assert(type(p62) == "number", "Bad argument #1 to Promise.delay, must be a number.");
	if not (p62 >= 0.016666666666666666) or p62 == math.huge then
		p62 = 0.016666666666666666;
	end;
	return v15._new(debug.traceback(nil, 2), function(p63, p64, p65)
		local v106 = v15._getTime();
		local v107 = v106 + p62;
		local v108 = {
			resolve = p63, 
			startTime = v106, 
			endTime = v107
		};
		if u21 == nil then
			u22 = v108;
			u21 = v15._timeEvent:Connect(function()
				while u22 ~= nil and u22.endTime < v15._getTime() do
					u22 = u22.next;
					if u22 == nil then
						u21:Disconnect();
						u21 = nil;
					else
						u22.previous = nil;
					end;
					u22.resolve(v15._getTime() - u22.startTime);				
				end;
			end);
		elseif u22.endTime < v107 then
			local v109 = u22;
			local v110 = v109.next;
			while v110 ~= nil and v110.endTime < v107 do
				v109 = v110;
				v110 = v109.next;			
			end;
			v109.next = v108;
			v108.previous = v109;
			if v110 ~= nil then
				v108.next = v110;
				v110.previous = v108;
			end;
		else
			v108.next = u22;
			u22.previous = v108;
			u22 = v108;
		end;
		p65(function()
			local l__next__111 = v108.next;
			if u22 ~= v108 then
				local l__previous__112 = v108.previous;
				l__previous__112.next = l__next__111;
				if l__next__111 ~= nil then
					l__next__111.previous = l__previous__112;
				end;
				return;
			end;
			if l__next__111 == nil then
				u21:Disconnect();
				u21 = nil;
			else
				l__next__111.previous = nil;
			end;
			u22 = l__next__111;
		end);
	end);
end;
v15.prototype.timeout = function(p66, p67, p68)
	local v113 = {};
	local u23 = debug.traceback(nil, 2);
	v113[1] = v15.delay(p67):andThen(function()
		if p68 == nil then
			local v114 = v7.new({
				kind = v7.Kind.TimedOut, 
				error = "Timed out", 
				context = string.format("Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s", p67, u23)
			}) or p68;
		else
			v114 = p68;
		end;
		return v15.reject(v114);
	end);
	v113[2] = p66;
	return v15.race(v113);
end;
v15.prototype.getStatus = function(p69)
	return p69._status;
end;
v15.prototype._andThen = function(p70, p71, p72, p73)
	p70._unhandledRejection = false;
	return v15._new(p71, function(p74, p75)
		local v115 = p74;
		if p72 then
			v115 = function(...)
				local v116 = nil;
				local v117 = nil;
				local v118 = nil;
				v117, v118, v116 = u2(p71, p72, ...);
				if not v117 then
					p75(v116[1]);
					return;
				end;
				p74(unpack(v116, 1, v118));
			end;
		end;
		local v119 = p75;
		if p73 then
			v119 = function(...)
				local v120 = nil;
				local v121 = nil;
				local v122 = nil;
				v121, v122, v120 = u2(p71, p73, ...);
				if not v121 then
					p75(v120[1]);
					return;
				end;
				p74(unpack(v120, 1, v122));
			end;
		end;
		if p70._status == v15.Status.Started then
			table.insert(p70._queuedResolve, v115);
			table.insert(p70._queuedReject, v119);
			return;
		end;
		if p70._status == v15.Status.Resolved then
			v115(unpack(p70._values, 1, p70._valuesLength));
			return;
		end;
		if p70._status == v15.Status.Rejected then
			v119(unpack(p70._values, 1, p70._valuesLength));
			return;
		end;
		if p70._status == v15.Status.Cancelled then
			p75(v7.new({
				error = "Promise is cancelled", 
				kind = v7.Kind.AlreadyCancelled, 
				context = "Promise created at\n\n" .. p71
			}));
		end;
	end, p70);
end;
v15.prototype.andThen = function(p76, p77, p78)
	local v123 = true;
	if p77 ~= nil then
		v123 = type(p77) == "function";
	end;
	assert(v123, string.format("Please pass a handler function to %s!", "Promise:andThen"));
	local v124 = true;
	if p78 ~= nil then
		v124 = type(p78) == "function";
	end;
	assert(v124, string.format("Please pass a handler function to %s!", "Promise:andThen"));
	return p76:_andThen(debug.traceback(nil, 2), p77, p78);
end;
v15.prototype.catch = function(p79, p80)
	local v125 = true;
	if p80 ~= nil then
		v125 = type(p80) == "function";
	end;
	assert(v125, string.format("Please pass a handler function to %s!", "Promise:catch"));
	return p79:_andThen(debug.traceback(nil, 2), nil, p80);
end;
v15.prototype.tap = function(p81, p82)
	assert(type(p82) == "function", string.format("Please pass a handler function to %s!", "Promise:tap"));
	return p81:_andThen(debug.traceback(nil, 2), function(...)
		local v126 = p82(...);
		if not v15.is(v126) then
			return ...;
		end;
		local v127, v128 = u8(...);
		return v126:andThen(function()
			return unpack(v128, 1, v127);
		end);
	end);
end;
v15.prototype.andThenCall = function(p83, p84, ...)
	assert(type(p84) == "function", string.format("Please pass a handler function to %s!", "Promise:andThenCall"));
	local v129, v130 = u8(...);
	return p83:_andThen(debug.traceback(nil, 2), function()
		return p84(unpack(v130, 1, v129));
	end);
end;
v15.prototype.andThenReturn = function(p85, ...)
	local v131, v132 = u8(...);
	return p85:_andThen(debug.traceback(nil, 2), function()
		return unpack(v132, 1, v131);
	end);
end;
v15.prototype.cancel = function(p86)
	if p86._status ~= v15.Status.Started then
		return;
	end;
	p86._status = v15.Status.Cancelled;
	if p86._cancellationHook then
		p86._cancellationHook();
	end;
	if p86._parent then
		p86._parent:_consumerCancelled(p86);
	end;
	for v133 in pairs(p86._consumers) do
		v133:cancel();
	end;
	p86:_finalize();
end;
v15.prototype._consumerCancelled = function(p87, p88)
	if p87._status ~= v15.Status.Started then
		return;
	end;
	p87._consumers[p88] = nil;
	if next(p87._consumers) == nil then
		p87:cancel();
	end;
end;
v15.prototype._finally = function(p89, p90, p91, p92)
	if not p92 then
		p89._unhandledRejection = false;
	end;
	return v15._new(p90, function(p93, p94)
		local v134 = p93;
		if p91 then
			v134 = function(...)
				local v135 = nil;
				local v136 = nil;
				local v137 = nil;
				v136, v137, v135 = u2(p90, p91, ...);
				if not v136 then
					p94(v135[1]);
					return;
				end;
				p93(unpack(v135, 1, v137));
			end;
		end;
		if p92 then
			v134 = function(...)
				if p89._status == v15.Status.Rejected then
					return p93(p89);
				end;
				return v134(...);
			end;
		end;
		if p89._status == v15.Status.Started then
			table.insert(p89._queuedFinally, v134);
			return;
		end;
		v134(p89._status);
	end, p89);
end;
v15.prototype.finally = function(p95, p96)
	local v138 = true;
	if p96 ~= nil then
		v138 = type(p96) == "function";
	end;
	assert(v138, string.format("Please pass a handler function to %s!", "Promise:finally"));
	return p95:_finally(debug.traceback(nil, 2), p96);
end;
v15.prototype.finallyCall = function(p97, p98, ...)
	assert(type(p98) == "function", string.format("Please pass a handler function to %s!", "Promise:finallyCall"));
	local v139, v140 = u8(...);
	return p97:_finally(debug.traceback(nil, 2), function()
		return p98(unpack(v140, 1, v139));
	end);
end;
v15.prototype.finallyReturn = function(p99, ...)
	local v141, v142 = u8(...);
	return p99:_finally(debug.traceback(nil, 2), function()
		return unpack(v142, 1, v141);
	end);
end;
v15.prototype.done = function(p100, p101)
	local v143 = true;
	if p101 ~= nil then
		v143 = type(p101) == "function";
	end;
	assert(v143, string.format("Please pass a handler function to %s!", "Promise:done"));
	return p100:_finally(debug.traceback(nil, 2), p101, true);
end;
v15.prototype.doneCall = function(p102, p103, ...)
	assert(type(p103) == "function", string.format("Please pass a handler function to %s!", "Promise:doneCall"));
	local v144, v145 = u8(...);
	return p102:_finally(debug.traceback(nil, 2), function()
		return p103(unpack(v145, 1, v144));
	end, true);
end;
v15.prototype.doneReturn = function(p104, ...)
	local v146, v147 = u8(...);
	return p104:_finally(debug.traceback(nil, 2), function()
		return unpack(v147, 1, v146);
	end, true);
end;
v15.prototype.awaitStatus = function(p105)
	p105._unhandledRejection = false;
	if p105._status == v15.Status.Started then
		local u24 = Instance.new("BindableEvent");
		p105:finally(function()
			u24:Fire();
		end);
		u24.Event:Wait();
		u24:Destroy();
	end;
	if p105._status == v15.Status.Resolved then
		return p105._status, unpack(p105._values, 1, p105._valuesLength);
	end;
	if p105._status ~= v15.Status.Rejected then
		return p105._status;
	end;
	return p105._status, unpack(p105._values, 1, p105._valuesLength);
end;
local function u25(p106, ...)
	return p106 == v15.Status.Resolved, ...;
end;
v15.prototype.await = function(p107)
	return u25(p107:awaitStatus());
end;
local function u26(p108, ...)
	if p108 ~= v15.Status.Resolved then
		if ... == nil then
			local v148 = "Expected Promise rejected with no value.";
		else
			v148 = ...;
		end;
		error(v148, 3);
	end;
	return ...;
end;
v15.prototype.expect = function(p109)
	return u26(p109:awaitStatus());
end;
v15.prototype.awaitValue = v15.prototype.expect;
v15.prototype._unwrap = function(p110)
	if p110._status == v15.Status.Started then
		error("Promise has not resolved or rejected.", 2);
	end;
	return p110._status == v15.Status.Resolved, unpack(p110._values, 1, p110._valuesLength);
end;
v15.prototype._resolve = function(p111, ...)
	if p111._status ~= v15.Status.Started then
		if v15.is((...)) then
			(...):_consumerCancelled(p111);
		end;
		return;
	end;
	if not v15.is((...)) then
		p111._status = v15.Status.Resolved;
		local v149, v150 = u8(...);
		p111._valuesLength = v149;
		p111._values = v150;
		local v151, v152, v153 = ipairs(p111._queuedResolve);
		while true do
			v151(v152, v153);
			if not v151 then
				break;
			end;
			v153 = v151;
			coroutine.wrap(v152)(...);		
		end;
		p111:_finalize();
		return;
	end;
	if select("#", ...) > 1 then
		warn((string.format("When returning a Promise from andThen, extra arguments are discarded! See:\n\n%s", p111._source)));
	end;
	local u27 = ...;
	local v154 = u27:andThen(function(...)
		p111:_resolve(...);
	end, function(...)
		local v155 = u27._values[1];
		if u27._error then
			v155 = v7.new({
				error = u27._error, 
				kind = v7.Kind.ExecutionError, 
				context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]"
			});
		end;
		if not v7.isKind(v155, v7.Kind.ExecutionError) then
			p111:_reject(...);
			return;
		end;
		return p111:_reject(v155:extend({
			error = "This Promise was chained to a Promise that errored.", 
			trace = "", 
			context = string.format("The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n", p111._source)
		}));
	end);
	if v154._status == v15.Status.Cancelled then
		p111:cancel();
		return;
	end;
	if v154._status == v15.Status.Started then
		p111._parent = v154;
		v154._consumers[p111] = true;
	end;
end;
v15.prototype._reject = function(p112, ...)
	if p112._status ~= v15.Status.Started then
		return;
	end;
	p112._status = v15.Status.Rejected;
	local v156, v157 = u8(...);
	p112._valuesLength = v156;
	p112._values = v157;
	if next(p112._queuedReject) ~= nil then
		local v158, v159, v160 = ipairs(p112._queuedReject);
		while true do
			v158(v159, v160);
			if not v158 then
				break;
			end;
			v160 = v158;
			coroutine.wrap(v159)(...);		
		end;
	else
		local u28 = tostring((...));
		coroutine.wrap(function()
			v15._timeEvent:Wait();
			if not p112._unhandledRejection then
				return;
			end;
			if v15.TEST then
				return;
			end;
			warn((string.format("Unhandled Promise rejection:\n\n%s\n\n%s", u28, p112._source)));
		end)();
	end;
	p112:_finalize();
end;
v15.prototype._finalize = function(p113)
	local v161, v162, v163 = ipairs(p113._queuedFinally);
	while true do
		v161(v162, v163);
		if not v161 then
			break;
		end;
		v163 = v161;
		coroutine.wrap(v162)(p113._status);	
	end;
	p113._queuedFinally = nil;
	p113._queuedReject = nil;
	p113._queuedResolve = nil;
	if not v15.TEST then
		p113._parent = nil;
		p113._consumers = nil;
	end;
end;
v15.prototype.now = function(p114, p115)
	local v164 = nil;
	v164 = debug.traceback(nil, 2);
	if p114:getStatus() == v15.Status.Resolved then
		return p114:_andThen(v164, function(...)
			return ...;
		end);
	end;
	if p115 == nil then
		local v165 = v7.new({
			kind = v7.Kind.NotResolvedInTime, 
			error = "This Promise was not resolved in time for :now()", 
			context = ":now() was called at:\n\n" .. v164
		}) or p115;
	else
		v165 = p115;
	end;
	return v15.reject(v165);
end;
function v15.retry(p116, p117, ...)
	assert(type(p116) == "function", "Parameter #1 to Promise.retry must be a function");
	assert(type(p117) == "number", "Parameter #2 to Promise.retry must be a number");
	local u29 = { ... };
	local u30 = select("#", ...);
	return v15.resolve(p116(...)):catch(function(...)
		if not (p117 > 0) then
			return v15.reject(...);
		end;
		return v15.retry(p116, p117 - 1, unpack(u29, 1, u30));
	end);
end;
function v15.fromEvent(p118, p119)
	p119 = p119 or function()
		return true;
	end;
	return v15._new(debug.traceback(nil, 2), function(p120, p121, p122)
		local u31 = nil;
		local u32 = false;
		u31 = p118:Connect(function(...)
			local v166 = p119(...);
			if v166 ~= true then
				if type(v166) ~= "boolean" then
					error("Promise.fromEvent predicate should always return a boolean");
				end;
				return;
			end;
			p120(...);
			if not u31 then
				u32 = true;
				return;
			end;
			u31:Disconnect();
			u31 = nil;
		end);
		if u32 and u31 then
			return (function()
				u31:Disconnect();
				u31 = nil;
			end)();
		end;
		p122(function()
			u31:Disconnect();
			u31 = nil;
		end);
	end);
end;
return v15;
