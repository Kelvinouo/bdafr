--[[VARIABLE DEFINITION ANOMALY DETECTED, DECOMPILATION OUTPUT POTENTIALLY INCORRECT]]--
-- Decompiled with the Synapse X Luau decompiler.

local function v1(p1, p2)
	local v2 = {};
	for v3, v4 in ipairs(p2) do
		v2[v4] = v4;
	end;
	local v5 = {};
	function v5.__index(p3, p4)
		error(string.format("%s is not in %s!", p4, p1), 2);
	end;
	function v5.__newindex()
		error(string.format("Creating new members in %s is not allowed!", p1), 2);
	end;
	return setmetatable(v2, v5);
end;
local v6 = {
	Kind = v1("Promise.Error.Kind", { "ExecutionError", "AlreadyCancelled", "NotResolvedInTime", "TimedOut" })
};
v6.__index = v6;
function v6.new(p5, p6)
	p5 = p5 or {};
	return setmetatable({
		error = tostring(p5.error) and "[This error has no error text.]", 
		trace = p5.trace, 
		context = p5.context, 
		kind = p5.kind, 
		parent = p6, 
		createdTick = os.clock(), 
		createdTrace = debug.traceback()
	}, v6);
end;
function v6.is(p7)
	local v7 = nil;
	if type(p7) == "table" then
		v7 = getmetatable(p7);
		if type(v7) ~= "table" then
			return false;
		end;
	else
		return false;
	end;
	local v8 = false;
	if rawget(p7, "error") ~= nil then
		v8 = type(rawget(v7, "extend")) == "function";
	end;
	return v8;
end;
function v6.isKind(p8, p9)
	assert(p9 ~= nil, "Argument #2 to Promise.Error.isKind must not be nil");
	return v6.is(p8) and p8.kind == p9;
end;
function v6.extend(p10, p11)
	p11 = p11 or {};
	p11.kind = p11.kind or p10.kind;
	return v6.new(p11, p10);
end;
function v6.getErrorChain(p12)
	local v9 = { p12 };
	while v9[#v9].parent do
		table.insert(v9, v9[#v9].parent);	
	end;
	return v9;
end;
function v6.__tostring(p13)
	local v10 = { string.format("-- Promise.Error(%s) --", p13.kind and "?") };
	for v11, v12 in ipairs(p13:getErrorChain()) do
		table.insert(v10, table.concat({ v12.trace or v12.error, v12.context }, "\n"));
	end;
	return table.concat(v10, "\n");
end;
local function u1(p14, ...)
	return p14, select("#", ...), { ... };
end;
local function u2(p15, p16, ...)
	assert(p15 ~= nil);
	return u1(xpcall(p16, function(p17)
		if type(p17) == "table" then
			return p17;
		end;
		return v6.new({
			error = p17, 
			kind = v6.Kind.ExecutionError, 
			trace = debug.traceback(tostring(p17), 2), 
			context = "Promise created at:\n\n" .. p15
		});
	end, ...));
end;
local v13 = {
	Error = v6, 
	Status = v1("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }), 
	_getTime = os.clock, 
	_timeEvent = game:GetService("RunService").Heartbeat, 
	prototype = {}
};
v13.__index = v13.prototype;
local u3 = {
	__mode = "k"
};
function v13._new(p18, p19, p20)
	if p20 ~= nil and not v13.is(p20) then
		error("Argument #2 to Promise.new must be a promise or nil", 2);
	end;
	local v14 = {
		_source = p18, 
		_status = v13.Status.Started, 
		_values = nil, 
		_valuesLength = -1, 
		_unhandledRejection = true, 
		_queuedResolve = {}, 
		_queuedReject = {}, 
		_queuedFinally = {}, 
		_cancellationHook = nil, 
		_parent = p20, 
		_consumers = setmetatable({}, u3)
	};
	if p20 and p20._status == v13.Status.Started then
		p20._consumers[v14] = true;
	end;
	setmetatable(v14, v13);
	local function u4(...)
		v14:_resolve(...);
	end;
	local function u5(...)
		v14:_reject(...);
	end;
	local function u6(p21)
		if p21 then
			if v14._status == v13.Status.Cancelled then
				p21();
			else
				v14._cancellationHook = p21;
			end;
		end;
		return v14._status == v13.Status.Cancelled;
	end;
	coroutine.wrap(function()
		local v15, v16, v17 = u2(v14._source, p19, u4, u5, u6);
		if not v15 then
			u5(v17[1]);
		end;
	end)();
	return v14;
end;
function v13.new(p22)
	return v13._new(debug.traceback(nil, 2), p22);
end;
function v13.__tostring(p23)
	return string.format("Promise(%s)", p23:getStatus());
end;
function v13.defer(p24)
	local v18 = debug.traceback(nil, 2);
	return v13._new(v18, function(p25, p26, p27)
		local u7 = nil;
		u7 = v13._timeEvent:Connect(function()
			u7:Disconnect();
			local v19, v20, v21 = u2(v18, p24, p25, p26, p27);
			if not v19 then
				p26(v21[1]);
			end;
		end);
	end);
end;
v13.async = v13.defer;
local function u8(...)
	return select("#", ...), { ... };
end;
function v13.resolve(...)
	local v22, v23 = u8(...);
	return v13._new(debug.traceback(nil, 2), function(p28)
		p28(unpack(v23, 1, v22));
	end);
end;
function v13.reject(...)
	local v24, v25 = u8(...);
	return v13._new(debug.traceback(nil, 2), function(p29, p30)
		p30(unpack(v25, 1, v24));
	end);
end;
function v13._try(p31, p32, ...)
	local v26, v27 = u8(...);
	return v13._new(p31, function(p33)
		p33(p32(unpack(v27, 1, v26)));
	end);
end;
function v13.try(...)
	return v13._try(debug.traceback(nil, 2), ...);
end;
function v13._all(p34, p35, p36)
	if type(p35) ~= "table" then
		error(string.format("Please pass a list of promises to %s", "Promise.all"), 3);
	end;
	for v28, v29 in pairs(p35) do
		if not v13.is(v29) then
			error(string.format("Non-promise value passed into %s at index %s", "Promise.all", tostring(v28)), 3);
		end;
	end;
	if #p35 ~= 0 and p36 ~= 0 then
		return v13._new(p34, function(p37, p38, p39)
			local v30 = 0;
			local u9 = {};
			local u10 = false;
			local u11 = 0;
			local u12 = {};
			local function v31(p40, ...)
				if u10 then
					return;
				end;
				u11 = u11 + 1;
				if p36 == nil then
					u12[p40] = ...;
				else
					u12[u11] = ...;
				end;
				if (p36 or #p35) <= u11 then
					u10 = true;
					p37(u12);
					for v32, v33 in ipairs(u9) do
						v33:cancel();
					end;
				end;
			end;
			p39(function()
				for v34, v35 in ipairs(u9) do
					v35:cancel();
				end;
			end);
			for v36, v37 in ipairs(p35) do
				local u13 = v30;
				u9[v36] = v37:andThen(function(...)
					v31(v36, ...);
				end, function(...)
					u13 = u13 + 1;
					if p36 == nil or #p35 - u13 < p36 then
						for v38, v39 in ipairs(u9) do
							v39:cancel();
						end;
						u10 = true;
						p38(...);
					end;
				end);
			end;
			if u10 then
				for v40, v41 in ipairs(u9) do
					v41:cancel();
				end;
			end;
		end);
	end;
	return v13.resolve({});
end;
function v13.all(p41)
	return v13._all(debug.traceback(nil, 2), p41);
end;
function v13.some(p42, p43)
	assert(type(p43) == "number", "Bad argument #2 to Promise.some: must be a number");
	return v13._all(debug.traceback(nil, 2), p42, p43);
end;
function v13.any(p44)
	return v13._all(debug.traceback(nil, 2), p44, 1):andThen(function(p45)
		return p45[1];
	end);
end;
function v13.allSettled(p46)
	if type(p46) ~= "table" then
		error(string.format("Please pass a list of promises to %s", "Promise.allSettled"), 2);
	end;
	for v42, v43 in pairs(p46) do
		if not v13.is(v43) then
			error(string.format("Non-promise value passed into %s at index %s", "Promise.allSettled", tostring(v42)), 2);
		end;
	end;
	if #p46 == 0 then
		return v13.resolve({});
	end;
	return v13._new(debug.traceback(nil, 2), function(p47, p48, p49)
		local u14 = 0;
		local u15 = {};
		local function v44(p50, ...)
			u14 = u14 + 1;
			u15[p50] = ...;
			if #p46 <= u14 then
				p47(u15);
			end;
		end;
		local u16 = {};
		p49(function()
			for v45, v46 in ipairs(u16) do
				v46:cancel();
			end;
		end);
		for v47, v48 in ipairs(p46) do
			u16[v47] = v48:finally(function(...)
				v44(v47, ...);
			end);
		end;
	end);
end;
function v13.race(p51)
	assert(type(p51) == "table", string.format("Please pass a list of promises to %s", "Promise.race"));
	for v49, v50 in pairs(p51) do
		assert(v13.is(v50), string.format("Non-promise value passed into %s at index %s", "Promise.race", tostring(v49)));
	end;
	return v13._new(debug.traceback(nil, 2), function(p52, p53, p54)
		local u17 = {};
		local u18 = false;
		if p54(function(...)
			for v51, v52 in ipairs(u17) do
				v52:cancel();
			end;
			u18 = true;
			return p53(...);
		end) then
			return;
		end;
		for v53, v54 in ipairs(p51) do
			u17[v53] = v54:andThen(function(...)
				for v55, v56 in ipairs(u17) do
					v56:cancel();
				end;
				u18 = true;
				return p52(...);
			end, function(...)
				for v57, v58 in ipairs(u17) do
					v58:cancel();
				end;
				u18 = true;
				return p53(...);
			end);
		end;
		if u18 then
			for v59, v60 in ipairs(u17) do
				v60:cancel();
			end;
		end;
	end);
end;
function v13.each(p55, p56)
	assert(type(p55) == "table", string.format("Please pass a list of promises to %s", "Promise.each"));
	assert(type(p56) == "function", string.format("Please pass a handler function to %s!", "Promise.each"));
	return v13._new(debug.traceback(nil, 2), function(p57, p58, p59)
		local v61 = {};
		local u19 = {};
		local u20 = false;
		p59(function()
			u20 = true;
			for v62, v63 in ipairs(u19) do
				v63:cancel();
			end;
		end);
		local v64 = {};
		for v65, v66 in ipairs(p55) do
			if v13.is(v66) then
				if v66:getStatus() == v13.Status.Cancelled then
					for v67, v68 in ipairs(u19) do
						v68:cancel();
					end;
					return p58(v6.new({
						error = "Promise is cancelled", 
						kind = v6.Kind.AlreadyCancelled, 
						context = string.format("The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s", v65, v66._source)
					}));
				end;
				if v66:getStatus() == v13.Status.Rejected then
					for v69, v70 in ipairs(u19) do
						v70:cancel();
					end;
					return p58(select(2, v66:await()));
				end;
				local v71 = v66:andThen(function(...)
					return ...;
				end);
				table.insert(u19, v71);
				v64[v65] = v71;
			else
				v64[v65] = v66;
			end;
		end;
		for v72, v73 in ipairs(v64) do
			if v13.is(local v74) then
				local v75, v73 = v74:await();
				if not v75 then
					for v76, v77 in ipairs(u19) do
						v77:cancel();
					end;
					return p58(v73);
				end;
			end;
			if u20 then
				return;
			end;
			local v78 = v13.resolve(p56(v73, v72));
			table.insert(u19, v78);
			local v79, v80 = v78:await();
			if not v79 then
				for v81, v82 in ipairs(u19) do
					v82:cancel();
				end;
				return p58(v80);
			end;
			v61[v72] = v80;
		end;
		p57(v61);
	end);
end;
function v13.is(p60)
	if type(p60) ~= "table" then
		return false;
	end;
	local v83 = getmetatable(p60);
	if v83 == v13 then
		return true;
	end;
	if v83 == nil then
		return type(p60.andThen) == "function";
	end;
	if type(v83) == "table" and type(rawget(v83, "__index")) == "table" and type(rawget(rawget(v83, "__index"), "andThen")) == "function" then
		return true;
	end;
	return false;
end;
function v13.promisify(p61)
	return function(...)
		return v13._try(debug.traceback(nil, 2), p61, ...);
	end;
end;
local u21 = nil;
local u22 = nil;
function v13.delay(p62)
	assert(type(p62) == "number", "Bad argument #1 to Promise.delay, must be a number.");
	if not (p62 >= 0.016666666666666666) or p62 == math.huge then
		p62 = 0.016666666666666666;
	end;
	return v13._new(debug.traceback(nil, 2), function(p63, p64, p65)
		local v84 = v13._getTime();
		local v85 = v84 + p62;
		local v86 = {
			resolve = p63, 
			startTime = v84, 
			endTime = v85
		};
		if u21 == nil then
			u22 = v86;
			u21 = v13._timeEvent:Connect(function()
				while u22 ~= nil and u22.endTime < v13._getTime() do
					u22 = u22.next;
					if u22 == nil then
						u21:Disconnect();
						u21 = nil;
					else
						u22.previous = nil;
					end;
					u22.resolve(v13._getTime() - u22.startTime);				
				end;
			end);
		elseif u22.endTime < v85 then
			local v87 = u22;
			local v88 = v87.next;
			while v88 ~= nil and v88.endTime < v85 do
				v87 = v88;
				v88 = v87.next;			
			end;
			v87.next = v86;
			v86.previous = v87;
			if v88 ~= nil then
				v86.next = v88;
				v88.previous = v86;
			end;
		else
			v86.next = u22;
			u22.previous = v86;
			u22 = v86;
		end;
		p65(function()
			local l__next__89 = v86.next;
			if u22 ~= v86 then
				local l__previous__90 = v86.previous;
				l__previous__90.next = l__next__89;
				if l__next__89 ~= nil then
					l__next__89.previous = l__previous__90;
				end;
				return;
			end;
			if l__next__89 == nil then
				u21:Disconnect();
				u21 = nil;
			else
				l__next__89.previous = nil;
			end;
			u22 = l__next__89;
		end);
	end);
end;
v13.prototype.timeout = function(p66, p67, p68)
	local v91 = {};
	local u23 = debug.traceback(nil, 2);
	v91[1] = v13.delay(p67):andThen(function()
		if p68 == nil then
			local v92 = v6.new({
				kind = v6.Kind.TimedOut, 
				error = "Timed out", 
				context = string.format("Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s", p67, u23)
			}) or p68;
		else
			v92 = p68;
		end;
		return v13.reject(v92);
	end);
	v91[2] = p66;
	return v13.race(v91);
end;
v13.prototype.getStatus = function(p69)
	return p69._status;
end;
v13.prototype._andThen = function(p70, p71, p72, p73)
	p70._unhandledRejection = false;
	return v13._new(p71, function(p74, p75)
		local v93 = p74;
		if p72 then
			v93 = function(...)
				local v94 = nil;
				local v95 = nil;
				local v96 = nil;
				v95, v96, v94 = u2(p71, p72, ...);
				if not v95 then
					p75(v94[1]);
					return;
				end;
				p74(unpack(v94, 1, v96));
			end;
		end;
		local v97 = p75;
		if p73 then
			v97 = function(...)
				local v98 = nil;
				local v99 = nil;
				local v100 = nil;
				v99, v100, v98 = u2(p71, p73, ...);
				if not v99 then
					p75(v98[1]);
					return;
				end;
				p74(unpack(v98, 1, v100));
			end;
		end;
		if p70._status == v13.Status.Started then
			table.insert(p70._queuedResolve, v93);
			table.insert(p70._queuedReject, v97);
			return;
		end;
		if p70._status == v13.Status.Resolved then
			v93(unpack(p70._values, 1, p70._valuesLength));
			return;
		end;
		if p70._status == v13.Status.Rejected then
			v97(unpack(p70._values, 1, p70._valuesLength));
			return;
		end;
		if p70._status == v13.Status.Cancelled then
			p75(v6.new({
				error = "Promise is cancelled", 
				kind = v6.Kind.AlreadyCancelled, 
				context = "Promise created at\n\n" .. p71
			}));
		end;
	end, p70);
end;
v13.prototype.andThen = function(p76, p77, p78)
	local v101 = true;
	if p77 ~= nil then
		v101 = type(p77) == "function";
	end;
	assert(v101, string.format("Please pass a handler function to %s!", "Promise:andThen"));
	local v102 = true;
	if p78 ~= nil then
		v102 = type(p78) == "function";
	end;
	assert(v102, string.format("Please pass a handler function to %s!", "Promise:andThen"));
	return p76:_andThen(debug.traceback(nil, 2), p77, p78);
end;
v13.prototype.catch = function(p79, p80)
	local v103 = true;
	if p80 ~= nil then
		v103 = type(p80) == "function";
	end;
	assert(v103, string.format("Please pass a handler function to %s!", "Promise:catch"));
	return p79:_andThen(debug.traceback(nil, 2), nil, p80);
end;
v13.prototype.tap = function(p81, p82)
	assert(type(p82) == "function", string.format("Please pass a handler function to %s!", "Promise:tap"));
	return p81:_andThen(debug.traceback(nil, 2), function(...)
		local v104 = p82(...);
		if not v13.is(v104) then
			return ...;
		end;
		local v105, v106 = u8(...);
		return v104:andThen(function()
			return unpack(v106, 1, v105);
		end);
	end);
end;
v13.prototype.andThenCall = function(p83, p84, ...)
	assert(type(p84) == "function", string.format("Please pass a handler function to %s!", "Promise:andThenCall"));
	local v107, v108 = u8(...);
	return p83:_andThen(debug.traceback(nil, 2), function()
		return p84(unpack(v108, 1, v107));
	end);
end;
v13.prototype.andThenReturn = function(p85, ...)
	local v109, v110 = u8(...);
	return p85:_andThen(debug.traceback(nil, 2), function()
		return unpack(v110, 1, v109);
	end);
end;
v13.prototype.cancel = function(p86)
	if p86._status ~= v13.Status.Started then
		return;
	end;
	p86._status = v13.Status.Cancelled;
	if p86._cancellationHook then
		p86._cancellationHook();
	end;
	if p86._parent then
		p86._parent:_consumerCancelled(p86);
	end;
	for v111 in pairs(p86._consumers) do
		v111:cancel();
	end;
	p86:_finalize();
end;
v13.prototype._consumerCancelled = function(p87, p88)
	if p87._status ~= v13.Status.Started then
		return;
	end;
	p87._consumers[p88] = nil;
	if next(p87._consumers) == nil then
		p87:cancel();
	end;
end;
v13.prototype._finally = function(p89, p90, p91, p92)
	if not p92 then
		p89._unhandledRejection = false;
	end;
	return v13._new(p90, function(p93, p94)
		local v112 = p93;
		if p91 then
			v112 = function(...)
				local v113 = nil;
				local v114 = nil;
				local v115 = nil;
				v114, v115, v113 = u2(p90, p91, ...);
				if not v114 then
					p94(v113[1]);
					return;
				end;
				p93(unpack(v113, 1, v115));
			end;
		end;
		if p92 then
			v112 = function(...)
				if p89._status == v13.Status.Rejected then
					return p93(p89);
				end;
				return v112(...);
			end;
		end;
		if p89._status == v13.Status.Started then
			table.insert(p89._queuedFinally, v112);
			return;
		end;
		v112(p89._status);
	end, p89);
end;
v13.prototype.finally = function(p95, p96)
	local v116 = true;
	if p96 ~= nil then
		v116 = type(p96) == "function";
	end;
	assert(v116, string.format("Please pass a handler function to %s!", "Promise:finally"));
	return p95:_finally(debug.traceback(nil, 2), p96);
end;
v13.prototype.finallyCall = function(p97, p98, ...)
	assert(type(p98) == "function", string.format("Please pass a handler function to %s!", "Promise:finallyCall"));
	local v117, v118 = u8(...);
	return p97:_finally(debug.traceback(nil, 2), function()
		return p98(unpack(v118, 1, v117));
	end);
end;
v13.prototype.finallyReturn = function(p99, ...)
	local v119, v120 = u8(...);
	return p99:_finally(debug.traceback(nil, 2), function()
		return unpack(v120, 1, v119);
	end);
end;
v13.prototype.done = function(p100, p101)
	local v121 = true;
	if p101 ~= nil then
		v121 = type(p101) == "function";
	end;
	assert(v121, string.format("Please pass a handler function to %s!", "Promise:done"));
	return p100:_finally(debug.traceback(nil, 2), p101, true);
end;
v13.prototype.doneCall = function(p102, p103, ...)
	assert(type(p103) == "function", string.format("Please pass a handler function to %s!", "Promise:doneCall"));
	local v122, v123 = u8(...);
	return p102:_finally(debug.traceback(nil, 2), function()
		return p103(unpack(v123, 1, v122));
	end, true);
end;
v13.prototype.doneReturn = function(p104, ...)
	local v124, v125 = u8(...);
	return p104:_finally(debug.traceback(nil, 2), function()
		return unpack(v125, 1, v124);
	end, true);
end;
v13.prototype.awaitStatus = function(p105)
	p105._unhandledRejection = false;
	if p105._status == v13.Status.Started then
		local u24 = Instance.new("BindableEvent");
		p105:finally(function()
			u24:Fire();
		end);
		u24.Event:Wait();
		u24:Destroy();
	end;
	if p105._status == v13.Status.Resolved then
		return p105._status, unpack(p105._values, 1, p105._valuesLength);
	end;
	if p105._status ~= v13.Status.Rejected then
		return p105._status;
	end;
	return p105._status, unpack(p105._values, 1, p105._valuesLength);
end;
local function u25(p106, ...)
	return p106 == v13.Status.Resolved, ...;
end;
v13.prototype.await = function(p107)
	return u25(p107:awaitStatus());
end;
local function u26(p108, ...)
	if p108 ~= v13.Status.Resolved then
		if ... == nil then
			local v126 = "Expected Promise rejected with no value.";
		else
			v126 = ...;
		end;
		error(v126, 3);
	end;
	return ...;
end;
v13.prototype.expect = function(p109)
	return u26(p109:awaitStatus());
end;
v13.prototype.awaitValue = v13.prototype.expect;
v13.prototype._unwrap = function(p110)
	if p110._status == v13.Status.Started then
		error("Promise has not resolved or rejected.", 2);
	end;
	return p110._status == v13.Status.Resolved, unpack(p110._values, 1, p110._valuesLength);
end;
v13.prototype._resolve = function(p111, ...)
	if p111._status ~= v13.Status.Started then
		if v13.is((...)) then
			(...):_consumerCancelled(p111);
		end;
		return;
	end;
	if not v13.is((...)) then
		p111._status = v13.Status.Resolved;
		local v127, v128 = u8(...);
		p111._valuesLength = v127;
		p111._values = v128;
		for v129, v130 in ipairs(p111._queuedResolve) do
			coroutine.wrap(v130)(...);
		end;
		p111:_finalize();
		return;
	end;
	if select("#", ...) > 1 then
		warn((string.format("When returning a Promise from andThen, extra arguments are discarded! See:\n\n%s", p111._source)));
	end;
	local u27 = ...;
	local v131 = u27:andThen(function(...)
		p111:_resolve(...);
	end, function(...)
		local v132 = u27._values[1];
		if u27._error then
			v132 = v6.new({
				error = u27._error, 
				kind = v6.Kind.ExecutionError, 
				context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]"
			});
		end;
		if not v6.isKind(v132, v6.Kind.ExecutionError) then
			p111:_reject(...);
			return;
		end;
		return p111:_reject(v132:extend({
			error = "This Promise was chained to a Promise that errored.", 
			trace = "", 
			context = string.format("The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n", p111._source)
		}));
	end);
	if v131._status == v13.Status.Cancelled then
		p111:cancel();
		return;
	end;
	if v131._status == v13.Status.Started then
		p111._parent = v131;
		v131._consumers[p111] = true;
	end;
end;
v13.prototype._reject = function(p112, ...)
	if p112._status ~= v13.Status.Started then
		return;
	end;
	p112._status = v13.Status.Rejected;
	local v133, v134 = u8(...);
	p112._valuesLength = v133;
	p112._values = v134;
	if next(p112._queuedReject) ~= nil then
		for v135, v136 in ipairs(p112._queuedReject) do
			coroutine.wrap(v136)(...);
		end;
	else
		local u28 = tostring((...));
		coroutine.wrap(function()
			v13._timeEvent:Wait();
			if not p112._unhandledRejection then
				return;
			end;
			if v13.TEST then
				return;
			end;
			warn((string.format("Unhandled Promise rejection:\n\n%s\n\n%s", u28, p112._source)));
		end)();
	end;
	p112:_finalize();
end;
v13.prototype._finalize = function(p113)
	for v137, v138 in ipairs(p113._queuedFinally) do
		coroutine.wrap(v138)(p113._status);
	end;
	p113._queuedFinally = nil;
	p113._queuedReject = nil;
	p113._queuedResolve = nil;
	if not v13.TEST then
		p113._parent = nil;
		p113._consumers = nil;
	end;
end;
v13.prototype.now = function(p114, p115)
	local v139 = nil;
	v139 = debug.traceback(nil, 2);
	if p114:getStatus() == v13.Status.Resolved then
		return p114:_andThen(v139, function(...)
			return ...;
		end);
	end;
	if p115 == nil then
		local v140 = v6.new({
			kind = v6.Kind.NotResolvedInTime, 
			error = "This Promise was not resolved in time for :now()", 
			context = ":now() was called at:\n\n" .. v139
		}) or p115;
	else
		v140 = p115;
	end;
	return v13.reject(v140);
end;
function v13.retry(p116, p117, ...)
	assert(type(p116) == "function", "Parameter #1 to Promise.retry must be a function");
	assert(type(p117) == "number", "Parameter #2 to Promise.retry must be a number");
	local u29 = { ... };
	local u30 = select("#", ...);
	return v13.resolve(p116(...)):catch(function(...)
		if not (p117 > 0) then
			return v13.reject(...);
		end;
		return v13.retry(p116, p117 - 1, unpack(u29, 1, u30));
	end);
end;
function v13.fromEvent(p118, p119)
	p119 = p119 or function()
		return true;
	end;
	return v13._new(debug.traceback(nil, 2), function(p120, p121, p122)
		local u31 = nil;
		local u32 = false;
		u31 = p118:Connect(function(...)
			local v141 = p119(...);
			if v141 ~= true then
				if type(v141) ~= "boolean" then
					error("Promise.fromEvent predicate should always return a boolean");
				end;
				return;
			end;
			p120(...);
			if not u31 then
				u32 = true;
				return;
			end;
			u31:Disconnect();
			u31 = nil;
		end);
		if u32 and u31 then
			return (function()
				u31:Disconnect();
				u31 = nil;
			end)();
		end;
		p122(function()
			u31:Disconnect();
			u31 = nil;
		end);
	end);
end;
return v13;
