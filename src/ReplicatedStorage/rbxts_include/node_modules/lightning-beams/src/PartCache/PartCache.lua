-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
v1.__index = v1;
v1.__type = "PartCache";
local u1 = CFrame.new(0, 1000000000, 0);
local function u2(p1, p2)
	if p1 == false then
		warn(p2);
	end;
end;
local u3 = require(script.Parent:WaitForChild("Table"));
local function u4(p3, p4)
	local v2 = p3:Clone();
	v2.CFrame = u1;
	v2.Anchored = true;
	v2.Parent = p4;
	return v2;
end;
function v1.new(p5, p6, p7)
	assert(p6 > 0, "PrecreatedParts can not be negative!");
	u2(p6 ~= 0, "PrecreatedParts is 0! This may have adverse effects when initially using the cache.");
	u2(p5.Archivable, "The template's Archivable property has been set to false, which prevents it from being cloned. It will temporarily be set to true.");
	p5.Archivable = true;
	p5.Archivable = p5.Archivable;
	p5 = p5:Clone();
	local v3 = {
		Open = {}, 
		InUse = {}, 
		CurrentCacheParent = p7 or workspace, 
		Template = p5, 
		ExpansionSize = 10
	};
	setmetatable(v3, v1);
	for v4 = 1, p6 and 5 do
		u3.insert(v3.Open, u4(p5, v3.CurrentCacheParent));
	end;
	v3.Template.Parent = nil;
	return v3;
end;
function v1.GetPart(p8)
	assert(getmetatable(p8) == v1, ("Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"):format("GetPart", "PartCache.new"));
	if #p8.Open == 0 then
		warn("No parts available in the cache! Creating [" .. p8.ExpansionSize .. "] new part instance(s) - this amount can be edited by changing the ExpansionSize property of the PartCache instance... (This cache now contains a grand total of " .. tostring(#p8.Open + #p8.InUse + p8.ExpansionSize) .. " parts.)");
		for v5 = 1, p8.ExpansionSize do
			u3.insert(p8.Open, u4(p8.Template, p8.CurrentCacheParent));
		end;
	end;
	local v6 = p8.Open[#p8.Open];
	p8.Open[#p8.Open] = nil;
	u3.insert(p8.InUse, v6);
	return v6;
end;
function v1.ReturnPart(p9, p10)
	assert(getmetatable(p9) == v1, ("Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"):format("ReturnPart", "PartCache.new"));
	local v7 = u3.indexOf(p9.InUse, p10);
	if v7 == nil then
		error("Attempted to return part \"" .. p10.Name .. "\" (" .. p10:GetFullName() .. ") to the cache, but it's not in-use! Did you call this on the wrong part?");
		return;
	end;
	u3.remove(p9.InUse, v7);
	u3.insert(p9.Open, p10);
	p10.CFrame = u1;
	p10.Anchored = true;
end;
function v1.SetCacheParent(p11, p12)
	assert(getmetatable(p11) == v1, ("Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"):format("SetCacheParent", "PartCache.new"));
	assert(p12:IsDescendantOf(workspace) or p12 == workspace, "Cache parent is not a descendant of Workspace! Parts should be kept where they will remain in the visible world.");
	p11.CurrentCacheParent = p12;
	for v8 = 1, #p11.Open do
		p11.Open[v8].Parent = p12;
	end;
	for v9 = 1, #p11.InUse do
		p11.InUse[v9].Parent = p12;
	end;
end;
function v1.Expand(p13, p14)
	assert(getmetatable(p13) == v1, ("Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"):format("Expand", "PartCache.new"));
	if p14 == nil then
		p14 = p13.ExpansionSize;
	end;
	for v10 = 1, p14 do
		u3.insert(p13.Open, u4(p13.Template, p13.CurrentCacheParent));
	end;
end;
function v1.Dispose(p15)
	assert(getmetatable(p15) == v1, ("Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"):format("Dispose", "PartCache.new"));
	for v11 = 1, #p15.Open do
		p15.Open[v11]:Destroy();
	end;
	for v12 = 1, #p15.InUse do
		p15.InUse[v12]:Destroy();
	end;
	p15.Template:Destroy();
	p15.Open = {};
	p15.InUse = {};
	p15.CurrentCacheParent = nil;
	p15.GetPart = nil;
	p15.ReturnPart = nil;
	p15.SetCacheParent = nil;
	p15.Expand = nil;
	p15.Dispose = nil;
end;
return v1;
