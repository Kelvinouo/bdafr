-- Decompiled with the Synapse X Luau decompiler.

local v1 = {};
v1.__index = v1;
v1.__type = "PartCache";
local u1 = CFrame.new(0, 1000000000, 0);
local u2 = require(script.Parent:WaitForChild("Table"));
function v1.new(p1, p2, p3)
	assert(p2 > 0, "PrecreatedParts can not be negative!");
	if p2 ~= 0 == false then
		warn("PrecreatedParts is 0! This may have adverse effects when initially using the cache.");
	end;
	if p1.Archivable == false then
		warn("The template's Archivable property has been set to false, which prevents it from being cloned. It will temporarily be set to true.");
	end;
	p1.Archivable = true;
	p1.Archivable = p1.Archivable;
	p1 = p1:Clone();
	local v2 = {
		Open = {}, 
		InUse = {}, 
		CurrentCacheParent = p3 or workspace, 
		Template = p1, 
		ExpansionSize = 10
	};
	setmetatable(v2, v1);
	for v3 = 1, p2 and 5 do
		local v4 = p1:Clone();
		v4.CFrame = u1;
		v4.Anchored = true;
		v4.Parent = v2.CurrentCacheParent;
		u2.insert(v2.Open, v4);
	end;
	v2.Template.Parent = nil;
	return v2;
end;
function v1.GetPart(p4)
	assert(getmetatable(p4) == v1, ("Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"):format("GetPart", "PartCache.new"));
	if #p4.Open == 0 then
		warn("No parts available in the cache! Creating [" .. p4.ExpansionSize .. "] new part instance(s) - this amount can be edited by changing the ExpansionSize property of the PartCache instance... (This cache now contains a grand total of " .. tostring(#p4.Open + #p4.InUse + p4.ExpansionSize) .. " parts.)");
		for v5 = 1, p4.ExpansionSize do
			local v6 = p4.Template:Clone();
			v6.CFrame = u1;
			v6.Anchored = true;
			v6.Parent = p4.CurrentCacheParent;
			u2.insert(p4.Open, v6);
		end;
	end;
	local v7 = p4.Open[#p4.Open];
	p4.Open[#p4.Open] = nil;
	u2.insert(p4.InUse, v7);
	return v7;
end;
function v1.ReturnPart(p5, p6)
	assert(getmetatable(p5) == v1, ("Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"):format("ReturnPart", "PartCache.new"));
	local v8 = u2.indexOf(p5.InUse, p6);
	if v8 == nil then
		error("Attempted to return part \"" .. p6.Name .. "\" (" .. p6:GetFullName() .. ") to the cache, but it's not in-use! Did you call this on the wrong part?");
		return;
	end;
	u2.remove(p5.InUse, v8);
	u2.insert(p5.Open, p6);
	p6.CFrame = u1;
	p6.Anchored = true;
end;
function v1.SetCacheParent(p7, p8)
	assert(getmetatable(p7) == v1, ("Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"):format("SetCacheParent", "PartCache.new"));
	assert(p8:IsDescendantOf(workspace) or p8 == workspace, "Cache parent is not a descendant of Workspace! Parts should be kept where they will remain in the visible world.");
	p7.CurrentCacheParent = p8;
	for v9 = 1, #p7.Open do
		p7.Open[v9].Parent = p8;
	end;
	for v10 = 1, #p7.InUse do
		p7.InUse[v10].Parent = p8;
	end;
end;
function v1.Expand(p9, p10)
	assert(getmetatable(p9) == v1, ("Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"):format("Expand", "PartCache.new"));
	if p10 == nil then
		p10 = p9.ExpansionSize;
	end;
	for v11 = 1, p10 do
		local v12 = p9.Template:Clone();
		v12.CFrame = u1;
		v12.Anchored = true;
		v12.Parent = p9.CurrentCacheParent;
		u2.insert(p9.Open, v12);
	end;
end;
function v1.Dispose(p11)
	assert(getmetatable(p11) == v1, ("Cannot statically invoke method '%s' - It is an instance method. Call it on an instance of this class created via %s"):format("Dispose", "PartCache.new"));
	for v13 = 1, #p11.Open do
		p11.Open[v13]:Destroy();
	end;
	for v14 = 1, #p11.InUse do
		p11.InUse[v14]:Destroy();
	end;
	p11.Template:Destroy();
	p11.Open = {};
	p11.InUse = {};
	p11.CurrentCacheParent = nil;
	p11.GetPart = nil;
	p11.ReturnPart = nil;
	p11.SetCacheParent = nil;
	p11.Expand = nil;
	p11.Dispose = nil;
end;
return v1;
