
-- Decompiled with the Synapse X Luau decompiler.

local v1 = {
	create = function(p1, p2, p3, p4, p5, p6, p7, p8)
		local v2 = p4 / 2;
		local v3 = p5 / 2;
		local v4 = p6 / 2;
		return {
			subRegions = {}, 
			lowerBounds = { p1 - v2, p2 - v3, p3 - v4 }, 
			upperBounds = { p1 + v2, p2 + v3, p3 + v4 }, 
			position = { p1, p2, p3 }, 
			size = { p4, p5, p6 }, 
			parent = p7, 
			depth = p7 and p7.depth + 1 or 1, 
			parentIndex = p8, 
			nodes = {}, 
			node_count = 0
		};
	end, 
	addNode = function(p9, p10)
		assert(p10);
		local v5 = p9;
		while v5 do
			if not v5.nodes[p10] then
				v5.nodes[p10] = p10;
				v5.node_count = v5.node_count + 1;
			end;
			v5 = v5.parent;		
		end;
	end, 
	moveNode = function(p11, p12, p13)
		assert(p11.depth == p12.depth, "fromLowest.depth ~= toLowest.depth");
		assert(p11 ~= p12, "fromLowest == toLowest");
		local v6 = p11;
		local v7 = p12;
		while v6 ~= v7 do
			assert(v6.nodes[p13]);
			assert(v6.node_count > 0);
			v6.nodes[p13] = nil;
			v6.node_count = v6.node_count - 1;
			if v6.node_count <= 0 and v6.parentIndex then
				assert(v6.parent);
				assert(v6.parent.subRegions[v6.parentIndex] == v6);
				v6.parent.subRegions[v6.parentIndex] = nil;
			end;
			assert(not v7.nodes[p13]);
			v7.nodes[p13] = p13;
			v7.node_count = v7.node_count + 1;
			v6 = v6.parent;
			v7 = v7.parent;		
		end;
	end, 
	removeNode = function(p14, p15)
		assert(p15);
		local v8 = p14;
		while v8 do
			assert(v8.nodes[p15]);
			assert(v8.node_count > 0);
			v8.nodes[p15] = nil;
			v8.node_count = v8.node_count - 1;
			if v8.node_count <= 0 and v8.parentIndex then
				assert(v8.parent);
				assert(v8.parent.subRegions[v8.parentIndex] == v8);
				v8.parent.subRegions[v8.parentIndex] = nil;
			end;
			v8 = v8.parent;		
		end;
	end
};
local u1 = math.sqrt(3) / 2;
function v1.getSearchRadiusSquared(p16, p17, p18)
	local v9 = p16 + u1 * p17;
	return v9 * v9 + p18;
end;
function v1.getNeighborsWithinRadius(p19, p20, p21, p22, p23, p24, p25, p26)
	assert(p26);
	local v10 = v1.getSearchRadiusSquared(p20, p19.size[1] / 2, 1E-06);
	local v11 = p20 * p20;
	for v12, v13 in pairs(p19.subRegions) do
		local l__position__14 = v13.position;
		local v15 = p21 - l__position__14[1];
		local v16 = p22 - l__position__14[2];
		local v17 = p23 - l__position__14[3];
		if v15 * v15 + v16 * v16 + v17 * v17 <= v10 then
			if v13.depth == p26 then
				for v18, v19 in pairs(v13.nodes) do
					local v20, v21, v22 = v18:GetRawPosition();
					local v23 = p21 - v20;
					local v24 = p22 - v21;
					local v25 = p23 - v22;
					local v26 = v23 * v23 + v24 * v24 + v25 * v25;
					if v26 <= v11 then
						p24[#p24 + 1] = v18:GetObject();
						p25[#p25 + 1] = v26;
					end;
				end;
			else
				v1.getNeighborsWithinRadius(v13, p20, p21, p22, p23, p24, p25, p26);
			end;
		end;
	end;
end;
function v1.getOrCreateSubRegionAtDepth(p27, p28, p29, p30, p31)
	local v27 = nil;
	v27 = p27;
	for v28 = p27.depth, p31 do
		local v29 = v1.getSubRegionIndex(v27, p28, p29, p30);
		local v30 = v27.subRegions[v29];
		if not v30 then
			v30 = v1.createSubRegion(v27, v29);
			v27.subRegions[v29] = v30;
		end;
		v27 = v30;
	end;
	return local v31;
end;
local u2 = { { 0.25, 0.25, -0.25 }, { -0.25, 0.25, -0.25 }, { 0.25, 0.25, 0.25 }, { -0.25, 0.25, 0.25 }, { 0.25, -0.25, -0.25 }, { -0.25, -0.25, -0.25 }, { 0.25, -0.25, 0.25 }, { -0.25, -0.25, 0.25 } };
function v1.createSubRegion(p32, p33)
	local l__size__32 = p32.size;
	local l__position__33 = p32.position;
	local v34 = u2[p33];
	return v1.create(l__position__33[1] + v34[1] * l__size__32[1], l__position__33[2] + v34[2] * l__size__32[2], l__position__33[3] + v34[3] * l__size__32[3], l__size__32[1] / 2, l__size__32[2] / 2, l__size__32[3] / 2, p32, p33);
end;
function v1.inRegionBounds(p34, p35, p36, p37)
	local l__lowerBounds__35 = p34.lowerBounds;
	local l__upperBounds__36 = p34.upperBounds;
	local v37 = false;
	if l__lowerBounds__35[1] <= p35 then
		v37 = false;
		if p35 <= l__upperBounds__36[1] then
			v37 = false;
			if l__lowerBounds__35[2] <= p36 then
				v37 = false;
				if p36 <= l__upperBounds__36[2] then
					v37 = false;
					if l__lowerBounds__35[3] <= p37 then
						v37 = p37 <= l__upperBounds__36[3];
					end;
				end;
			end;
		end;
	end;
	return v37;
end;
function v1.getSubRegionIndex(p38, p39, p40, p41)
	if p38.position[1] < p39 then
		local v38 = 1;
	else
		v38 = 2;
	end;
	if p40 <= p38.position[2] then
		v38 = v38 + 4;
	end;
	if p38.position[3] <= p41 then
		v38 = v38 + 2;
	end;
	return v38;
end;
function v1.getTopLevelRegionHash(p42, p43, p44)
	return p42 * 73856093 + p43 * 19351301 + p44 * 83492791;
end;
function v1.getTopLevelRegionCellIndex(p45, p46, p47, p48)
	return math.floor(p46 / p45[1] + 0.5), math.floor(p47 / p45[2] + 0.5), math.floor(p48 / p45[3] + 0.5);
end;
function v1.getTopLevelRegionPosition(p49, p50, p51, p52)
	return p49[1] * p50, p49[2] * p51, p49[3] * p52;
end;
function v1.areEqualTopRegions(p53, p54, p55, p56)
	local l__position__39 = p53.position;
	local v40 = false;
	if l__position__39[1] == p54 then
		v40 = false;
		if l__position__39[2] == p55 then
			v40 = l__position__39[3] == p56;
		end;
	end;
	return v40;
end;
function v1.findRegion(p57, p58, p59, p60, p61)
	local v41, v42, v43 = v1.getTopLevelRegionCellIndex(p58, p59, p60, p61);
	local v44 = p57[v1.getTopLevelRegionHash(v41, v42, v43)];
	if not v44 then
		return nil;
	end;
	local v45, v46, v47 = v1.getTopLevelRegionPosition(p58, v41, v42, v43);
	for v48, v49 in pairs(v44) do
		if v1.areEqualTopRegions(v49, v45, v46, v47) then
			return v49;
		end;
	end;
	return nil;
end;
function v1.getOrCreateRegion(p62, p63, p64, p65, p66)
	local v50, v51, v52 = v1.getTopLevelRegionCellIndex(p63, p64, p65, p66);
	local v53 = v1.getTopLevelRegionHash(v50, v51, v52);
	local v54 = p62[v53];
	if not v54 then
		v54 = {};
		p62[v53] = v54;
	end;
	local v55, v56, v57 = v1.getTopLevelRegionPosition(p63, v50, v51, v52);
	for v58, v59 in pairs(v54) do
		if v1.areEqualTopRegions(v59, v55, v56, v57) then
			return v59;
		end;
	end;
	local v60 = v1.create(v55, v56, v57, p63[1], p63[2], p63[3]);
	table.insert(v54, v60);
	return v60;
end;
return v1;

